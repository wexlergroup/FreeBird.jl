<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorials ¬∑ FreeBird.jl</title><meta name="title" content="Tutorials ¬∑ FreeBird.jl"/><meta property="og:title" content="Tutorials ¬∑ FreeBird.jl"/><meta property="twitter:title" content="Tutorials ¬∑ FreeBird.jl"/><meta name="description" content="Documentation for FreeBird.jl."/><meta property="og:description" content="Documentation for FreeBird.jl."/><meta property="twitter:description" content="Documentation for FreeBird.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="FreeBird.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FreeBird.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">FreeBird.jl</a></li><li class="is-active"><a class="tocitem" href>Tutorials</a><ul class="internal"><li><a class="tocitem" href="#Atomistic-walkers-and-nested-sampling"><span>Atomistic walkers and nested sampling</span></a></li><li><a class="tocitem" href="#Lattice-walkers-and-exact-enumeration"><span>Lattice walkers and exact enumeration</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Modules and Documentation</span><ul><li><a class="tocitem" href="../AbstractLiveSets/"><code>AbstractLiveSets</code></a></li><li><a class="tocitem" href="../AbstractWalkers/"><code>AbstractWalkers</code></a></li><li><a class="tocitem" href="../SamplingSchemes/"><code>SamplingSchemes</code></a></li><li><a class="tocitem" href="../AbstractPotentials/"><code>AbstractPotentials</code></a></li><li><a class="tocitem" href="../AbstractHamiltonians/"><code>AbstractHamiltonians</code></a></li><li><a class="tocitem" href="../EnergyEval/"><code>EnergyEval</code></a></li><li><a class="tocitem" href="../MonteCarloMoves/"><code>MonteCarloMoves</code></a></li><li><a class="tocitem" href="../FreeBirdIO/"><code>FreeBirdIO</code></a></li><li><a class="tocitem" href="../AnalysisTools/"><code>AnalysisTools</code></a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/wexlergroup/FreeBird.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/wexlergroup/FreeBird.jl/blob/main/scripts/tutorials.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FreeBird.jl-Tutorial"><a class="docs-heading-anchor" href="#FreeBird.jl-Tutorial">FreeBird.jl Tutorial</a><a id="FreeBird.jl-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#FreeBird.jl-Tutorial" title="Permalink"></a></h1><p>This is a tutorial to using the FreeBird.jl package. It covers the basic functionalities of the package, such as generating atomistic and lattice walkers, defining a potential energy function or Hamiltonian, and running a sampling simulation. For more detailed information, please refer to the documentation of the package. You can find the runnable version of this script in the <code>scripts</code> directory of the package.</p><h2 id="Atomistic-walkers-and-nested-sampling"><a class="docs-heading-anchor" href="#Atomistic-walkers-and-nested-sampling">Atomistic walkers and nested sampling</a><a id="Atomistic-walkers-and-nested-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Atomistic-walkers-and-nested-sampling" title="Permalink"></a></h2><p>First, let&#39;s load the FreeBird.jl package:</p><pre><code class="language-julia hljs">using FreeBird</code></pre><p>Now, let&#39;s create a few configurations of a simple atomistic system with six particles in a 3D box.</p><pre><code class="language-julia hljs">single_config = generate_initial_configs(1, 562.5, 6; particle_type=:H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{AtomsBase.FastSystem{3, AtomsBase.PeriodicCell{3, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}}, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}, Quantity{Float64, ùêå, Unitful.FreeUnits{(u,), ùêå, nothing}}, AtomsBase.ChemicalSpecies}}:
 FastSystem(H‚ÇÜ, periodicity = FFF)</code></pre><p>The function above has generated a single configuration, with 562.5 √Ö<span>$^3$</span> volume per particle, and 6 particles of type H. Note that the <code>particle_type</code> keyword argument can be used to specify the type of particle, i.e., chemical element. By default, the type is set to <code>:H</code>. Use <code>?generate_initial_configs</code> in the REPL to see the documentation of the function. Or see <a href="../FreeBirdIO/#FreeBird.FreeBirdIO.generate_initial_configs-Tuple{Int64, Float64, Int64}"><code>generate_initial_configs</code></a>.</p><p>Let&#39;s inspect the generated configuration using the <code>vew_structure</code> function:</p><pre><code class="language-julia hljs">single_config[1] |&gt; view_structure</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">          .------------------------------------.
         /|                                    |
        / |                                    |
       /  |                                    |
      /   |                                    |
     /   H|                                    |
    /     |                                    |
   /      |                                    |
  /       |                                    |
 *        |                                    |
 |        |                                    |
 |        |                                    |
 |    H   |                                    |
 |        |                                    |
 |        |                                    |
 |        |                                    |
 |        |                                    |
 |        |                     H              |
 |        .------------------------------------.
 |       /               H                    /
 |      /                                    /
 |     /                                    /
 |    /                                    /
 |   /                 H                  /
 |  H                                    /
 | /                                    /
 |/                                    /
 *------------------------------------*</code></pre><p>It&#39;s of a <code>FastSystem</code> type from <code>AtomsBase</code>. The dimensions of the box are 15 √Ö x 15 √Ö x 15 √Ö, following the volume per particle specified. The positions of the particles are randomly generated within the box.</p><p>Now, let&#39;s generate a few more configurations:</p><pre><code class="language-julia hljs">configs = generate_initial_configs(120, 562.5, 6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">120-element Vector{AtomsBase.FastSystem{3, AtomsBase.PeriodicCell{3, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}}, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}, Quantity{Float64, ùêå, Unitful.FreeUnits{(u,), ùêå, nothing}}, AtomsBase.ChemicalSpecies}}:
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 ‚ãÆ
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)
 FastSystem(H‚ÇÜ, periodicity = FFF)</code></pre><p>The function above has generated 120 configurations, again, with 562.5 √Ö<span>$^3$</span> volume per particle, and 6 particles of type H. These configurations will be served as the initial walkers for a sampling run, but first, we need to warp them into the <a href="../AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker"><code>AtomWalker</code></a> type defined in FreeBird.jl.</p><pre><code class="language-julia hljs">walkers = AtomWalker.(generate_initial_configs(120, 562.5, 6));</code></pre><p>Let&#39;s inquire the type of the <code>walkers</code> variable:</p><pre><code class="language-julia hljs">walkers |&gt; typeof</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vector{AtomWalker{1}}<span class="sgr90"> (alias for Array{AtomWalker{1}, 1})</span></code></pre><p>The <code>walkers</code> variable is of a <code>Vector{AtomWalker{1}}</code> type, which is a vector of <code>AtomWalker{1}</code> objects. The <code>AtomWalker{1}</code> type is a parametrized type, where the parameter is the number of components in the system. In this case, the system has only one component, consisting of 6 particles of type H.</p><p>To define how these particles interact with each other, we need to create a potential energy function. Let&#39;s use the Lennard-Jones potential:</p><pre><code class="language-julia hljs">lj = LJParameters(epsilon=0.1, sigma=2.5, cutoff=4.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LJParameters(0.1 eV, 2.5 √Ö, 4.0, -9.763240814208984e-5 eV)</code></pre><p>The <a href="../AbstractPotentials/#FreeBird.AbstractPotentials.LJParameters"><code>LJParameters</code></a> type is a struct that holds the parameters of the Lennard-Jones potential. The <code>epsilon</code> and <code>sigma</code> fields are the energy and length scales of the potential, respectively. The <code>cutoff</code> field is the distance at which the potential is truncated. An energy shift is applied to the potential to ensure continuity at the cutoff distance, automatically in this case. See the documentation of the <code>LJParameters</code> type for more information and examples.</p><p>We now can create a so-called <em>liveset</em> that will be used to store the walkers during the simulation. The <code>lj</code> potential will be used to attached and used to calculate the potential energy of the walkers.</p><pre><code class="language-julia hljs">ls = LJAtomWalkers(walkers, lj)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LJAtomWalkers(AtomWalker{1}, LJParameters):
[1] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.005069105579886958 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[2] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : 662.3852163820451 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[3] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.10925875658902844 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[4] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.016586288305330564 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[5] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.1327923928495812 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

‚ãÆ
Omitted 110 walkers
‚ãÆ

[116] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.024546498231608645 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[117] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.20033984631169255 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[118] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.002930141491616368 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[119] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : 84.473705528293 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[120] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -0.009130163932994475 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

LJParameters(0.1 eV, 2.5 √Ö, 4.0, -9.763240814208984e-5 eV)
</code></pre><p>Here, <code>ls</code> is a <a href="../AbstractLiveSets/#FreeBird.AbstractLiveSets.LJAtomWalkers"><code>LJAtomWalkers</code></a> type, and has the <code>walkers</code> and <code>lj</code> fields attached to it.</p><p>Now, time to set up a simulation. We will be using nested sampling, a Bayesian-inference inspired method, as an example here. First, we need to define the nested sampling parameters:</p><pre><code class="language-julia hljs">ns_params = NestedSamplingParameters(mc_steps=200, step_size=0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NestedSamplingParameters(200, 0.01, 0.1, 1.0e-6, 1.0, (0.25, 0.75), 0, 100, 1234)</code></pre><p>The <a href="../SamplingSchemes/#FreeBird.SamplingSchemes.NestedSamplingParameters"><code>NestedSamplingParameters</code></a> type is a struct that holds the parameters of the nested sampling algorithm. The fields are as follows:</p><ul><li><code>mc_steps::Int64</code>: The number of total Monte Carlo moves to perform.</li><li><code>initial_step_size</code>::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.</li><li><code>step_size::Float64</code>: The on-the-fly step size used in the sampling process.</li><li><code>step_size_lo::Float64</code>: The lower bound of the step size.</li><li><code>step_size_up::Float64</code>: The upper bound of the step size.</li><li><code>accept_range::Tuple{Float64, Float64}</code>: The range of acceptance rates for adjusting the step size.</li><li><code>fail_count::Int64</code>: The number of failed MC moves in a row.</li><li><code>allowed_fail_count::Int64</code>: The maximum number of failed MC moves allowed before resetting the step size.</li><li><code>random_seed::Int64</code>: The seed for the random number generator.</li></ul><p>Speaking of the Monte Carlo moves, we need to define that too:</p><pre><code class="language-julia hljs">mc = MCRandomWalkClone()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MCRandomWalkClone([1, 2, 3])</code></pre><p>The <a href="../SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkClone"><code>MCRandomWalkClone</code></a> type is a type of Monte Carlo move that indicates a new walker is created by cloning an existing walker and then decorrelate the positions of the particles.</p><p>We also need to specify how we want to save the data and the output:</p><pre><code class="language-julia hljs">save = SaveEveryN(n_traj=10, n_snap=20_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SaveEveryN(&quot;output_df.csv&quot;, &quot;output.traj.extxyz&quot;, &quot;output.ls.extxyz&quot;, 10, 20000, 1)</code></pre><p>The <a href="../FreeBirdIO/#FreeBird.FreeBirdIO.SaveEveryN"><code>SaveEveryN</code></a> type is a struct that holds the parameters of the saving routine.</p><p>Now, we are ready to run the nested sampling simulation:</p><pre><code class="language-julia hljs">energies, liveset, _ = nested_sampling(ls, ns_params, 20_000, mc, save)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">20000√ó2 DataFrame
   Row ‚îÇ iter   emax
       ‚îÇ<span class="sgr90"> Int64  Float64
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     1 ‚îÇ     1      4.42386e9
     2 ‚îÇ     2  80532.0
     3 ‚îÇ     3  25673.1
     4 ‚îÇ     4   1621.21
     5 ‚îÇ     5    860.51
     6 ‚îÇ     6    662.385
     7 ‚îÇ     7    463.343
     8 ‚îÇ     8     84.4737
   ‚ãÆ   ‚îÇ   ‚ãÆ          ‚ãÆ
 19994 ‚îÇ 19994     -1.26974
 19995 ‚îÇ 19995     -1.26974
 19996 ‚îÇ 19996     -1.26974
 19997 ‚îÇ 19997     -1.26974
 19998 ‚îÇ 19998     -1.26974
 19999 ‚îÇ 19999     -1.26974
 20000 ‚îÇ 20000     -1.26974
</span><span class="sgr36">            19985 rows omitted, LJAtomWalkers(AtomWalker{1}, LJParameters):
[1] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417394667516 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[2] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.26974173946681 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[3] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417394668502 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[4] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417394670671 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[5] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417394671477 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

‚ãÆ
Omitted 110 walkers
‚ãÆ

[116] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417395146888 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[117] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417395240356 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[118] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.269741739528631 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[119] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.2697417395295836 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[120] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodicity = FFF)
    energy             : -1.269741739471832 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

LJParameters(0.1 eV, 2.5 √Ö, 4.0, -9.763240814208984e-5 eV)
, NestedSamplingParameters(200, 0.01, 6.388057090915513e-6, 1.0e-6, 1.0, (0.25, 0.75), 0, 100, 1234))</span></span></code></pre><p>The results of the simulation are stored in the <code>energies</code> and <code>liveset</code> variables. The <code>energies</code> variable is a <code>DataFrame</code> that contains the energies of the walkers at each iteration. The <code>liveset</code> variable is the final liveset after the simulation. Let&#39;s see how the walkers look like after the simulation:</p><pre><code class="language-julia hljs">liveset.walkers[1].configuration |&gt; view_structure</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">          .------------------------------------.
         /|                                    |
        / |                                    |
       /  |                                    |
      /   |                                    |
     /    |                                    |
    /     |                                    |
   /      |                                    |
  /       |                 H                  |
 *        |                                    |
 |        |           H                        |
 |        |             H   H                  |
 |        |                   H                |
 |        |             H                      |
 |        |                                    |
 |        |                                    |
 |        |                                    |
 |        |                                    |
 |        .------------------------------------.
 |       /                                    /
 |      /                                    /
 |     /                                    /
 |    /                                    /
 |   /                                    /
 |  /                                    /
 | /                                    /
 |/                                    /
 *------------------------------------*</code></pre><p>They should be in a more ordered state, in this case, a cluster, than the initial gaseous state.</p><h3 id="Calculating-heat-capacity-with-AnalysisTools-module"><a class="docs-heading-anchor" href="#Calculating-heat-capacity-with-AnalysisTools-module">Calculating heat capacity with <code>AnalysisTools</code> module</a><a id="Calculating-heat-capacity-with-AnalysisTools-module-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-heat-capacity-with-AnalysisTools-module" title="Permalink"></a></h3><p>The <a href="../AnalysisTools/#FreeBird.AnalysisTools"><code>AnalysisTools</code></a> module provides functions to calculate the heat capacity of the system. First, we calculate the <code>œâ</code> factors, which account for the fractions of phase-space volume sampled during each nested sampling iteration, defined as:</p><p class="math-container">\[\omega_i = \frac{1}{N+1} \left(\frac{N}{N+1}\right)^i\]</p><p>where <span>$N$</span> is the number of walkers and <span>$i$</span> is the iteration number.</p><pre><code class="language-julia hljs">œâi = œâ·µ¢(energies.iter, 120);</code></pre><p>Let&#39;s shift the energies to be greater than or equal to zero, making the calculation of the heat capacity more stable.</p><pre><code class="language-julia hljs">Ei = energies.emax .- minimum(energies.emax);</code></pre><p>Specify the temperatures that we are interested in, in units of Kelvin.</p><pre><code class="language-julia hljs">Ts = collect(1:0.1:1000);</code></pre><p>Define the Boltzmann constant in units of eV/K.</p><pre><code class="language-julia hljs">kb = 8.617333262e-5 # eV/K</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8.617333262e-5</code></pre><p>Calculate the inverse temperatures</p><pre><code class="language-julia hljs">Œ≤ = 1 ./(kb.*Ts);</code></pre><p>Define the degrees of freedom, which is 3√ó6 for the 6-particle system.</p><pre><code class="language-julia hljs">dof = 18</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">18</code></pre><p>Calculate the heat capacities as a function of temperature using the <code>cv</code> function,</p><p class="math-container">\[C_V(\beta) = \frac{\mathrm{dof} \cdot k_B}{2} + k_B \beta^2 \left(\frac{\sum_i \omega_i E_i^2 \exp(-E_i \beta)}{Z(\beta)} - U(\beta)^2\right)\]</p><pre><code class="language-julia hljs">cvs = cv(energies, Œ≤, dof, 120);</code></pre><p>Let&#39;s plot the heat capacity as a function of temperature</p><pre><code class="language-julia hljs">using Plots
plot(Ts, cvs./kb, xlabel=&quot;Temperature (K)&quot;, ylabel=&quot;Heat Capacity (\$k_B\$)&quot;, label=&quot;LJ\$_6\$&quot;)</code></pre><img src="6661334d.svg" alt="Example block output"/><p>The plot should show the heat capacity as a function of temperature for the 6-particle Lennard-Jones system, with a main peak around 400 K, representing the phase transition, and some fluctuations at low temperatures, and tailing off to zero at high temperatures.</p><p>That&#39;s it! You have successfully run a nested sampling simulation using the FreeBird.jl package.</p><h2 id="Lattice-walkers-and-exact-enumeration"><a class="docs-heading-anchor" href="#Lattice-walkers-and-exact-enumeration">Lattice walkers and exact enumeration</a><a id="Lattice-walkers-and-exact-enumeration-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-walkers-and-exact-enumeration" title="Permalink"></a></h2><p>Another feature of FreeBird.jl is the ability to work with lattice systems. The lattice systems are defined by the <a href="../AbstractWalkers/#FreeBird.AbstractWalkers.MLattice"><code>MLattice</code></a> which is a parametrized type.</p><pre><code class="language-julia hljs">MLattice{C,G}(
    lattice_vectors::Matrix{Float64},
    basis::Vector{Tuple{Float64, Float64, Float64}},
    supercell_dimensions::Tuple{Int64, Int64, Int64},
    periodicity::Tuple{Bool, Bool, Bool},
    components::Vector{Vector{Bool}},
    adsorptions::Vector{Bool},
    cutoff_radii::Vector{Float64},
) where {C,G}</code></pre><p>The <code>C</code> parameter is the number of components in the system, and the <code>G</code> parameter defines the geometry of the lattice.</p><p>Now, let&#39;s create a simple square lattice system with single component:</p><pre><code class="language-julia hljs">ml = MLattice{1,SquareLattice}(components=[[1,2,3,4]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 16 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors cutoffs [1.1, 1.5]
    occupations          : 
      ‚óè ‚óè ‚óè ‚óè 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
    adsorptions          : full adsorption
</code></pre><p>When you run the above code, the outer constructor of <code>MLattice</code> will be called. Many of the arguments are optional and have default values. The <code>components</code> argument is a vector of vectors that defines the components of the system. The <code>components=[[1,2,3,4]]</code> argument specifies that the system has a single component, and the first four sites are occupied.</p><pre><code class="language-julia hljs">MLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,
    basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],
    supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),
    periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),
    cutoff_radii::Vector{Float64}=[1.1, 1.5],
    components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,
    adsorptions::Union{Vector{Int},Symbol}=:full)</code></pre><p>You may notice that the above code returns a <code>SLattice</code> type. The <code>SLattice</code> type is simply an alias for the <code>MLattice{1,G}</code>, where <code>G</code> is the geometry of the lattice and the number of components is fixed to 1. You can also directly call the <code>SLattice</code>, it will give the same result:</p><pre><code class="language-julia hljs">sl = SLattice{SquareLattice}(components=[[1,2,3,4]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 16 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors cutoffs [1.1, 1.5]
    occupations          : 
      ‚óè ‚óè ‚óè ‚óè 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
    adsorptions          : full adsorption
</code></pre><p>Now, let&#39;s define a Hamiltonian for the lattice system:</p><pre><code class="language-julia hljs">ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u&quot;eV&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GenericLatticeHamiltonian{2,Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}:
    on_site_interaction:      -0.04 eV
    nth_neighbor_interactions: [-0.01, -0.0025] eV
</code></pre><p>The <a href="../AbstractHamiltonians/#FreeBird.AbstractHamiltonians.GenericLatticeHamiltonian"><code>GenericLatticeHamiltonian</code></a> type is a struct that holds the parameters of the Hamiltonian. The first argument is the on-site energy, and the second argument is the list of n-th nearest-neighbors energy. The third argument is the unit of the energy.</p><p>To run exact enumeration, we only need a initial walker/lattice configuration, and the Hamiltonian. Let&#39;s run the exact enumeration:</p><pre><code class="language-julia hljs">df, ls = exact_enumeration(sl, ham)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">1820√ó2 DataFrame
  Row ‚îÇ energy      config
      ‚îÇ<span class="sgr90"> Quantity‚Ä¶   Array‚Ä¶
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    1 ‚îÇ    -0.2 eV  Vector{Bool}[[1, 1, 1, 1, 0, 0, ‚Ä¶
    2 ‚îÇ -0.1925 eV  Vector{Bool}[[1, 1, 1, 0, 1, 0, ‚Ä¶
    3 ‚îÇ  -0.195 eV  Vector{Bool}[[1, 1, 1, 0, 0, 1, ‚Ä¶
    4 ‚îÇ -0.1925 eV  Vector{Bool}[[1, 1, 1, 0, 0, 0, ‚Ä¶
    5 ‚îÇ  -0.185 eV  Vector{Bool}[[1, 1, 1, 0, 0, 0, ‚Ä¶
    6 ‚îÇ   -0.18 eV  Vector{Bool}[[1, 1, 1, 0, 0, 0, ‚Ä¶
    7 ‚îÇ   -0.18 eV  Vector{Bool}[[1, 1, 1, 0, 0, 0, ‚Ä¶
    8 ‚îÇ   -0.18 eV  Vector{Bool}[[1, 1, 1, 0, 0, 0, ‚Ä¶
  ‚ãÆ   ‚îÇ     ‚ãÆ                       ‚ãÆ
 1814 ‚îÇ -0.1925 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 1815 ‚îÇ  -0.195 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 1816 ‚îÇ  -0.185 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 1817 ‚îÇ -0.1925 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 1818 ‚îÇ  -0.195 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 1819 ‚îÇ -0.1925 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 1820 ‚îÇ    -0.2 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
</span><span class="sgr36">                                     1805 rows omitted, LatticeGasWalkers(LatticeWalker{1}, GenericLatticeHamiltonian{2, Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}):
    lattice_vectors:      [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    supercell_dimensions: (4, 4, 1)
    periodicity:          (true, true, false)
    basis:                [(0.0, 0.0, 0.0)]
[1] energy = -0.2 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[2] energy = -0.1925 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[3] energy = -0.195 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[4] energy = -0.1925 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[5] energy = -0.185 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
‚ãÆ
Omitted 1810 walkers
‚ãÆ

[1816] energy = -0.185 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]
[1817] energy = -0.1925 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1]
[1818] energy = -0.195 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1]
[1819] energy = -0.1925 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1]
[1820] energy = -0.2 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]

GenericLatticeHamiltonian{2,Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}:
    on_site_interaction:      -0.04 eV
    nth_neighbor_interactions: [-0.01, -0.0025] eV

)</span></span></code></pre><p>The results of the exact enumeration are stored in the <code>df</code> and <code>ls</code> variables. The <code>df</code> variable is a <code>DataFrame</code> that contains the list of energies, as well as the configurations. The <code>ls</code> variable is the final liveset that contains all possible configurations of the lattice system. Let&#39;s see how the first configuration looks like:</p><pre><code class="language-julia hljs">ls.walkers[1].configuration</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 16 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors cutoffs [1.1, 1.5]
    occupations          : 
      ‚óè ‚óè ‚óè ‚óè 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
    adsorptions          : full adsorption
</code></pre><p>It&#39;s the initial configuration of the lattice system. Let&#39;s see how the last configuration looks like:</p><pre><code class="language-julia hljs">ls.walkers[end].configuration</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 16 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors cutoffs [1.1, 1.5]
    occupations          : 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óè ‚óè ‚óè ‚óè 
    adsorptions          : full adsorption
</code></pre><p>Be warned that the exact enumeration can be computationally expensive for large systems.</p><h3 id="Calculating-heat-capacity"><a class="docs-heading-anchor" href="#Calculating-heat-capacity">Calculating heat capacity</a><a id="Calculating-heat-capacity-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-heat-capacity" title="Permalink"></a></h3><p>Since we enumerated all possible configurations of the lattice system, we can calculate the partition function, then heat capacity directly.</p><p>Let&#39;s calculate the heat capacity for the lattice system: Define the temperatures that we are interested in, in units of Kelvin.</p><pre><code class="language-julia hljs">Ts = collect(1:0.1:500);</code></pre><p>Define the Boltzmann constant in units of eV/K.</p><pre><code class="language-julia hljs">kb = 8.617333262e-5 # eV/K</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8.617333262e-5</code></pre><p>Convert them to inverse temperatures</p><pre><code class="language-julia hljs">Œ≤s = 1 ./(kb.*Ts);</code></pre><p>Extract the energies from the DataFrame, keeping the values only</p><pre><code class="language-julia hljs">es = [e.val for e in df.energy];</code></pre><p>Since this is not a nested sampling run, each configuration carries the same weight:</p><pre><code class="language-julia hljs">œâ_1 = ones(length(df.energy));</code></pre><p>And for a lattice, the degrees of freedom is 0:</p><pre><code class="language-julia hljs">dof = 0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>Now we can use a scaler version of the <a href="../AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{DataFrames.DataFrame, Vector{Float64}, Int64, Int64}"><code>cv</code></a> function to calculate the heat capacity:</p><pre><code class="language-julia hljs">cvs = [cv(Œ≤, œâ_1, es, dof) for Œ≤ in Œ≤s];</code></pre><p>Let&#39;s plot the heat capacity as a function of temperature</p><pre><code class="language-julia hljs">using Plots
plot(Ts, cvs./kb, xlabel=&quot;Temperature (K)&quot;, ylabel=&quot;Heat Capacity (\$k_B\$)&quot;, label=&quot;Square Lattice&quot;)</code></pre><img src="6c1f6e0f.svg" alt="Example block output"/><p>You should expect to see a single peak in the heat capacity curve around 40 K, and tailing off to zero at high temperatures.</p><p>That&#39;s it! You have successfully run an exact enumeration simulation using the FreeBird.jl package.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ FreeBird.jl</a><a class="docs-footer-nextpage" href="../examples/">Examples ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 9 June 2025 21:47">Monday 9 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
