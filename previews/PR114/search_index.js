var documenterSearchIndex = {"docs":
[{"location":"FreeBirdIO/#FreeBirdIO","page":"FreeBirdIO","title":"FreeBirdIO","text":"","category":"section"},{"location":"FreeBirdIO/#Functions","page":"FreeBirdIO","title":"Functions","text":"","category":"section"},{"location":"FreeBirdIO/","page":"FreeBirdIO","title":"FreeBirdIO","text":"Modules = [FreeBirdIO]","category":"page"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO","text":"FreeBirdIO\n\nModule for input/output operations in the FreeBird package.\n\n\n\n\n\n","category":"module"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.DataSavingStrategy","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.DataSavingStrategy","text":"abstract type DataSavingStrategy\n\nAbstract type representing a strategy for saving data.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.SaveEveryN","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.SaveEveryN","text":"struct SaveEveryN <: DataSavingStrategy\n\nSaveEveryN is a concrete subtype of DataSavingStrategy that specifies saving data every N steps.\n\nFields\n\ndf_filename::String: The name of the file to save the DataFrame to.\nwk_filename::String: The name of the file to save the atom walker to.\nls_filename::String: The name of the file to save the liveset to.\nn_traj::Int: The number of steps between each save of the culled walker into a trajectory file.\nn_snap::Int: The number of steps between each save of the liveset into a snapshot file.\nn_info::Int: The number of steps between each print of information.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.SaveFreePartEveryN","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.SaveFreePartEveryN","text":"struct SaveFreePartEveryN <: DataSavingStrategy\n\nSaveFreePartEveryN is a concrete subtype of DataSavingStrategy that specifies saving data every N steps. Only the free particles are saved into the trajectory and snapshot files.\n\nFields\n\ndf_filename::String: The name of the file to save the DataFrame to.\nwk_filename::String: The name of the file to save the atom walker to.\nls_filename::String: The name of the file to save the liveset to.\nn_traj::Int: The number of steps between each save of the culled walker into a trajectory file.\nn_snap::Int: The number of steps between each save of the liveset into a snapshot file.\nn_info::Int: The number of steps between each print of information.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.append_system-Tuple{AtomsBase.FlexibleSystem, AtomsBase.FlexibleSystem}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.append_system","text":"append_system(ats1::FlexibleSystem, ats2::FlexibleSystem)\n\nAppend two FlexibleSystem objects into a single FastSystem object. The first argument is the system to be appended to, and its bounding box and boundary conditions  will be used for the new system.\n\nArguments\n\nats1::FlexibleSystem: The base system to be appended.\nats2::FlexibleSystem: The system to append.\n\nReturns\n\nnew_list: A new FastSystem object containing the appended systems.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.append_system-Union{Tuple{T}, Tuple{AtomsBase.FlexibleSystem, Vector{T}}} where T","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.append_system","text":"append_system(ats1::FlexibleSystem, ats2::Vector{FlexibleSystem})\n\nAppend a FlexibleSystem object to a vector of FlexibleSystem objects. The first argument is the system to be appended to, and its bounding box and boundary conditions will be used for the new systems.\n\nArguments\n\nats1::FlexibleSystem: The base system to be appended.\nats2::Vector{FlexibleSystem}: A vector of FlexibleSystem objects to append.\n\nReturns\n\nconfigs: A vector of FastSystem objects containing the appended systems.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.append_walker-Union{Tuple{C}, Tuple{String, AtomWalker{C}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.append_walker","text":"append_walker(filename::String, at::AtomWalker)\n\nAppend an AtomWalker object to a file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.convert_system_to_walker-Tuple{AtomsBase.FlexibleSystem, Bool}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.convert_system_to_walker","text":"convert_system_to_walker(at::FlexibleSystem, resume::Bool)\n\nConverts a FlexibleSystem object to an AtomWalker object.\n\nArguments\n\nat::FlexibleSystem: The FlexibleSystem object to convert.\nresume::Bool: Whether to resume from previous data.\n\nReturns\n\nAtomWalker: The converted AtomWalker object.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.convert_walker_to_system-Tuple{AtomWalker}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.convert_walker_to_system","text":"convert_walker_to_system(at::AtomWalker)\n\nConverts an AtomWalker object to an AbstractSystem object.\n\nArguments\n\nat::AtomWalker: The AtomWalker object to be converted.\n\nReturns\n\nAbstractSystem: The converted AbstractSystem object.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_initial_configs-Tuple{Int64, Float64, Int64}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_initial_configs","text":"generate_initial_configs(num_walkers::Int, volume_per_particle::Float64, num_particle::Int; particle_type::Symbol=:H)\n\nGenerate initial configurations for a given number of walkers.\n\nArguments\n\nnum_walkers::Int: The number of walkers.\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Int: The number of particles.\nparticle_type::Symbol=:H: The type of particle (default is :H).\n\nReturns\n\nAn array of initial configurations for each walker.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_initial_configs-Tuple{Int64, Float64, Vector{Int64}}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_initial_configs","text":"generate_initial_configs(num_walkers::Int, volume_per_particle::Float64, num_particle::Vector{Int}; particle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)])\n\nGenerate initial configurations for a given number of walkers with multiple particle types.\n\nArguments\n\nnum_walkers::Int: The number of walkers.\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Vector{Int}: A vector containing the number of particles of each type.\nparticle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)]: A vector of symbols representing the types of particles (default is hydrogen and oxygen).\n\nReturns\n\nAn array of initial configurations for each walker, where each configuration contains particles of the specified types.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_multi_type_random_starting_config-Tuple{Float64, Vector{Int64}}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_multi_type_random_starting_config","text":"generate_multi_type_random_starting_config(volume_per_particle::Float64, num_particle::Vector{Int}; particle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)])\n\nGenerate a random starting configuration for a system of particles with multiple types.\n\nArguments\n\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Vector{Int}: The number of particles of each type.\nparticle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)]: The types of particles.\n\nReturns\n\nFastSystem: A FastSystem object representing the generated system.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_random_starting_config-Tuple{Float64, Int64}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_random_starting_config","text":"generate_random_starting_config(volume_per_particle::Float64, num_particle::Int; particle_type::Symbol=:H)\n\nGenerate a random starting configuration for a system of particles.\n\nArguments\n\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Int: The number of particles.\nparticle_type::Symbol=:H: The type of particle (default is hydrogen).\n\nReturns\n\nFastSystem: A FastSystem object representing the generated system.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_configs-Tuple{String, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_configs","text":"read_configs(filename::String, pbc::Vector)\n\nReads atomic configurations from a file and applies periodic boundary conditions.\n\nArguments\n\nfilename::String: The name of the file containing the atomic configurations.\npbc::Vector: A vector specifying the periodic boundary conditions.\n\nReturns\n\nAn array of atomic configurations with periodic boundary conditions applied.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_configs-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_configs","text":"read_configs(filename::String; pbc::String=\"TTT\")\n\nReads configurations from a file.\n\nArguments\n\nfilename::String: The name of the file to read configurations from.\npbc::String=\"TTT\": Periodic boundary conditions. A string of length 3, where each character represents whether the corresponding dimension has periodic boundary conditions ('T') or not ('F').\n\nReturns\n\nThe configurations read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_config-Tuple{String, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_config","text":"read_single_config(filename::String, pbc::Vector)\n\nReads a single configuration from the specified file and sets the periodic boundary conditions (PBC) for the atoms.\n\nArguments\n\nfilename::String: The name of the file to read the configuration from.\npbc::Vector: A vector specifying the periodic boundary conditions.\n\nReturns\n\nat::Atoms: The atoms with the PBC set.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_config-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_config","text":"read_single_config(filename::String; pbc::String=\"TTT\")\n\nReads a single configuration from the specified file.\n\nArguments\n\nfilename::String: The name of the file to read from.\npbc::String=\"TTT\": The periodic boundary conditions. Default is \"TTT\".\n\nReturns\n\nThe configuration read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_walker-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_walker","text":"read_single_walker(filename::String; pbc::String=\"TTT\", resume::Bool=true)\n\nReads a single walker from the specified file.\n\nArguments\n\nfilename::String: The path to the file containing the walker data.\npbc::String: (optional) The periodic boundary conditions. Default is \"TTT\".\nresume::Bool: (optional) Whether to resume reading from a previous checkpoint. Default is true.\n\nReturns\n\nThe walker object read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_walkers-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_walkers","text":"read_walkers(filename::String; pbc::String=\"TTT\", resume::Bool=true)\n\nReads walker configurations from a file.\n\nArguments\n\nfilename::String: The name of the file to read the walker configurations from.\npbc::String: A string specifying the periodic boundary conditions. Default is \"TTT\".\nresume::Bool: A boolean indicating whether to resume reading from a previous checkpoint. Default is true.\n\nReturns\n\nAn array of walker objects.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.set_pbc-Tuple{ExtXYZ.Atoms, Vector{Bool}}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.set_pbc","text":"set_pbc(at::Atoms, pbc::Vector)\n\nSet the periodic boundary conditions for a system of atoms.\n\nArguments\n\nat::Atoms: The system of atoms.\npbc::Vector: A vector of length 3 specifying the periodic boundary conditions for each dimension. Each element can be either true for periodic boundary conditions or false for Dirichlet zero boundary conditions.\n\nReturns\n\nFlexibleSystem: A flexible system with the specified boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_df-Tuple{String, DataFrames.DataFrame}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_df","text":"write_df(filename::String, df::DataFrame)\n\nWrite a DataFrame to a CSV/Arrow file.\n\nArguments\n\nfilename::String: The name of the file to write to.\ndf::DataFrame: The DataFrame to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_df_every_n-Tuple{DataFrames.DataFrame, Int64, DataSavingStrategy}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_df_every_n","text":"write_df_every_n(df::DataFrame, step::Int, d_strategy::SaveEveryN)\n\nWrite the DataFrame df to a file specified by d_strategy.filename every d_strategy.n steps.\n\nArguments\n\ndf::DataFrame: The DataFrame to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the filename and the step interval.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_ls_every_n-Tuple{AbstractLiveSet, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_ls_every_n","text":"write_ls_every_n(ls::AtomWalkers, step::Int, d_strategy::SaveEveryN)\n\nWrite the liveset ls to file every n steps, as specified by the d_strategy.\n\nArguments\n\nls::AbstractLiveSet: The liveset to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the frequency of writing.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_single_walker-Tuple{String, AbstractWalker, Bool}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_single_walker","text":"write_single_walker(filename::String, at::AtomWalker, append::Bool)\n\nWrite a single AtomWalker object to a file. If the file already exists, append the walker to the file.\n\nArguments\n\nfilename::String: The name of the file to write to.\nat::AtomWalker: The AtomWalker object to write.\nappend::Bool: A boolean indicating whether to append the walker to the file if it already exists.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_single_walker-Tuple{String, AtomWalker}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_single_walker","text":"write_single_walker(filename::String, at::AtomWalker)\n\nWrite a single AtomWalker object to a file.\n\nArguments\n\nfilename::String: The name of the file to write to.\nat::AtomWalker: The AtomWalker object to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walker_every_n-Tuple{AbstractWalker, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walker_every_n","text":"write_walker_every_n(wk::AbstractWalker, step::Int, d_strategy::SaveEveryN)\n\nWrite the walker wk to a file specified by d_strategy.wk_filename every d_strategy.n steps.\n\nArguments\n\nwk::AbstractWalker: The walker to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the file name and the interval.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walkers-Union{Tuple{C}, Tuple{String, Array{AtomWalker{C}, 1}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walkers","text":"write_walkers(filename::String, ats::Vector{AtomWalker})\n\nWrite a collection of AtomWalker objects to a file.\n\nArguments\n\nfilename::String: The name of the file to write the walkers to.\nats::Vector{AtomWalker}: The collection of AtomWalker objects to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walkers-Union{Tuple{C}, Tuple{String, Array{LatticeWalker{C}, 1}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walkers","text":"write_walkers(filename::String, ats::Vector{LatticeWalker})\n\nWrite a collection of LatticeWalker objects to a file.\n\nArguments\n\nfilename::String: The name of the file to write the walkers to.\nats::Vector{LatticeWalker}: The collection of LatticeWalker objects to write.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#Sampling-Schemes","page":"SamplingSchemes","title":"Sampling Schemes","text":"","category":"section"},{"location":"SamplingSchemes/#Functions","page":"SamplingSchemes","title":"Functions","text":"","category":"section"},{"location":"SamplingSchemes/","page":"SamplingSchemes","title":"SamplingSchemes","text":"Modules = [SamplingSchemes]","category":"page"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes","text":"SamplingSchemes\n\nModule for defining the sampling schemes.\n\n\n\n\n\n","category":"module"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCMixedMoves","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCMixedMoves","text":"struct MCMixedMoves <: MCRoutine\n\nA type for generating a new walker by performing random walks and swapping atoms. Currently, it is intended to use this routine for multi-component systems. The actual number of random walks and swaps to perform is determined by the weights of the fields walks_freq and swaps_freq. For example, if walks_freq=4 and swaps_freq=1, then the probability of performing a random walk is 4/5, and the probability of performing a swap is 1/5.\n\nFields\n\nwalks_freq::Int: The frequency of random walks to perform.\nswaps_freq::Int: The frequency of atom swaps to perform.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCNewSample","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCNewSample","text":"struct MCNewSample <: MCRoutine\n\nA type for generating a new walker from a random configuration. Currently, it is intended to use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkClone","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkClone","text":"struct MCRandomWalkClone <: MCRoutine\n\nA type for generating a new walker by cloning an existing walker and performing a random walk for decorrelation.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkCloneParallel","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkCloneParallel","text":"struct MCRandomWalkCloneParallel <: MCRoutineParallel\n\nA type for generating a new walker by cloning an existing walker and performing a random walk for decorrelation in parallel.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkMaxE","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkMaxE","text":"struct MCRandomWalkMaxE <: MCRoutine\n\nA type for generating a new walker by performing a random walk for decorrelation on the highest-energy walker.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkMaxEParallel","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkMaxEParallel","text":"MCRandomWalkMaxEParallel <: MCRoutineParallel\n\nA type for generating a new walker by performing a random walk for decorrelation on the highest-energy walker(s) in parallel.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRejectionSampling","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRejectionSampling","text":"struct MCRejectionSampling <: MCRoutine\n\nA type for generating a new walker by performing rejection sampling. Currently, it is intended to use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRoutine","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRoutine","text":"abstract type MCRoutine\n\nAn abstract type representing a Monte Carlo routine.\n\nCurrently, the following concrete types are supported:\n\nMCRandomWalkMaxE: A type for generating a new walker by performing a random walk for decorrelation on the\n\nhighest-energy walker.\n\nMCRandomWalkClone: A type for generating a new walker by cloning an existing walker and performing a random walk\n\nfor decorrelation.\n\nMCNewSample: A type for generating a new walker from a random configuration. Currently, it is intended to use \n\nthis routine for lattice gas systems.\n\nMCMixedMoves: A type for generating a new walker by performing random walks and swapping atoms. Currently, it is\n\nintended to use this routine for multi-component systems. The actual number of random walks and swaps to perform is determined by the weights of the fields walks_freq and swaps_freq. See MCMixedMoves.\n\nMCRejectionSampling: A type for generating a new walker by performing rejection sampling. Currently, it is intended\n\nto use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRoutineParallel","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRoutineParallel","text":"abstract type MCRoutineParallel <: MCRoutine\n\n(Internal) An abstract type representing a parallel Monte Carlo routine.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MetropolisMCParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MetropolisMCParameters","text":"MetropolisMCParameters <: SamplingParameters\n\nParameters for the Metropolis Monte Carlo algorithm.\n\nFields\n\ntemperature::Float64: The temperature of the system.\nequilibrium_steps::Int64: The number of steps to equilibrate the system.\nsampling_steps::Int64: The number of steps to sample the system.\nstep_size::Float64: The step size for the random walk (for atomistic systems).\nstep_size_lo::Float64: The lower bound of the step size.\nstep_size_up::Float64: The upper bound of the step size.\naccept_range::Tuple{Float64, Float64}: The range of acceptance rates for adjusting the step size.\n\ne.g. (0.25, 0.75) means that the step size will decrease if the acceptance rate is below 0.25 and increase if it is above 0.75.\n\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.NestedSamplingParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.NestedSamplingParameters","text":"mutable struct NestedSamplingParameters <: SamplingParameters\n\nThe NestedSamplingParameters struct represents the parameters used in the nested sampling scheme.\n\nFields\n\nmc_steps::Int64: The number of total Monte Carlo moves to perform.\ninitial_step_size::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.\nstep_size::Float64: The on-the-fly step size used in the sampling process.\nstep_size_lo::Float64: The lower bound of the step size.\nstep_size_up::Float64: The upper bound of the step size.\naccept_range::Tuple{Float64, Float64}: The range of acceptance rates for adjusting the step size.\n\ne.g. (0.25, 0.75) means that the step size will decrease if the acceptance rate is below 0.25 and increase if it is above 0.75.\n\nfail_count::Int64: The number of failed MC moves in a row.\nallowed_fail_count::Int64: The maximum number of failed MC moves allowed before resetting the step size.\nenergy_perturbation::Float64: The perturbation value used to adjust the energy of the walkers.\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.SamplingParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.SamplingParameters","text":"struct NestedSamplingParameters\n\nThe NestedSamplingParameters struct represents the parameters for various sampling algorithm.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.WangLandauParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.WangLandauParameters","text":"WangLandauParameters\n\nA structure to hold the parameters for the Wang-Landau sampling scheme.\n\nFields\n\nnum_steps::Int64: The number of Monte Carlo steps.\nflatness_criterion::Float64: The criterion for flatness of the histogram.\nf_initial::Float64: The initial modification factor.\nf_min::Float64: The minimum modification factor.\nenergy_bins::Vector{Float64}: The pre-supplied energy bins.\nmax_iter::Int64: The maximum number of iterations in each flatness check.\nstep_size::Float64: The step size for the random walk (for atomistic systems).\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.WangLandauParameters-Tuple{}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.WangLandauParameters","text":"WangLandauParameters(; \n    num_steps::Int64=100,\n    flatness_criterion::Float64=0.8,\n    f_initial::Float64=Float64(MathConstants.e),\n    f_min::Float64=exp(1e-8),\n    energy_min::Float64=0.0,\n    energy_max::Float64=1.0,\n    num_energy_bins::Int64=100,\n    max_iter::Int64=1000,\n    step_size::Float64=0.01,\n    random_seed::Int64=1234\n)\n\nCreate a WangLandauParameters object with the specified parameters.\n\nArguments\n\nnum_steps::Int64: The number of Monte Carlo steps.\nflatness_criterion::Float64: The criterion for flatness of the histogram.\nf_initial::Float64: The initial modification factor.\nf_min::Float64: The minimum modification factor.\nenergy_min::Float64: The minimum energy.\nenergy_max::Float64: The maximum energy.\nnum_energy_bins::Int64: The number of energy bins.\nmax_iter::Int64: The maximum number of iterations in each flatness check.\nrandom_seed::Int64: The seed for the random number generator.\n\nReturns\n\nWangLandauParameters: The parameters for the Wang-Landau sampling scheme.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.LatticeNestedSamplingParameters-Tuple{}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.LatticeNestedSamplingParameters","text":"LatticeNestedSamplingParameters(;\n        mc_steps::Int64=100,\n        energy_perturbation::Float64=1e-12,\n        fail_count::Int64=0,\n        allowed_fail_count::Int64=10,\n        random_seed::Int64=1234,\n        )\n\nA convenience constructor for NestedSamplingParameters with default values suitable for lattice systems.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.adjust_step_size-Tuple{SamplingParameters, Float64}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.adjust_step_size","text":"adjust_step_size(params::SamplingParameters, rate::Float64)\n\nAdjusts the step size of the sampling algorithm based on the acceptance rate.  The step size is increased by 10% if the acceptance rate is above the upper limit of the range, and decreased by 10% if the acceptance rate is below the lower limit of the range.\n\nArguments\n\nparams::SamplingParameters: The parameters of the sampling algorithm.\nrate::Float64: The acceptance rate of the algorithm.\nrange::Tuple{Float64, Float64}: The range of acceptance rates for adjusting the step size. Default is (0.25, 0.75).\n\nReturns\n\nparams::SamplingParameters: The updated parameters with adjusted step size.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.estimate_temperature","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.estimate_temperature","text":"estimate_temperature(n_walker::Int, n_cull::Int, ediff::Float64)\n\nEstimate the temperature for the nested sampling algorithm from dlog(ω)/dE.\n\n\n\n\n\n","category":"function"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.exact_enumeration-Union{Tuple{G}, Tuple{C}, Tuple{MLattice{C, G}, ClassicalHamiltonian}} where {C, G}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.exact_enumeration","text":"exact_enumeration(lattice::SLattice{G}, cutoff_radii::Tuple{Float64, Float64}, h::ClassicalHamiltonian) where G\n\nEnumerate all possible configurations of a lattice system and compute the energy of each configuration.\n\nArguments\n\nlattice::SLattice{G}: The (starting) lattice system to enumerate. All possible configurations will be generated from this lattice system.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\n\nReturns\n\nDataFrame: A DataFrame containing the energy and configuration of each configuration.\nLatticeGasWalkers: A collection of lattice walkers for each configuration.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.monte_carlo_sampling-Tuple{AbstractLattice, ClassicalHamiltonian, MetropolisMCParameters}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.monte_carlo_sampling","text":"monte_carlo_sampling(\n    lattice::AbstractLattice,\n    h::ClassicalHamiltonian,\n    mc_params::MetropolisMCParameters;\n    kb::Float64 = 8.617333262e-5 # eV/K\n)\n\nPerform the Metropolis Monte Carlo sampling algorithm for a range of temperatures.\n\nNote: The Boltzmann constant is set to 8.617333262e-5 eV K^-1. Thus, the units of the temperature should be in Kelvin, and the units of the energy should be in eV (defined in the Hamiltonian).\n\nArguments\n\nlattice::AbstractLattice: The initial lattice configuration.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\nmc_params::MetropolisMCParameters: The parameters for the Metropolis Monte Carlo algorithm.\nkb::Float64: The Boltzmann constant in eV/K (default is 8.617333262e-5 eV/K).\n\nReturns\n\nenergies::Vector{Float64}: The energies of the system at each temperature.\nconfigs::Vector{typeof(lattice)}: The configurations of the system at each temperature.\ncvs::Vector{Float64}: The heat capacities of the system at each temperature.\nacceptance_rates::Vector{Float64}: The acceptance rates of the system at each temperature.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.monte_carlo_sampling-Tuple{AtomWalker, LennardJonesParameterSets, MetropolisMCParameters}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.monte_carlo_sampling","text":"monte_carlo_sampling(\n    at::AtomWalker,\n    lj::LennardJonesParameterSets,\n    mc_params::MetropolisMCParameters;\n    kb::Float64 = 8.617333262e-5 # eV/K\n)\n\nPerform the Metropolis Monte Carlo sampling algorithm for a range of temperatures.\n\nNote: The Boltzmann constant is set to 8.617333262e-5 eV K^-1. Thus, the units of the temperature should be in Kelvin, and the units of the energy should be in eV.\n\nArguments\n\nat::AtomWalker: The initial atom walker configuration.\nlj::LennardJonesParameterSets: The Lennard-Jones parameters.\nmc_params::MetropolisMCParameters: The parameters for the Metropolis Monte Carlo algorithm.\n\nReturns\n\nenergies::Vector{Float64}: The energies of the system at each temperature.\nconfigs::Vector{typeof(at)}: The configurations of the system at each temperature.\ncvs::Vector{Float64}: The heat capacities of the system at each temperature.\nacceptance_rates::Vector{Float64}: The acceptance rates of the system at each temperature.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling-Tuple{AbstractLiveSet, NestedSamplingParameters, Int64, MCRoutine, DataSavingStrategy}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling","text":"nested_sampling(liveset::AbstractLiveSet, ns_params::NestedSamplingParameters, n_steps::Int64, mc_routine::MCRoutine; args...)\n\nPerform a nested sampling loop for a given number of steps.\n\nArguments\n\nliveset::AbstractLiveSet: The initial set of walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nn_steps::Int64: The number of steps to perform.\nmc_routine::MCRoutine: The Monte Carlo routine to use.\n\nReturns\n\ndf: A DataFrame containing the iteration number and maximum energy for each step.\nliveset: The updated set of walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{AtomWalkers, NestedSamplingParameters, MCMixedMoves}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, mc_routine::MCMixedMoves)\n\nPerform a single step of the nested sampling algorithm using the Monte Carlo mixed moves routine.\n\nArguments\n\nliveset::AtomWalkers: The set of atom walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCMixedMoves: The Monte Carlo mixed moves routine.\n\nReturns\n\niter: The iteration number after the step.\nemax: The highest energy recorded during the step.\nliveset: The updated set of atom walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{AtomWalkers, NestedSamplingParameters, MCRoutine}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, mc_routine::MCRoutine)\n\nPerform a single step of the nested sampling algorithm using the Monte Carlo random walk routine.\n\nArguments\n\nliveset::AtomWalkers: The set of atom walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCRoutine: The Monte Carlo routine for generating new samples. See MCRoutine.\n\nReturns\n\niter: The iteration number after the step.\nemax: The highest energy recorded during the step.\nliveset: The updated set of atom walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{LatticeGasWalkers, NestedSamplingParameters, MCNewSample}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, mc_routine::MCNewSample)\n\nPerform a single step of the nested sampling algorithm.\n\nThis function takes a liveset of lattice gas walkers, ns_params containing the parameters for nested sampling, and mc_routine representing the Monte Carlo routine for generating new samples. It performs a single step of the nested sampling algorithm by updating the liveset with a new walker.\n\nArguments\n\nliveset::LatticeGasWalkers: The liveset of lattice gas walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCNewSample: The Monte Carlo routine for generating new samples.\n\nReturns\n\niter: The iteration number of the liveset after the step.\nemax: The maximum energy of the liveset after the step.\nliveset::LatticeGasWalkers: The updated liveset after the step.\nns_params::LatticeNestedSamplingParameters: The updated nested sampling parameters after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{LatticeGasWalkers, NestedSamplingParameters, MCRoutine}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, mc_routine::MCRoutine)\n\nPerform a single step of the nested sampling algorithm.\n\nThis function takes a liveset of lattice gas walkers, ns_params containing the parameters for nested sampling, and mc_routine representing the Monte Carlo  routine for generating new samples. It performs a single step of the nested sampling algorithm by updating the liveset with a new walker.\n\nArguments\n\nliveset::LatticeGasWalkers: The liveset of lattice gas walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCRoutine: The Monte Carlo routine for generating new samples.\n\nReturns\n\niter: The iteration number of the liveset after the step.\nemax: The maximum energy of the liveset after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nvt_monte_carlo-Tuple{AbstractLattice, ClassicalHamiltonian, Float64, Int64, Int64}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nvt_monte_carlo","text":"nvt_monte_carlo(\n    lattice::AbstractLattice,\n    h::ClassicalHamiltonian,\n    temperature::Float64,\n    num_steps::Int64,\n    random_seed::Int64;\n    kb::Float64 = 8.617_333_262e-5  # eV K-1\n)\n\nPerform the NVT Monte Carlo algorithm to sample the lattice configurations.\n\nNote: The Boltzmann constant is set to 8.617333262e-5 eV K^-1. Thus, the units of the temperature should be in Kelvin, and the units of the energy should be in eV (defined in the Hamiltonian).\n\nArguments\n\nlattice::AbstractLattice: The initial lattice configuration.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\ntemperature::Float64: The temperature of the system.\nnum_steps::Int64: The number of Monte Carlo steps.\nrandom_seed::Int64: The seed for the random number generator.\nkb::Float64: The Boltzmann constant (default is 8.617333262e-5 eV K-1).\n\nReturns\n\nenergies::Vector{Float64}: The energies of the system at each step.\nconfigurations::Vector{typeof(lattice)}: The configurations of the system at each step.\naccepted_steps::Int64: The number of accepted steps.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nvt_monte_carlo-Tuple{AtomWalker, AbstractPotential, Float64, Int64, Float64, Int64}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nvt_monte_carlo","text":"nvt_monte_carlo(\n    walker::AtomWalker,\n    pot::AbstractPotential,\n    temperature::Float64,\n    num_steps::Int64,\n    step_size::Float64,\n    random_seed::Int64;\n    kb::Float64 = 8.617_333_262e-5  # eV K-1\n)\n\nPerform the NVT Monte Carlo algorithm to sample the atom walker configurations. Note: The Boltzmann constant is set to 8.617333262e-5 eV K^-1. Thus, the units of the temperature should be in Kelvin, and the units of the energy should be in eV (defined in the Hamiltonian).\n\nArguments\n\nwalker::AtomWalker: The initial atom walker configuration.\npot::AbstractPotential: The potential energy function for the atoms.\ntemperature::Float64: The temperature of the system.\nnum_steps::Int64: The number of Monte Carlo steps.\nstep_size::Float64: The step size for the random walk.\nrandom_seed::Int64: The seed for the random number generator.\nkb::Float64: The Boltzmann constant (default is 8.617333262e-5 eV K-1).\n\nReturns\n\nenergies::Vector{typeof(walker.energy)}: The energies of the system at each step.\nconfigurations::Vector{typeof(walker)}: The configurations of the system at each step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.sort_by_energy!-Tuple{AbstractLiveSet}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.sort_by_energy!","text":"sort_by_energy!(liveset::LJAtomWalkers)\n\nSorts the walkers in the liveset by their energy in descending order.\n\nArguments\n\nliveset::LJAtomWalkers: The liveset of walkers to be sorted.\n\nReturns\n\nliveset::LJAtomWalkers: The sorted liveset.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.update_iter!-Tuple{AbstractLiveSet}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.update_iter!","text":"update_iter!(liveset::AtomWalkers)\n\nUpdate the iteration count for each walker in the liveset.\n\nArguments\n\nliveset::AtomWalkers: The set of walkers to update.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.wang_landau-Tuple{AbstractLattice, ClassicalHamiltonian, WangLandauParameters}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.wang_landau","text":"wang_landau(\n    lattice::AbstractLattice,\n    h::ClassicalHamiltonian,\n    wl_params::WangLandauParameters\n)\n\nwang_landau(\n    walker::AtomWalker,\n    lj::LennardJonesParameterSets,\n    wl_params::WangLandauParameters\n)\n\nPerform the Wang-Landau sampling scheme for a lattice or an atomistic system.\n\nArguments\n\nlattice::AbstractLattice/walker::AtomWalker: The initial lattice/atomistic configuration.\nh::ClassicalHamiltonian/lj::LennardJonesParameterSets: The Hamiltonian parameters for the lattice/atomistic system.\nwl_params::WangLandauParameters: The parameters for the Wang-Landau sampling scheme.\n\nReturns\n\ndf::DataFrame/energies::Vector{Float64}: The energies of the system at each step.\nconfigs::Vector{AbstractLattice}/configs::Vector{AtomWalker}: The configurations of the system at each step.\nwl_params::WangLandauParameters: The parameters for the Wang-Landau sampling scheme.\nS::Vector{Float64}: The entropy of the system.\nH::Vector{Int64}: The histogram of the system.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"EditURL = \"../../scripts/tutorials.jl\"","category":"page"},{"location":"tutorials/#FreeBird.jl-Tutorial","page":"Tutorials","title":"FreeBird.jl Tutorial","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This is a tutorial to using the FreeBird.jl package. It covers the basic functionalities of the package, such as generating atomistic and lattice walkers, defining a potential energy function or Hamiltonian, and running a sampling simulation. For more detailed information, please refer to the documentation of the package. You can find the runnable version of this script in the scripts directory of the package.","category":"page"},{"location":"tutorials/#Atomistic-walkers-and-nested-sampling","page":"Tutorials","title":"Atomistic walkers and nested sampling","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"First, let's load the FreeBird.jl package:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using FreeBird","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now, let's create a few configurations of a simple atomistic system with six particles in a 3D box.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"single_config = generate_initial_configs(1, 562.5, 6; particle_type=:H)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The function above has generated a single configuration, with 562.5 Å^3 volume per particle, and 6 particles of type H. Note that the particle_type keyword argument can be used to specify the type of particle, i.e., chemical element. By default, the type is set to :H. Use ?generate_initial_configs in the REPL to see the documentation of the function. Or see generate_initial_configs.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's inspect the generated configuration using the view_structure function:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"single_config[1] |> view_structure","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"It's of a FastSystem type from AtomsBase. The dimensions of the box are 15 Å x 15 Å x 15 Å, following the volume per particle specified. The positions of the particles are randomly generated within the box.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now, let's generate a few more configurations:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"configs = generate_initial_configs(120, 562.5, 6)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The function above has generated 120 configurations, again, with 562.5 Å^3 volume per particle, and 6 particles of type H. These configurations will be served as the initial walkers for a sampling run, but first, we need to wrap them into the AtomWalker type defined in FreeBird.jl.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"walkers = AtomWalker.(generate_initial_configs(120, 562.5, 6));\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's inquire the type of the walkers variable:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"walkers |> typeof","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The walkers variable is of a Vector{AtomWalker{1}} type, which is a vector of AtomWalker{1} objects. The AtomWalker{1} type is a parametrized type, where the parameter is the number of components in the system. In this case, the system has only one component, consisting of 6 particles of type H.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"To define how these particles interact with each other, we need to create a potential energy function. Let's use the Lennard-Jones potential:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"lj = LJParameters(epsilon=0.1, sigma=2.5, cutoff=4.0)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The LJParameters type is a struct that holds the parameters of the Lennard-Jones potential. The epsilon and sigma fields are the energy and length scales of the potential, respectively. The cutoff field is the distance at which the potential is truncated. An energy shift is applied to the potential to ensure continuity at the cutoff distance, automatically in this case. See the documentation of the LJParameters type for more information and examples.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We now can create a so-called liveset that will be used to store the walkers during the simulation. The lj potential will be used to attached and used to calculate the potential energy of the walkers.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ls = LJAtomWalkers(walkers, lj)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here, ls is a LJAtomWalkers type, and has the walkers and lj fields attached to it.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now, time to set up a simulation. We will be using nested sampling, a Bayesian-inference inspired method, as an example here. First, we need to define the nested sampling parameters:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ns_params = NestedSamplingParameters(mc_steps=200, step_size=0.1)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The NestedSamplingParameters type is a struct that holds the parameters of the nested sampling algorithm. The fields are as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mc_steps::Int64: The number of total Monte Carlo moves to perform.\ninitial_step_size::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.\nstep_size::Float64: The on-the-fly step size used in the sampling process.\nstep_size_lo::Float64: The lower bound of the step size.\nstep_size_up::Float64: The upper bound of the step size.\naccept_range::Tuple{Float64, Float64}: The range of acceptance rates for adjusting the step size.\nfail_count::Int64: The number of failed MC moves in a row.\nallowed_fail_count::Int64: The maximum number of failed MC moves allowed before resetting the step size.\nrandom_seed::Int64: The seed for the random number generator.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Speaking of the Monte Carlo moves, we need to define that too:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mc = MCRandomWalkClone()","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The MCRandomWalkClone type is a type of Monte Carlo move that indicates a new walker is created by cloning an existing walker and then decorrelate the positions of the particles.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We also need to specify how we want to save the data and the output:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"save = SaveEveryN(n_traj=10, n_snap=20_000)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The SaveEveryN type is a struct that holds the parameters of the saving routine.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now, we are ready to run the nested sampling simulation:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"energies, liveset, _ = nested_sampling(ls, ns_params, 20_000, mc, save)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The results of the simulation are stored in the energies and liveset variables. The energies variable is a DataFrame that contains the energies of the walkers at each iteration. The liveset variable is the final liveset after the simulation. Let's see how the walkers look like after the simulation:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"liveset.walkers[1].configuration |> view_structure","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"They should be in a more ordered state, in this case, a cluster, than the initial gaseous state.","category":"page"},{"location":"tutorials/#Calculating-heat-capacity-with-AnalysisTools-module","page":"Tutorials","title":"Calculating heat capacity with AnalysisTools module","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The AnalysisTools module provides functions to calculate the heat capacity of the system. First, we calculate the ω factors, which account for the fractions of phase-space volume sampled during each nested sampling iteration, defined as:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"omega_i = frac1N+1 left(fracNN+1right)^i","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"where N is the number of walkers and i is the iteration number.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ωi = ωᵢ(energies.iter, 120);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's shift the energies to be greater than or equal to zero, making the calculation of the heat capacity more stable.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Ei = energies.emax .- minimum(energies.emax);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Specify the temperatures that we are interested in, in units of Kelvin.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Ts = collect(1:0.1:1000);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Define the Boltzmann constant in units of eV/K.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"kb = 8.617333262e-5 # eV/K","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Calculate the inverse temperatures","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"β = 1 ./(kb.*Ts);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Define the degrees of freedom, which is 3×6 for the 6-particle system.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"dof = 18","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Calculate the heat capacities as a function of temperature using the cv function,","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"C_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"cvs = cv(energies, β, dof, 120);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's plot the heat capacity as a function of temperature","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Plots\nplot(Ts, cvs./kb, xlabel=\"Temperature (K)\", ylabel=\"Heat Capacity (\\$k_B\\$)\", label=\"LJ\\$_6\\$\")","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The plot should show the heat capacity as a function of temperature for the 6-particle Lennard-Jones system, with a main peak around 400 K, representing the phase transition, and some fluctuations at low temperatures, and tailing off to zero at high temperatures.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"That's it! You have successfully run a nested sampling simulation using the FreeBird.jl package.","category":"page"},{"location":"tutorials/#Lattice-walkers-and-exact-enumeration","page":"Tutorials","title":"Lattice walkers and exact enumeration","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Another feature of FreeBird.jl is the ability to work with lattice systems. The lattice systems are defined by the MLattice which is a parametrized type.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"MLattice{C,G}(\n    lattice_vectors::Matrix{Float64},\n    basis::Vector{Tuple{Float64, Float64, Float64}},\n    supercell_dimensions::Tuple{Int64, Int64, Int64},\n    periodicity::Tuple{Bool, Bool, Bool},\n    components::Vector{Vector{Bool}},\n    adsorptions::Vector{Bool},\n    cutoff_radii::Vector{Float64},\n) where {C,G}","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The C parameter is the number of components in the system, and the G parameter defines the geometry of the lattice.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now, let's create a simple square lattice system with single component:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ml = MLattice{1,SquareLattice}(components=[[1,2,3,4]])","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"When you run the code above, the outer constructor of MLattice will be called. Many of the arguments are optional and have default values. The components argument is a vector of vectors that defines the components of the system. The components=[[1,2,3,4]] argument specifies that the system has a single component, and the first four sites are occupied.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"MLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,\n    basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],\n    supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),\n    periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n    cutoff_radii::Vector{Float64}=[1.1, 1.5],\n    components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n    adsorptions::Union{Vector{Int},Symbol}=:full)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"You may notice that the code above returns a SLattice type. The SLattice type is simply an alias for the MLattice{1,G}, where G is the geometry of the lattice and the number of components is fixed to 1. You can also directly call the SLattice, it will give the same result:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"sl = SLattice{SquareLattice}(components=[[1,2,3,4]])","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now, let's define a Hamiltonian for the lattice system:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\")","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The GenericLatticeHamiltonian type is a struct that holds the parameters of the Hamiltonian. The first argument is the on-site energy, and the second argument is the list of n-th nearest-neighbors energy. The third argument is the unit of the energy.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"To run exact enumeration, we only need a initial walker/lattice configuration and the Hamiltonian. Let's run the exact enumeration:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"df, ls = exact_enumeration(sl, ham)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The results of the exact enumeration are stored in the df and ls variables. The df variable is a DataFrame that contains the list of energies, as well as the configurations. The ls variable is the final liveset that contains all possible configurations of the lattice system. Let's see how the first configuration looks like:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ls.walkers[1].configuration","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"It's the initial configuration of the lattice system. Let's see how the last configuration looks like:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ls.walkers[end].configuration","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Be warned that the exact enumeration can be computationally expensive for large systems.","category":"page"},{"location":"tutorials/#Calculating-heat-capacity","page":"Tutorials","title":"Calculating heat capacity","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Since we enumerated all possible configurations of the lattice system, we can calculate the partition function, then the heat capacity directly.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's calculate the heat capacity for the lattice system: Define the temperatures that we are interested in, in units of Kelvin.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Ts = collect(1:0.1:500);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Define the Boltzmann constant in units of eV/K.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"kb = 8.617333262e-5 # eV/K","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Convert them to inverse temperatures","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"βs = 1 ./(kb.*Ts);\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Extract the energies from the DataFrame, keeping the values only","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"es = [e.val for e in df.energy];\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Since this is not a nested sampling run, each configuration carries the same weight:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ω_1 = ones(length(df.energy));\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"And for a lattice, the degrees of freedom is 0:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"dof = 0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now we can use a scaler version of the cv function to calculate the heat capacity:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"cvs = [cv(β, ω_1, es, dof) for β in βs];\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's plot the heat capacity as a function of temperature","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Plots\nplot(Ts, cvs./kb, xlabel=\"Temperature (K)\", ylabel=\"Heat Capacity (\\$k_B\\$)\", label=\"Square Lattice\")","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"You should expect to see a single peak in the heat capacity curve around 40 K, and tailing off to zero at high temperatures.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"That's it! You have successfully run an exact enumeration simulation using the FreeBird.jl package.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"EnergyEval/#EnergyEval","page":"EnergyEval","title":"EnergyEval","text":"","category":"section"},{"location":"EnergyEval/#Functions","page":"EnergyEval","title":"Functions","text":"","category":"section"},{"location":"EnergyEval/","page":"EnergyEval","title":"EnergyEval","text":"Modules = [EnergyEval]","category":"page"},{"location":"EnergyEval/#FreeBird.EnergyEval","page":"EnergyEval","title":"FreeBird.EnergyEval","text":"EnergyEval\n\nModule for evaluating energy-related quantities for a system.\n\n\n\n\n\n","category":"module"},{"location":"EnergyEval/#FreeBird.EnergyEval.frozen_energy-Union{Tuple{P}, Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeParameterSets{C, P}, Vector{Int64}, Vector{Bool}}} where {C, P}","page":"EnergyEval","title":"FreeBird.EnergyEval.frozen_energy","text":"frozen_energy(at::AbstractSystem, cps::CompositeParameterSets{C,P}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy of the frozen particles in the system using a multi-component potential (CompositeParameterSets). I.e., the components interact with each other using different parameters. The energy is calculated by summing the pairwise interactions between the frozen particles. Since the frozen particles do not move, the energy is typically only calculated once for a given system.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\ncps::CompositeParameterSets{C,P}: The composite potential parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy of the frozen particles in the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.frozen_energy-Union{Tuple{S}, Tuple{AtomsBase.AbstractSystem, SingleComponentPotential{S}, Vector{Int64}, Vector{Bool}}} where S","page":"EnergyEval","title":"FreeBird.EnergyEval.frozen_energy","text":"frozen_energy(at::AbstractSystem, pot::SingleComponentPotential{S}, list_num_par::Vector{Int}, frozen::Vector{Bool}) where {S}\n\nCalculate the energy of the frozen particles in the system using a single-component potential. I.e., the components interact with each other using the same parameters. The energy is calculated by summing the pairwise interactions between the frozen particles. Since the frozen particles do not move, the energy is typically only calculated once for a given system.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\npot::SingleComponentPotential{S}: The single-component potential.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy of the frozen particles in the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.inter_component_energy-Tuple{AtomsBase.AbstractSystem, AtomsBase.AbstractSystem, SingleComponentPotential{Pairwise}}","page":"EnergyEval","title":"FreeBird.EnergyEval.inter_component_energy","text":"inter_component_energy(at1::AbstractSystem, at2::AbstractSystem, pot::SingleComponentPotential{Pairwise})\n\nCompute the energy between two components of a system using a specified pairwise potential.\n\nArguments\n\nat1::AbstractSystem: The first component of the system.\nat2::AbstractSystem: The second component of the system.\npot::SingleComponentPotential{Pairwise}: The potential used to compute the energy.\n\nReturns\n\nenergy: The energy between the two components.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.inter_component_energy-Union{Tuple{U}, Tuple{N}, Tuple{Vector{Bool}, Vector{Bool}, Vector{Vector{Vector{Int64}}}, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.inter_component_energy","text":"inter_component_energy(lattice1::Vector{Bool}, lattice2::Vector{Bool}, lattice_neighbors::Vector{Vector{Vector{Int64}}}, h::GenericLatticeHamiltonian{N,U})\n\nCompute the interaction energy between two lattice configurations using the Hamiltonian parameters.\n\nArguments\n\nlattice1::Vector{Bool}: The first lattice configuration.\nlattice2::Vector{Bool}: The second lattice configuration.\nlattice_neighbors::Vector{Vector{Vector{Int64}}}: The lattice neighbor list.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::U: The interaction energy between the two lattice configurations.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Tuple{AtomsBase.AbstractSystem, SingleComponentPotential{Pairwise}, Vector{Int64}, Vector{Bool}}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, pot::SingleComponentPotential{S}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy from interactions between free-free and free-frozen particles using a single-component potential. I.e., the components interact with each other using the same parameters. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\npot::SingleComponentPotential{S}: The single-component potential.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeParameterSets{C, GuptaParameters}, Vector{Int64}}} where C","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, \n                        pot::CompositeParameterSets{C,GuptaParameters},\n                        list_num_par::Vector{Int}\n                        ) where C\n\nCalculate the energy from interactions between particles using the Gupta potential for a multi-component system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{P}, Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeParameterSets{C, P}, Vector{Int64}, Vector{Bool}, AtomsBase.AbstractSystem}} where {C, P<:SingleComponentPotential{Pairwise}}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, cps::CompositeParameterSets{C,P}, list_num_par::Vector{Int}, frozen::Vector{Bool}, surface::AbstractSystem)\n\nCalculate the energy from interactions between free-free and free-frozen particles using a multi-component potential (CompositeParameterSets). The energy is calculated by summing the pairwise interactions between the free particles and the surface.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\ncps::CompositeParameterSets{C,P}: The composite potential parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\nsurface::AbstractSystem: An optional surface system to consider in the energy calculation. See LJSurfaceWalkers.  \n\nReturns\n\nenergy: The energy from interactions between particles and the surface.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{P}, Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeParameterSets{C, P}, Vector{Int64}, Vector{Bool}}} where {C, P<:SingleComponentPotential{Pairwise}}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, cps::CompositeParameterSets{C,P}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy from interactions between free-free and free-frozen particles using a multi-component potential (CompositeParameterSets). The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\ncps::CompositeParameterSets{C,P}: The composite potential parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{S}, Tuple{AtomsBase.AbstractSystem, SingleComponentPotential{S}}} where S","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, pot::SingleComponentPotential{S})\n\nCalculate the energy from interactions between particles using the a single-component potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\npot::SingleComponentPotential{S}: The single-component potential.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{U}, Tuple{N}, Tuple{G}, Tuple{C}, Tuple{MLattice{C, G}, MLatticeHamiltonian{C, N, U}}} where {C, G, N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::MLattice{C,G}, h::MLatticeHamiltonian{C,N,U})\n\nCompute the interaction energy of a multi-component lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::MLattice{C,G}: The multi-component lattice configuration.\nh::MLatticeHamiltonian{C,N,U}: The multi-component lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{U}, Tuple{N}, Tuple{SLattice, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::SLattice, h::GenericLatticeHamiltonian{N})\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::SLattice: The lattice configuration.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.intra_component_energy-Tuple{AtomsBase.AbstractSystem, GuptaParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.intra_component_energy","text":"intra_component_energy(at::AbstractSystem, pot::GuptaParameters)\n\nCalculate the energy from interactions between particles using the Gupta potential for a single component.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.intra_component_energy-Tuple{AtomsBase.AbstractSystem, SingleComponentPotential{Pairwise}}","page":"EnergyEval","title":"FreeBird.EnergyEval.intra_component_energy","text":"intra_component_energy(at::AbstractSystem, pot::SingleComponentPotential{Pairwise})\n\nCompute the energy within a component of a system using a specified pairwise potential.\n\nArguments\n\nat::AbstractSystem: The component of the system.\npot::SingleComponentPotential{Pairwise}: The potential used to compute the energy.\n\nReturns\n\nenergy: The energy within the component.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.lattice_interaction_energy-Union{Tuple{U}, Tuple{N}, Tuple{Vector{Bool}, Vector{Vector{Vector{Int64}}}, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.lattice_interaction_energy","text":"lattice_interaction_energy(lattice_occupations::Vector{Bool}, lattice_neighbors::Vector{Vector{Vector{Int64}}}, h::GenericLatticeHamiltonian{N,U})\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice_occupations::Vector{Bool}: The lattice occupation configuration.\nlattice_neighbors::Vector{Vector{Vector{Int64}}}: The lattice neighbor list.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::U: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.pbc_dist-Union{Tuple{T}, Tuple{Union{Vector{T}, StaticArraysCore.SVector{T}}, Union{Vector{T}, StaticArraysCore.SVector{T}}, AtomsBase.AbstractSystem}} where T","page":"EnergyEval","title":"FreeBird.EnergyEval.pbc_dist","text":"pbc_dist(pos1, pos2, at)\n\nCompute the distance between two positions considering periodic boundary conditions. Currently only works for orthorhombic lattices.\n\nArguments\n\npos1::Union{SVector{T},Vector{T}}: The first position.\npos2::Union{SVector{T},Vector{T}}: The second position.\nat::AbstractSystem: The abstract system containing boundary conditions and bounding box.\n\nReturns\n\nd::Float64: The distance between pos1 and pos2 considering periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.single_site_energy-Tuple{Int64, AtomsBase.AbstractSystem, SingleComponentPotential{Pairwise}, Vector{Int64}}","page":"EnergyEval","title":"FreeBird.EnergyEval.single_site_energy","text":"single_site_energy(index::Int, at::AbstractSystem, pot::SingleComponentPotential{Pairwise})\nsingle_site_energy(index::Int, at::AbstractSystem, cps::CompositeParameterSets{C,P}, list_num_par::Vector{Int})\nsingle_site_energy(index::Int, at::AbstractSystem, cps::CompositeParameterSets{C,P}, list_num_par::Vector{Int}, surface::AbstractSystem)\n\nCalculate the energy of a single site in the system using a pairwise potential. The energy is calculated by summing the pairwise interactions between the site and all other sites in the system.\n\nArguments\n\nindex::Int: The index of the site for which the energy is calculated.\nat::AbstractSystem: The system for which the energy is calculated.\npot::SingleComponentPotential{Pairwise}: The single-component pairwise potential.\ncps::CompositeParameterSets{C,P}: The composite potential parameters. The unpacked type P must be Pairwise.\nlist_num_par::Vector{Int}: The number of particles in each component.\nsurface::AbstractSystem: An optional surface system to consider in the energy calculation. See LJSurfaceWalkers.\n\nReturns\n\nenergy: The energy of the site.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#AbstractLiveSets","page":"AbstractLiveSets","title":"AbstractLiveSets","text":"","category":"section"},{"location":"AbstractLiveSets/#Functions","page":"AbstractLiveSets","title":"Functions","text":"","category":"section"},{"location":"AbstractLiveSets/","page":"AbstractLiveSets","title":"AbstractLiveSets","text":"Modules = [AbstractLiveSets]","category":"page"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets","text":"AbstractLiveSets\n\nModule for defining the livesets, which are collections of  walkers that are used in the sampling schemes.\n\n\n\n\n\n","category":"module"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.GuptaAtomWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.GuptaAtomWalkers","text":"struct GuptaAtomWalkers <: AtomWalkers\n\nThe GuptaAtomWalkers struct represents a collection of atom walkers that interact with each other using the Gupta potential.\n\nFields\n\nwalkers::Vector{AtomWalker{C}}: A vector of atom walkers, where C is the number of components.\npotential::Union{GuptaParameters, CompositeParameterSets{C, GuptaParameters}}: The Gupta potential parameters. See GuptaParameters for more details.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LJAtomWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LJAtomWalkers","text":"struct LJAtomWalkers <: AtomWalkers\n\nThe LJAtomWalkers struct represents a collection of atom walkers that interact with each other using the Lennard-Jones potential.\n\nFields\n\nwalkers::Vector{AtomWalker{C}}: A vector of atom walkers, where C is the number of components.\npotential::AbstractPotential: The Lennard-Jones potential parameters. See AbstractPotential.\n\nConstructor\n\nLJAtomWalkers(walkers::Vector{AtomWalker{C}}, pot::AbstractPotential; assign_energy=true):    Constructs a new LJAtomWalkers object with the given walkers and Lennard-Jones potential parameters. If assign_energy=true,   the energy of each walker is assigned using the Lennard-Jones potential.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LJSurfaceWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LJSurfaceWalkers","text":"struct LJSurfaceWalkers <: AtomWalkers\n\nThe LJSurfaceWalkers struct represents a collection of atom walkers interacting through a Lennard-Jones potential,  with the presence of an external surface object wrapped in an AtomWalker.\n\nFields\n\nwalkers::Vector{AtomWalker{C}}: A vector of atom walkers, where C is the number of components.\npot::Union{LJParameters, CompositeParameterSets{CP, LJParameters}}: The Lennard-Jones potential parameters.\nsurface::AtomWalker{CS}: An atom walker representing the surface, where CS is the number of components of the surface.\n\nConstructor\n\nLJSurfaceWalkers(walkers::Vector{AtomWalker{C}},                    pot::Union{LJParameters, CompositeParameterSets{CP, LJParameters}},                    surface::AtomWalker{CS}; assign_energy=true)\nConstructs a new LJSurfaceWalkers object with the given walkers, Lennard-Jones potential parameters, and a single surface walker.    If assign_energy=true, the energy of each walker is assigned using the Lennard-Jones potential and the surface.\n`LJSurfaceWalkers(walkers::Vector{AtomWalker{C}},                            pot::Union{LJParameters, CompositeParameterSets{CP, LJParameters}},                           surface::AtomWalker{CS},                            assignenergyparallel::Symbol,                           ) where {C, CP, CS}\nConstructs a new LJSurfaceWalkers object with the given walkers, Lennard-Jones potential parameters, and a single surface walker.   The assign_energy_parallel argument determines whether to assign energy in parallel using threads (:threads) or distributed    processes (:distributed).\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LJSurfaceWalkers-Union{Tuple{CS}, Tuple{CP}, Tuple{C}, Tuple{Array{AtomWalker{C}, 1}, Union{LJParameters, CompositeParameterSets{CP, LJParameters}}, AtomWalker{CS}, Symbol}} where {C, CP, CS}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LJSurfaceWalkers","text":"LJSurfaceWalkers(walkers::Vector{AtomWalker{C}}, \n                        pot::Union{LJParameters, CompositeParameterSets{CP, LJParameters}},\n                        surface::AtomWalker{CS}, \n                        assign_energy_parallel::Symbol,\n                        ) where {C, CP, CS}\n\nConstructs a new LJSurfaceWalkers object with the given walkers, Lennard-Jones potential parameters, and a single surface walker. The assign_energy_parallel argument determines whether to assign energy in parallel using threads (:threads) or distributed  processes (:distributed).\n\nArguments\n\nwalkers::Vector{AtomWalker{C}}: A vector of atom walkers, where C is the number of components.\npot::Union{LJParameters, CompositeParameterSets{CP, LJParameters}}: The Lennard-Jones potential parameters.\nsurface::AtomWalker{CS}: An atom walker representing the surface, where CS is the number of components of the surface.\nassign_energy_parallel::Symbol: The method to use for parallel energy assignment. Can be :threads or :distributed.\n\nReturns\n\nLJSurfaceWalkers: A new LJSurfaceWalkers object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LatticeGasWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LatticeGasWalkers","text":"struct LatticeGasWalkers <: LatticeWalkers\n\nThe LatticeGasWalkers struct represents a collection of lattice walkers for a lattice gas system. It is a subtype of LatticeWalkers.\n\nFields\n\nwalkers::Vector{LatticeWalker{C}}: A vector of lattice walkers.\nhamiltonian::LatticeGasHamiltonian: The lattice gas Hamiltonian associated with the walkers.\n\nConstructors\n\nLatticeGasWalkers(walkers::Vector{LatticeWalker{C}}, hamiltonian::LatticeGasHamiltonian; assign_energy=true, perturb_energy::Float64=0.0): Constructs a new LatticeGasWalkers object with the given walkers and Hamiltonian. If assign_energy is true, the energy of each walker is assigned using the provided Hamiltonian. The optional perturb_energy parameter can be used to add a small perturbation to the assigned energy.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Tuple{AtomWalker, AbstractPotential, AtomWalker}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::AtomWalker, pot::AbstractPotential, surface::AtomWalker)\n\nAssigns the energy to the given walker using the an AbstractPotential pot with an external surface.\n\nArguments\n\nwalker::AtomWalker: The walker object to assign the energy to.\npot::AbstractPotential: The potential parameters.\nsurface::AtomWalker: The surface walker object to consider in the energy calculation.\n\nReturns\n\nwalker::AtomWalker: The walker object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Tuple{AtomWalker, AbstractPotential}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::AtomWalker, pot::AbstractPotential)\n\nAssigns the energy to the given walker using the an AbstractPotential pot.\n\nArguments\n\nwalker::AtomWalker: The walker object to assign the energy to.\npot::AbstractPotential: The potential parameters.\n\nReturns\n\nwalker::AtomWalker: The walker object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Union{Tuple{C}, Tuple{Array{AtomWalker{C}, 1}, AbstractPotential}} where C","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::Vector{AtomWalker{C}}, pot::AbstractPotential) where C\n\nAssigns the energy to each walker in walker using an AbstractPotential pot.\n\nArguments\n\nwalker::Vector{AtomWalker{C}}: A vector of walker objects to assign the energy to, where C is the number of components.\npot::AbstractPotential: The abstract potential to use for energy assignment.\n\nReturns\n\nwalker::Vector{AtomWalker{C}}: The vector of walker objects with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Union{Tuple{C}, Tuple{Array{AtomWalker{C}, 1}, Union{LJParameters, CompositeParameterSets{C, LJParameters}}}} where C","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walkers::Vector{AtomWalker{C}}, pot::Union{LJParameters, CompositeParameterSets{C, LJParameters}}; assign_energy=true, const_frozen_part=true) where C\n\nAssigns the energy to each walker in walkers using the a single-component or multi-component Lennard-Jones potential pot. If const_frozen_part=true, the frozen part of the energy is calculated only once for the first walker and assigned to all walkers. If assign_energy=true, the energy is assigned to each walker.\n\nArguments\n\nwalkers::Vector{AtomWalker{C}}: A vector of walker objects to assign the energy to, where C is the number of components.\npot::Union{LJParameters, CompositeParameterSets{C, LJParameters}}: The potential parameters.\nassign_energy::Bool=true: Whether to assign the energy to each walker.\nconst_frozen_part::Bool=true: Whether to calculate the frozen part of the energy only once for the first walker and assign it to all walkers.\n\nReturns\n\nwalkers::Vector{AtomWalker{C}}: The vector of walker objects with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian}} where C","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::LatticeWalker{C}, hamiltonian::LatticeGasHamiltonian; perturb_energy::Float64=0.0)\n\nAssigns energy to the given walker based on the hamiltonian. If perturb_energy is non-zero, a small random perturbation is added to the energy.\n\nArguments\n\nwalker::LatticeWalker{C}: The walker to assign energy to.\nhamiltonian::LatticeGasHamiltonian: The Hamiltonian used to calculate the energy.\nperturb_energy::Float64=0.0: The amount of random perturbation to add to the energy.\n\nReturns\n\nwalker::LatticeWalker{C}: The walker with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_frozen_energy!-Tuple{AtomWalker, AbstractPotential}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_frozen_energy!","text":"assign_frozen_energy!(walker::AtomWalker, pot::AbstractPotential)\n\nAssigns the frozen energy to the given walker using the an AbstractPotential pot.\n\nArguments\n\nwalker::AtomWalker: The walker object to assign the energy to.\npot::AbstractPotential: The potential parameters.\n\nReturns\n\nwalker::AtomWalker: The walker object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#AbstractPotentials","page":"AbstractPotentials","title":"AbstractPotentials","text":"","category":"section"},{"location":"AbstractPotentials/#Functions","page":"AbstractPotentials","title":"Functions","text":"","category":"section"},{"location":"AbstractPotentials/","page":"AbstractPotentials","title":"AbstractPotentials","text":"Modules = [AbstractPotentials]","category":"page"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials","text":"AbstractPotentials\n\nModule for defining and implementing potentials.\n\nCurrently implemented potentials:\n\nLennard-Jones potential\nGupta (SMA-TB) potential\n\n\n\n\n\n","category":"module"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.AbstractPotential","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.AbstractPotential","text":"AbstractPotential\n\nAn abstract type for potentials. All potentials should be subtypes of AbstractPotential.\n\nCurrently, there are two main categories of potentials:  \n\n1. `SingleComponentPotential{T}`: Potentials that use the same parameters for all components. \n   Here, `T` is the type of the single component parameter sets, e.g., `LJParameters` or `GuptaParameters`.  \n\n2. `MultiComponentPotential`: Potentials that use different parameters for different components, e.g., `CompositeParameterSets{C,P}`.\n   This type is not parameterized by `C` or `P` to allow for more flexibility in defining multi-component potentials, i.e.,\n   using different interaction models for different pairs of components.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.CompositeParameterSets","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.CompositeParameterSets","text":"struct CompositeParameterSets{C,P} <: MultiComponentParameterSets\n\nCompositeParameterSets is a struct that represents a set of composite parameter sets, typically used for multi-component systems.\n\nFields\n\nparam_sets::Matrix{P}: A matrix of parameter sets representing the composite parameter sets.\n\nType Parameters\n\nC::Int: The number of composite parameter sets.\nP <: SingleComponentParameterSets: The type of the single component parameter sets.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.CompositeParameterSets-Union{Tuple{P}, Tuple{Int64, Vector{P}}} where P<:SingleComponentPotential","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.CompositeParameterSets","text":"CompositeParameterSets(c::Int, ps::Vector{P}) where {P <: SingleComponentParameterSets}\n\nConstruct a CompositeParameterSets object from a vector of SingleComponentParameterSets.\n\nArguments\n\nc::Int: The number of components.\nps::Vector{P}: A vector of SingleComponentParameterSets objects.\n\nThe number of elements in the vector must be equal to c^2 or c*(c+1)/2.  The former case is for a full flattened matrix of SingleComponentParameterSets, useful when the interactions are asymmetric, i.e., epsilon_ij != epsilon_ji. The latter case is for symmetric interactions, i.e., epsilon_ij = epsilon_ji, hence only the upper triangular part of the matrix is needed.\n\nReturns\n\nA CompositeParameterSets object.\n\nExample\n\njulia> ps = [LJParameters(epsilon=e) for e in [11, 12, 13, 22, 23, 33]]\n6-element Vector{LJParameters}:\n LJParameters(11.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(12.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(13.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(22.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(23.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(33.0 eV, 1.0 Å, Inf, 0.0 eV)\n\njulia> ljp = CompositeParameterSets(3,ps)\n┌ Info: Creating CompositeParameterSets from the upper triangular part of the matrix.\n│         By specifying length(ps) sets of parameters, a 3 x 3 matrix is constructed.\n└         If this was not your intention, please check the documentation or raise an issue.\nCompositeParameterSets{3,LJParameters}(param_sets::3x3 Matrix):\n    param_sets[1, 1] : LJParameters(11.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[1, 2] : LJParameters(12.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[1, 3] : LJParameters(13.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[2, 1] : LJParameters(12.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[2, 2] : LJParameters(22.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[2, 3] : LJParameters(23.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[3, 1] : LJParameters(13.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[3, 2] : LJParameters(23.0 eV, 1.0 Å, Inf, 0.0 eV)\n    param_sets[3, 3] : LJParameters(33.0 eV, 1.0 Å, Inf, 0.0 eV)\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.GuptaParameters","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.GuptaParameters","text":"struct GuptaParameters\n\nThe GuptaParameters struct represents the parameters for the Gupta potential (a many-body potential, also known as the second-moment approximation tight-binding potential or SMA-TB).\n\nFormula\n\nThe Gupta potential is given by:\n\nE_i = sum_j A expleft(-p left(fracr_ijr_0 - 1right)right) - sqrtsum_j xi^2 expleft(-2q left(fracr_ijr_0 - 1right)right)\n\nwhere:\n\nE_i is the combined attraction and repulsion energy for atom i.\nr_ij is the distance between atoms i and j.\nA is the repulsive energy scale.\nxi is the attractive energy scale.\np is the exponent for the repulsive term.\nq is the exponent for the attractive term.\nr_0 is the nearest-neighbor distance in the bulk material.\nThe potential is typically truncated at a cutoff distance, defined as a multiple of r_0.\n\nSee Cleri and Rosato 1993 Phys. Rev. B 48, 22 for more details.\n\nFields\n\nA::typeof(1.0u\"eV\"): The repulsive energy scale of the potential.\nξ::typeof(1.0u\"eV\"): The attractive energy scale of the potential.\np::Float64: The exponent for the repulsive term.\nq::Float64: The exponent for the attractive term.\nr0::typeof(1.0u\"Å\"): The equilibrium distance for the potential.\ncutoff::Float64: The cutoff distance for the potential, in units of r0.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.GuptaParameters-Tuple{}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.GuptaParameters","text":"GuptaParameters(;A=1.0, ξ=1.0, p=10.0, q=5.0, r0=1.0, cutoff=Inf)\n\nA constructor for the GuptaParameters struct with default values for the Gupta potential with no cutoff.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.LJParameters","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.LJParameters","text":"struct LJParameters\n\nThe LJParameters struct represents the parameters for the Lennard-Jones potential.\n\nFields\n\nepsilon::typeof(1.0u\"eV\"): The energy scale of the potential.\nsigma::typeof(1.0u\"Å\"): The length scale of the potential.\ncutoff::Float64: The cutoff distance for the potential, in units of sigma.\nshift::typeof(0.0u\"eV\"): The energy shift applied to the potential, calculated at the cutoff distance.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.LJParameters-Tuple{}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.LJParameters","text":"LJParameters(;epsilon=1.0, sigma=1.0, cutoff=Inf, shift=true)\n\nA constructor for the LJParameters struct with default values for the  Lennard-Jones potential with no cutoff or shift. The shift parameter can be  specified as a boolean, if true, the shift energy is calculated automatically  at the cutoff distance; or as a typeof(0.0u\"eV\"), in which case the value is used directly.\n\nExample\n\njulia> lj = LJParameters(epsilon=0.1,sigma=2.5,cutoff=3.5,shift=false)\nLJParameters(0.1 eV, 2.5 Å, 3.5, 0.0 eV)\n\njulia> lj = LJParameters(sigma=2.5)\nLJParameters(1.0 eV, 2.5 Å, Inf, 0.0 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=5.0)\nLJParameters(1.0 eV, 1.0 Å, 3.5, 5.0 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=true)\nLJParameters(1.0 eV, 1.0 Å, 3.5, -0.0021747803916549904 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=false)\nLJParameters(1.0 eV, 1.0 Å, 3.5, 0.0 eV)\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.ManyBody","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.ManyBody","text":"ManyBody\n\nA subtype of PotentialStyle representing many-body interaction models.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.MultiComponentPotential","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.MultiComponentPotential","text":"MultiComponentPotential\n\nAn abstract type for multi-component potentials, where different components can interact using different parameters.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.Pairwise","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.Pairwise","text":"Pairwise\n\nA subtype of PotentialStyle representing pairwise interaction models.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.PotentialStyle","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.PotentialStyle","text":"PotentialStyle\n\nAn abstract type for potential styles, used to parameterize potentials and dispatch methods for energy evaluation based on the interaction model.\n\nSubtypes\n\nPairwise: Potentials that depend only on pairwise interactions between particles, e.g., Lennard-Jones potential.\nManyBody: Potentials that depend on many-body interactions, e.g., Gupta potential.\n\nExamples\n\nPairwise: LJParameters <: LennardJonesParameterSets{Pairwise}.\nManyBody: GuptaParameters <: GuptaParameters{ManyBody}.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.SingleComponentPotential","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.SingleComponentPotential","text":"SingleComponentPotential{T}\n\nAn abstract type for single-component potentials, where all components interact using the same parameters. Here, T is the type of the single component parameter sets, e.g., LJParameters or GuptaParameters.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.gupta_attraction_squared-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, GuptaParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.gupta_attraction_squared","text":"gupta_attraction_squared(r::typeof(1.0u\"Å\"), gp::GuptaParameters)\n\nCalculate the squared attractive energy term of the Gupta potential for a given interatomic distance r and a set of GuptaParameters. It is used to define the many-body interaction in the Gupta potential. See many_body_energy for more details. The square root is taken when calculating the total energy. See total_energy.\n\nArguments\n\nr::typeof(1.0u\"Å\"): The interatomic distance.\ngp::GuptaParameters: The parameters of the Gupta potential.\n\nReturns\n\nThe squared attractive energy term of the Gupta potential.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.gupta_repulsion-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, GuptaParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.gupta_repulsion","text":"gupta_repulsion(r::typeof(1.0u\"Å\"), gp::GuptaParameters)\n\nCalculate the repulsive energy term of the Gupta potential for a given interatomic distance r and a set of GuptaParameters. It is used to define the two-body interaction in the Gupta potential. See two_body_energy for more details.\n\nArguments\n\nr::typeof(1.0u\"Å\"): The interatomic distance.\ngp::GuptaParameters: The parameters of the Gupta potential.\n\nReturns\n\nThe repulsive energy term of the Gupta potential.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.lj_energy-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, LJParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.lj_energy","text":"lj_energy(r::typeof(1.0u\"Å\"), lj::LJParameters)\n\nCompute the Lennard-Jones energy between two particles at a given distance.\n\nArguments\n\nr::typeof(1.0u\"Å\"): The distance between the particles.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\n0.0u\"eV\" if the distance is greater than the cutoff distance.\nThe Lennard-Jones energy minus the shift otherwise.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.lj_energy-Tuple{Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}, Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.lj_energy","text":"lj_energy(epsilon::typeof(1.0u\"eV\"), sigma::typeof(1.0u\"Å\"), r::typeof(1.0u\"Å\"))\n\nCompute the Lennard-Jones potential energy between two particles.\n\nThe Lennard-Jones potential energy is given by the equation:\n\nV(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right\n\nwhere epsilon is the energy scale, sigma is the distance scale, and r is the distance between the particles.\n\nArguments\n\nepsilon::typeof(1.0u\"eV\"): The energy scale of the potential.\nsigma::typeof(1.0u\"Å\"): The distance scale of the potential.\nr::typeof(1.0u\"Å\"): The distance between the particles.\n\nReturns\n\nThe Lennard-Jones potential energy between the particles.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.many_body_energy-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, GuptaParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.many_body_energy","text":"many_body_energy(r::typeof(1.0u\"Å\"), gp::GuptaParameters)\n\nCalculate the squared many-body attractive energy contribution from a single atom at a distance r using the Gupta potential defined by the parameters in gp. See gupta_attraction_squared for more details.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.pair_energy-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, LJParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.pair_energy","text":"pair_energy(r::typeof(1.0u\"Å\"), lj::LJParameters)\n\nCompute the energy of a pair of particles separated by distance r using the Lennard-Jones potential.\n\nArguments\n\nr::typeof(1.0u\"Å\"): The distance between the two particles.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy::typeof(0.0u\"eV\"): The energy of the pair of particles.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.total_energy-Union{Tuple{C}, Tuple{Vector{<:Real}, Vector{<:Real}, Union{GuptaParameters, CompositeParameterSets{C, GuptaParameters}}}} where C","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.total_energy","text":"total_energy(energies_two_body::Vector{<:Real}, \n                energies_many_body::Vector{<:Real}, \n                pot::Union{GuptaParameters,CompositeParameterSets{C, GuptaParameters}}) where C\n\nCalculate the total energy of a system using the Gupta potential. The total energy is computed by summing the two-body repulsive energies and subtracting the square root of the many-body attractive energies. See two_body_energy and many_body_energy for more details.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.two_body_energy-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, GuptaParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.two_body_energy","text":"two_body_energy(r::typeof(1.0u\"Å\"), gp::GuptaParameters)\n\nCalculate the two-body repulsive energy between two atoms separated by a distance r using the Gupta potential defined by the parameters in gp. See gupta_repulsion for more details.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#MonteCarloMoves","page":"MonteCarloMoves","title":"MonteCarloMoves","text":"","category":"section"},{"location":"MonteCarloMoves/#Functions","page":"MonteCarloMoves","title":"Functions","text":"","category":"section"},{"location":"MonteCarloMoves/","page":"MonteCarloMoves","title":"MonteCarloMoves","text":"Modules = [MonteCarloMoves]","category":"page"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves","text":"MonteCarloMoves\n\nModule containing functions for performing Monte Carlo moves on atomistic/lattice systems.\n\n\n\n\n\n","category":"module"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_new_sample!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_new_sample!","text":"MC_new_sample!(lattice::LatticeWalker, h::ClassicalHamiltonian, emax::Float64; energy_perturb::Float64=0.0)\n\nGenerate a new sample for the lattice system.\n\nArguments\n\nlattice::LatticeWalker: The walker to generate a new sample for.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_swap!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParameterSets, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_swap!","text":"MC_random_swap!(n_steps::Int, at::AtomWalker{C}, lj::LennardJonesParameterSets, emax::typeof(0.0u\"eV\"))\n\nPerform a Monte Carlo random swap of two atoms in the AtomWalker. Only works when there are two or more non-frozen components.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The AtomWalker object.\nlj::LennardJonesParameterSets: The Lennard-Jones parameters.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker{C}: The updated AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Tuple{Int64, LatticeWalker{1}, ClassicalHamiltonian, Float64}","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, lattice::LatticeWalker, h::ClassicalHamiltonian, emax::Float64; energy_perturb::Float64=0.0)\n\nPerform a Monte Carlo random walk on the lattice system.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nlattice::LatticeWalker: The walker to perform the random walk on.\nh::ClassicalHamiltonian: The lattice gas Hamiltonian.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Union{Tuple{CS}, Tuple{C}, Tuple{Int64, AtomWalker{C}, AbstractPotential, Float64, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}, AtomWalker{CS}}} where {C, CS}","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, at::AtomWalker{C}, pot::AbstractPotential, step_size::Float64, emax::typeof(0.0u\"eV\"), surface::AtomWalker{CS})\n\nPerform a Monte Carlo random walk on the atomic/molecular system with an external surface.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\npot::AbstractPotential: The potential energy function for the system.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\nsurface::AtomWalker{CS}: The surface walker object to consider in the energy calculation. Typically frozen. \n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, AbstractPotential, Float64, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, at::AtomWalker, pot::AbstractPotential, step_size::Float64, emax::typeof(0.0u\"eV\"))\n\nPerform a Monte Carlo random walk on the atomic/molecular system.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\npot::AbstractPotential: The potential energy function for the system.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParameterSets, Float64, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, at::AtomWalker, pot::LennardJonesParameterSets, step_size::Float64, emax::typeof(0.0u\"eV\"))\n\nPerform a Monte Carlo random walk on the atomic/molecular system. Specialized for Lennard-Jones potentials.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\npot::LennardJonesParameterSets: The potential energy function for the system.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk_2D!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, AbstractPotential, Float64, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk_2D!","text":"MC_random_walk_2D!(n_steps::Int, at::AtomWalker, pot::AbstractPotential, step_size::Float64, emax::typeof(0.0u\"eV\"); dims::Vector{Int}=[1,2])\n\nPerform a Monte Carlo random walk on the atomic/molecular system in 2D.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\npot::AbstractPotential: The potential energy function for the system.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\ndims::Vector{Int}=[1,2]: The dimensions in which the random walk is performed.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_rejection_sampling!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_rejection_sampling!","text":"MC_rejection_sampling!(lattice::LatticeWalker, h::ClassicalHamiltonian, emax::Float64; energy_perturb::Float64=0.0, max_iter=10_000)\n\nPerform a Monte Carlo rejection sampling on the lattice system.\n\nArguments\n\nlattice::LatticeWalker: The walker to perform the rejection sampling on.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\nmax_iter::Int=10_000: The maximum number of iterations to perform.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.free_component_index-Union{Tuple{AtomWalker{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.free_component_index","text":"free_component_index(at::AtomWalker{C}) where C\n\nGet the indices of the free particles in each component of the AtomWalker.\n\nReturns\n\nind_free_parts::Array{Vector{Int}}: An array of vectors containing the indices of the free particles in each component.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.free_par_index-Union{Tuple{AtomWalker{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.free_par_index","text":"free_par_index(at::AtomWalker{C}) where C\n\nGet the indices of the free particles in the AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!-Tuple{SLattice}","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!","text":"generate_random_new_lattice_sample!(lattice::SLattice)\n\nGenerate a new random sample for the single-component lattice system.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!","text":"generate_random_new_lattice_sample!(lattice::MLattice{C}) where C\n\nGenerate a new random sample for the multi-component lattice system.\n\nArguments\n\nlattice::MLattice{C}: The lattice system to generate a new sample for.\n\nReturns\n\nlattice::MLattice{C}: The updated lattice system.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.mean_sq_displacement-Union{Tuple{C}, Tuple{AtomWalker{C}, AtomWalker{C}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.mean_sq_displacement","text":"mean_sq_displacement(at::AtomWalker, at_orig::AtomWalker)\n\nCalculate the mean squared displacement before and after random walk(s). Note that due to the current implementation of the periodic boundary wrap, this function is not appropriate to use for calculating mean displacements in a propagation.\n\nArguments\n\nat::AtomWalker{C}: The current AtomWalker after the random walk.\nat_orig::AtomWalker{C}: The original AtomWalker before the random walk.\n\nReturns\n\ndistsq::typeof(0.0u\"Å\"^2): The mean squared displacement of all free particles.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.periodic_boundary_wrap!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, AtomsBase.AbstractSystem}} where T","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.periodic_boundary_wrap!","text":"periodic_boundary_wrap!(pos::SVector{3,T}, system::AbstractSystem) where T\n\nWrap the position vector pos according to the periodic boundary conditions of the system. If the boundary condition is Periodic(), the position is wrapped using the modulo operator. If the boundary condition is DirichletZero(), the position is wrapped by reflecting the position vector across the boundary.\n\nArguments\n\npos::SVector{3,T}: The position vector to be wrapped.\nsystem::AbstractSystem: The system containing the periodic boundary conditions.\n\nReturns\n\nThe wrapped position vector.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.single_atom_random_walk!-Union{Tuple{C}, Tuple{AtomWalker{C}, AbstractPotential, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.single_atom_random_walk!","text":"single_atom_random_walk!(at::AtomWalker, pot::AbstractPotential, step_size::Float64)\n\nPerform a single atom random walk on the AtomWalker object at using the potential pot and a specified step_size.\n\nArguments\n\nat::AtomWalker{C}: The walker to perform the random walk on.\npot::AbstractPotential: The potential energy function for the system.\nstep_size::Float64: The maximum distance an atom can move in any direction.\n\nReturns\n\nat::AtomWalker: The updated walker after the random walk.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.single_atom_random_walk!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Float64}} where T","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.single_atom_random_walk!","text":"single_atom_random_walk!(pos::SVector{3,T}, step_size::Float64) where T\n\nPerform a single atom random walk by updating the position pos in each direction by a random amount. The step_size determines the maximum distance the atom can move in any direction.\n\nArguments\n\npos::SVector{3,T}: The current position of the atom as a 3D vector.\nstep_size::Float64: The maximum distance the atom can move in any direction.\n\nReturns\n\npos: The updated position of the atom.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.two_atoms_swap!-Union{Tuple{C}, Tuple{AtomWalker{C}, Any, Any}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.two_atoms_swap!","text":"two_atoms_swap!(at::AtomWalker{C}, ind1, ind2) where C\n\nSwap the positions of two atoms in the AtomWalker.\n\nArguments\n\nat::AtomWalker{C}: The AtomWalker object.\nind1::Int: The index of the first atom.\nind2::Int: The index of the second atom.\n\nReturns\n\nat::AtomWalker{C}: The updated AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#Analysis-Tools","page":"AnalysisTools","title":"Analysis Tools","text":"","category":"section"},{"location":"AnalysisTools/#Functions","page":"AnalysisTools","title":"Functions","text":"","category":"section"},{"location":"AnalysisTools/","page":"AnalysisTools","title":"AnalysisTools","text":"Modules = [AnalysisTools]","category":"page"},{"location":"AnalysisTools/#FreeBird.AnalysisTools","page":"AnalysisTools","title":"FreeBird.AnalysisTools","text":"AnalysisTools\n\nModule for analyzing the output of the sampling.\n\n\n\n\n\n","category":"module"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{DataFrames.DataFrame, Vector{Float64}, Int64, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(df::DataFrame, βs::Vector{Float64}, dof::Int, n_walkers::Int)\n\n(Nested Sampling) Calculates the constant-volume heat capacity at constant volume for the given DataFrame, inverse temperatures, degrees of freedom, and number of walkers. The heat capacity is defined as:\n\nC_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)\n\nwhere mathrmdof is the degrees of freedom, k_B is the Boltzmann constant (in units of eV/K), beta is the inverse temperature, omega_i is the i-th omega factor, E_i is the i-th energy, Z(beta) is the partition function, and U(beta) is the internal energy.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the output data.\nβs::Vector{Float64}: Inverse temperatures.\ndof::Int: The degrees of freedom, equal to the number of dimensions times the number of particles. For a lattice, it is zero.\nn_walkers::Int: The number of walkers.\nn_cull::Int: The number of culled walkers. Default is 1.\nω0::Float64: The initial omega factor. Default is 1.0.\n\nReturns\n\nA vector of constant-volume heat capacities.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{Float64, Vector{Float64}, Vector{Float64}, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(β::Float64, omega_i::Vector{Float64}, Ei::Vector{Float64}, dof::Int)\n\nCalculates the constant-volume heat capacity for the given beta, omega factors, energies, and degrees of freedom. The heat capacity is defined as:\n\nC_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)\n\nwhere mathrmdof is the degrees of freedom, k_B is the Boltzmann constant (in units of eV/K), beta is the inverse temperature,  omega_i is the i-th omega factor, E_i is the i-th energy, Z(beta) is the partition function, and U(beta) is the internal energy.\n\nArguments\n\nβ::Float64: The inverse temperature.\nωi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies in eV.\ndof::Int: The degrees of freedom, equals to the number of dimensions times the number of particles.\n\nReturns\n\nThe constant-volume heat capacity.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{Vector{Float64}, Int64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(Ts::Vector{Float64}, dof::Int, energy_bins::Vector{Float64}, entropy::Vector{Float64})\n\n(Wang-Landau Sampling) Calculates the constant-volume heat capacity at constant volume for the given temperatures, degrees of  freedom, energy bins, and entropy. The kinetic energy is treated classically, and is added to the heat capacity as dof cdot k_B2.\n\nArguments\n\nTs::Vector{Float64}: The temperatures in Kelvin.\ndof::Int: The degrees of freedom, equals to the number of dimensions times the number of particles. For a lattice, it is zero.\nenergy_bins::Vector{Float64}: The energy bins in eV.\nentropy::Vector{Float64}: The entropy.\n\nReturns\n\nA vector of constant-volume heat capacities.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.internal_energy-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.internal_energy","text":"internal_energy(β::Float64, ωi::Vector{Float64}, ei::Vector{Float64})\n\nCalculates the internal energy from the partition function for the given beta, omega factors, and energies. The internal energy is defined as:\n\nU(beta) = fracsum_i omega_i E_i exp(-E_i beta)sum_i omega_i exp(-E_i beta)\n\nwhere omega_i is the i-th omega factor, E_i is the i-th energy, and beta is the inverse temperature.\n\nArguments\n\nβ::Float64: The inverse temperature.\nωi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies in eV.\n\nReturns\n\nThe internal energy.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.partition_function-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.partition_function","text":"partition_function(β::Float64, ωi::Vector{Float64}, Ei::Vector{Float64})\n\nCalculates the partition function for the given beta, omega factors, and energies. The partition function is defined as:\n\nZ(beta) = sum_i omega_i exp(-E_i beta)\n\nwhere omega_i is the i-th omega factor, E_i is the i-th energy, and beta is the inverse temperature.\n\nArguments\n\nβ::Float64: The inverse temperature.\nωi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies.\n\nReturns\n\nThe partition function.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.read_output-Tuple{String}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.read_output","text":"read_output(filename::String)\n\nReads the output file and returns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.ωᵢ-Tuple{AbstractVector{Int64}, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.ωᵢ","text":"ωᵢ(iters::Vector{Int}, n_walkers::Int; n_cull::Int=1, ω0::Float64=1.0)\n\nCalculates the omega factors for the given number of iterations and walkers. The omega factors account for the fractions of phase-space volume sampled during each nested sampling iteration, defined as:\n\nomega_i = fracCK+C left(fracKK+Cright)^i\n\nwhere K is the number of walkers, C is the number of culled walkers,  and i is the iteration number.\n\nArguments\n\niters::Vector{Int}: The iteration numbers.\nn_walkers::Int: The number of walkers.\nn_cull::Int: The number of culled walkers. Default is 1.\nω0::Float64: The initial omega factor. Default is 1.0.\n\nReturns\n\nA vector of omega factors.\n\n\n\n\n\n","category":"method"},{"location":"AbstractHamiltonians/#AbstractHamiltonians","page":"AbstractHamiltonians","title":"AbstractHamiltonians","text":"","category":"section"},{"location":"AbstractHamiltonians/#Functions","page":"AbstractHamiltonians","title":"Functions","text":"","category":"section"},{"location":"AbstractHamiltonians/","page":"AbstractHamiltonians","title":"AbstractHamiltonians","text":"Modules = [AbstractHamiltonians]","category":"page"},{"location":"AbstractHamiltonians/#FreeBird.AbstractHamiltonians","page":"AbstractHamiltonians","title":"FreeBird.AbstractHamiltonians","text":"AbstractHamiltonians\n\nModule for defining and implementing Hamiltonians.\n\n\n\n\n\n","category":"module"},{"location":"AbstractHamiltonians/#FreeBird.AbstractHamiltonians.GenericLatticeHamiltonian","page":"AbstractHamiltonians","title":"FreeBird.AbstractHamiltonians.GenericLatticeHamiltonian","text":"struct GenericLatticeHamiltonian{N,U} <: ClassicalHamiltonian\n\nThe GenericLatticeHamiltonian struct represents a generic lattice Hamiltonian.  It has an on-site interaction energy and a N-elements vector of nth-neighbor interaction energies. Units of energy U is also specified.\n\nFields\n\non_site_interaction::U: The energy of on-site interactions.\nnth_neighbor_interactions::SVector{N, U}: The energy of nth-neighbor interactions.\n\nConstructors\n\nGenericLatticeHamiltonian(on_site_interaction::Float64, nth_neighbor_interactions::Vector{Float64}, energy_units::Unitful.Units)\nGenericLatticeHamiltonian(on_site_interaction::U, nth_neighbor_interactions::Vector{U}) where U\n\nExamples\n\njulia> ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\")\nGenericLatticeHamiltonian{2,Quantity{Float64, 𝐋² 𝐌 𝐓⁻², Unitful.FreeUnits{(eV,), 𝐋² 𝐌 𝐓⁻², nothing}}}:\n    on_site_interaction:      -0.04 eV\n    nth_neighbor_interactions: [-0.01, -0.0025] eV\n\n\njulia> ham = GenericLatticeHamiltonian(-0.04u\"eV\", [-0.01, -0.0025]*u\"eV\")\nGenericLatticeHamiltonian{2,Quantity{Float64, 𝐋² 𝐌 𝐓⁻², Unitful.FreeUnits{(eV,), 𝐋² 𝐌 𝐓⁻², nothing}}}:\n    on_site_interaction:      -0.04 eV\n    nth_neighbor_interactions: [-0.01, -0.0025] eV\n\n\n\n\n\n","category":"type"},{"location":"AbstractHamiltonians/#FreeBird.AbstractHamiltonians.MLatticeHamiltonian","page":"AbstractHamiltonians","title":"FreeBird.AbstractHamiltonians.MLatticeHamiltonian","text":"    struct MLatticeHamiltonian{C,N,U} <: ClassicalHamiltonian\n\nThe MLatticeHamiltonian struct represents a multi-component lattice Hamiltonian. It has a matrix of GenericLatticeHamiltonian{N,U}.\n\nFields\n\nHamiltonians::Matrix{GenericLatticeHamiltonian{N,U}}: The matrix of GenericLatticeHamiltonian{N,U}.\n\nConstructors\n\nMLatticeHamiltonian(Hamiltonians::Vector{GenericLatticeHamiltonian{N,U}})\n\nExamples\n\njulia> hams = [GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\") for i in 1:4] # full flattened matrix\njulia> mlham = MLatticeHamiltonian(hams)\njulia> hams = [GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\") for i in 1:3] # upper triangular matrix\njulia> mlham = MLatticeHamiltonian(2, hams)\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#AbstractWalkers","page":"AbstractWalkers","title":"AbstractWalkers","text":"","category":"section"},{"location":"AbstractWalkers/#Functions","page":"AbstractWalkers","title":"Functions","text":"","category":"section"},{"location":"AbstractWalkers/","page":"AbstractWalkers","title":"AbstractWalkers","text":"Modules = [AbstractWalkers]","category":"page"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers","text":"AbstractWalkers\n\nModule containing abstract definitions for walkers.\n\n\n\n\n\n","category":"module"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.AtomWalker","text":"mutable struct AtomWalker\n\nThe AtomWalker struct represents a walker composed of atoms/molecules.\n\nFields\n\nconfiguration::FastSystem: The configuration of the walker.\nenergy::typeof(0.0u\"eV\"): The energy of the walker.\niter::Int64: The current iteration number of the walker.\nlist_num_par::Vector{Int64}: The list of the number of particles for each component.\nfrozen::Vector{Bool}: A boolean vector indicating whether each component is frozen or not.\nenergy_frozen_part::typeof(0.0u\"eV\"): The energy of the frozen particles in the walker, serves as a constant energy offset   to the interacting part of the system.\n\nConstructor\n\nAtomWalker(configuration::FastSystem; energy=0.0u\"eV\", iter=0, list_num_par=zeros(Int,C), frozen=zeros(Bool,C), energy_frozen_part=0.0u\"eV\"):    Constructs a new AtomWalker object with the given configuration and optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.AtomWalker","text":"AtomWalker(configuration::AbstractSystem; freeze_species::Vector{Symbol}=Symbol[], merge_same_species=true)\n\nConstructs an AtomWalker object with the given configuration.\n\nArguments\n\nconfiguration::AbstractSystem: The configuration of the walker.\nfreeze_species::Vector{Symbol}: A vector of species to freeze.\nmerge_same_species::Bool: A boolean indicating whether to merge the same species into one component.\n\nReturns\n\nAtomWalker{C}: The constructed AtomWalker object.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"Å\"\n\n        .--------------.  \n       /|Fel           |  \n      / H   H   Cl     |  \n     /  Hu   O         |  \n    *   |       Au   Fe|  \n    |   |FeCl        Fe|  \n    |   |        Au    |  \n    |   .---------Au---.  \n    |  /           H  /   \n    | Au Cl          /    \n    |/              /     \n    *--------------*      \n\njulia> AtomWalker(at;freeze_species=[:H],merge_same_species=false)\nAtomWalker{6}(FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"), 0.0 eV, 0, [2, 3, 1, 6, 4, 5], Bool[1, 1, 0, 0, 0, 0], 0.0 eV)\n\njulia> AtomWalker(at;freeze_species=[:H],merge_same_species=true)\nAtomWalker{5}(FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"), 0.0 eV, 0, [5, 1, 6, 4, 5], Bool[1, 0, 0, 0, 0], 0.0 eV)\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.LatticeGeometry","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.LatticeGeometry","text":"abstract type LatticeGeometry\n\nThe LatticeGeometry abstract type represents the geometry of a lattice. It has the following subtypes:\n\nSquareLattice: A square lattice.\nTriangularLattice: A triangular lattice.\nGenericLattice: A generic lattice. Currently used for non-square and non-triangular lattices.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.LatticeWalker","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.LatticeWalker","text":"mutable struct LatticeWalker\n\nThe LatticeWalker struct represents a walker on a 3D lattice.\n\nFields\n\nconfiguration::AbstractLattice: The configuration of the walker.\nenergy::Float64: The energy of the walker.\niter::Int64: The current iteration number of the walker.\n\nConstructor\n\nLatticeWalker(configuration::AbstractLattice; energy=0.0, iter=0)\n\nCreate a new LatticeWalker with the given configuration and optional energy and iteration number.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.MLattice","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.MLattice","text":"mutable struct MLattice{C,G}\n\nA mutable struct representing a lattice with the following fields:\n\nlattice_vectors::Matrix{Float64}: The lattice vectors defining the unit cell.\npositions::Matrix{Float64}: The positions of the lattice points.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis vectors within the unit cell.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\nperiodicity::Tuple{Bool, Bool, Bool}: The periodicity in each dimension.\ncomponents::Vector{Vector{Bool}}: The components of the lattice.\nneighbors::Vector{Vector{Vector{Int}}}: The neighbors of each lattice point.\nadsorptions::Vector{Bool}: The adsorption sites on the lattice.\n\nInner Constructor\n\nMLattice{C,G}(\n    lattice_vectors::Matrix{Float64},\n    basis::Vector{Tuple{Float64, Float64, Float64}},\n    supercell_dimensions::Tuple{Int64, Int64, Int64},\n    periodicity::Tuple{Bool, Bool, Bool},\n    components::Vector{Vector{Bool}},\n    adsorptions::Vector{Bool},\n    cutoff_radii::Vector{Float64},\n) where {C,G}\n\nCreates an MLattice instance with the specified parameters. The constructor performs the following steps:\n\nValidates that the number of components matches the expected value C.\nComputes the positions of the lattice points using lattice_positions.\nComputes the supercell lattice vectors.\nComputes the neighbors of each lattice point using compute_neighbors.\n\nThrows an ArgumentError if the number of components does not match C.\n\nOuter Constructors\n\nMLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,\n                           basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],\n                           supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),\n                           periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n                           cutoff_radii::Vector{Float64}=[1.1, 1.5],\n                           components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n                           adsorptions::Union{Vector{Int},Symbol}=:full)\n\nMLattice{C,TriangularLattice}(; lattice_constant::Float64=1.0,\n                              basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0),(1/2, sqrt(3)/2, 0.0)],\n                              supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 2, 1),\n                              periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n                              cutoff_radii::Vector{Float64}=[1.1, 1.5],\n                              components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n                              adsorptions::Union{Vector{Int},Symbol}=:full)\n\nConstructs a square/triangular lattice with the specified parameters. The components and adsorptions arguments can be a vector of integers specifying the indices of the occupied sites, or a symbol. If components is :equal, the lattice is divided into C equal components when possible, or  nearest to equal components otherwise. If adsorptions is :full, all sites are classified as adsorption sites.\n\nReturns\n\nMLattice{C,G}: A square/triangular lattice object with C components.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.check_num_components-Tuple{Int64, Vector{Int64}, Vector{Bool}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.check_num_components","text":"check_num_components(C::Int, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCheck that the number of components matches the length of the list of number of particles and frozen particles.\n\nArguments\n\nC::Int: The number of components.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.custom_sort-Tuple{Vector{Int64}, Int64}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.custom_sort","text":"custom_sort(arr::Vector{Int}, period::Int)\n\nSorts [1,2,3,4,5,6,7,8] into [1,3,5,7,2,4,6,8] for period = 2. Useful for printing triangular lattices.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.lattice_positions-Tuple{Matrix{Float64}, Vector{Tuple{Float64, Float64, Float64}}, Tuple{Int64, Int64, Int64}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.lattice_positions","text":"latticepositions(latticevectors::Matrix{Float64}, basis::Vector{Tuple{Float64, Float64, Float64}}, supercell_dimensions::Tuple{Int64, Int64, Int64})\n\nCompute the positions of atoms in a 3D lattice.\n\nArguments\n\nlattice_vectors::Matrix{Float64}: The lattice vectors of the system.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis of the system.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\n\nReturns\n\npositions::Matrix{Float64}: The positions of the atoms in the supercell.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.merge_components-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.merge_components","text":"merge_components(lattice::MLattice{C}) where C\n\nMerges the boolvec of components into a single vector of integers, where each integer represents the component number.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.mlattice_setup-Tuple{Int64, Vector{Tuple{Float64, Float64, Float64}}, Tuple{Int64, Int64, Int64}, Union{Vector{Vector{Bool}}, Vector{Vector{Int64}}, Symbol}, Union{Vector{Bool}, Vector{Int64}, Symbol}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.mlattice_setup","text":"mlattice_setup(C::Int, \n                 basis::Vector{Tuple{Float64, Float64, Float64}},\n                 supercell_dimensions::Tuple{Int64, Int64, Int64},\n                 components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol},\n                 adsorptions::Union{Vector{Int}, Vector{Bool}, Symbol})\n\nSetup the components and adsorptions for a lattice.\n\nArguments\n\nC::Int: The number of components.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis of the lattice.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\ncomponents::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}: The components of the lattice.\nadsorptions::Union{Vector{Int}, Vector{Bool}, Symbol}: The adsorption sites on the lattice.\n\nReturns\n\nlattice_comp::Vector{Vector{Bool}}: The components of the lattice.\nlattice_adsorptions::Vector{Bool}: The adsorption sites on the lattice.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.num_sites-Tuple{AbstractLattice}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.num_sites","text":"num_sites(lattice::AbstractLattice)\n\nReturns the total number of sites in a lattice given a AbstractLattice object. Returns the total number of sites.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.occupied_site_count-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.occupied_site_count","text":"occupied_site_count(MLattice::MLattice{C})\n\nReturns the number of occupied sites in each component of a lattice in an array.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.sort_components_by_atomic_number-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.sort_components_by_atomic_number","text":"sort_components_by_atomic_number(at::AbstractSystem; merge_same_species=true)\n\nSorts the components of an AbstractSystem object at by their atomic number.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem object.\n\nKeyword Arguments\n\nmerge_same_species::Bool=true: Whether to merge components with the same species.\n\nReturns\n\nlist_num_par::Vector{Int64}: A vector containing the number of each component species.\nnew_list::FastSystem: A new FastSystem object with the sorted components.\n\nThe function first extracts the atomic numbers of the components in at. If merge_same_species is true, it sorts the unique species and counts the number of each species. If merge_same_species is false, it creates a list of species and their counts. It then sorts the species and counts by atomic number. Finally, it constructs a new FastSystem object with the sorted components and returns the list of species counts and the new FastSystem object.\n\nExamples\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"Å\"\n\n        .--------------.  \n       /|     Cl    H  |  \n      / |      Fe      |  \n     /  |  Au     FeH  |  \n    *   |   FeH  ACl   |  \n    |   |    Cl     Au |  \n    |   |            O |  \n    |   .--Fe----------.  \n    |  /H  Cl         /   \n    | /          Au  /    \n    |/Cl          Cl/     \n    *--------------*      \n\n\njulia> AbstractWalkers.sort_components_by_atomic_number(at; merge_same_species=false)\n([2, 3, 1, 6, 4, 5], FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"))\n\njulia> AbstractWalkers.sort_components_by_atomic_number(at)\n([5, 1, 6, 4, 5], FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"))\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_components-Tuple{AtomsBase.AbstractSystem, Vector{Int64}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_components","text":"split_components(at::AbstractSystem, list_num_par::Vector{Int})\n\nSplit the system into components based on the number of particles in each component.\n\nArguments\n\nat::AbstractSystem: The system to split.\nlist_num_par::Vector{Int}: The number of particles in each component.\n\nReturns\n\ncomponents: An array of FastSystem objects representing the components of the system.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_components_by_chemical_species-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_components_by_chemical_species","text":"split_components_by_chemical_species(at::AbstractSystem)\n\nSplit an AbstractSystem into multiple components based on the chemical species.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem to be split.\n\nReturns\n\nAn array of FastSystem objects, each representing a component of the input system.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"Å\"\n\n        .--------------.  \n       /Au      Cl     |  \n      / |HAu Fe        |  \n     /  |     Cl Cl Cl |  \n    *   |Cle           |  \n    |   | Cl      H    |  \n    |   |      OAuH    |  \n    |FeFe-----------H--.  \n    |  /          Au  /   \n    | /      Au      /    \n    |/              /     \n    *--------------*      \n\n\njulia> AbstractWalkers.split_components_by_chemical_species(at)\n5-element Vector{FastSystem}:\n FastSystem(H₅, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(Cl₆, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(Fe₄, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(Au₅, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_into_subarrays-Tuple{AbstractVector, Int64}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_into_subarrays","text":"split_into_subarrays(arr::AbstractVector, N::Int)\n\nSplit an array into N subarrays of approximately equal size.\n\nArguments\n\narr::AbstractVector: The array to split.\nN::Int: The number of subarrays to create.\n\nReturns\n\nsubarrays::Vector{Vector{eltype(arr)}}: A vector of subarrays.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.update_walker!-Tuple{AtomWalker, Symbol, Any}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.update_walker!","text":"update_walker!(walker::AtomWalker, key::Symbol, value)\n\nUpdate the properties of an AtomWalker object.\n\nA convenient function that updates the value of a specific property of an AtomWalker object.\n\nArguments\n\nwalker::AtomWalker: The AtomWalker object to be updated.\nkey::Symbol: The key of the property to be updated.\nvalue: The new value of the property.\n\nReturns\n\nwalker::AtomWalker: The updated AtomWalker object.\n\nExample\n\nupdate_walker!(walker, :energy, 10.0u\"eV\")\nupdate_walker!(walker, :iter, 1)\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.view_structure-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.view_structure","text":"view_structure(at::AbstractSystem)\nview_structure(walker::AtomWalker)\n\nPrint an ASCII representation of the system.\n\n\n\n\n\n","category":"method"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"EditURL = \"../../scripts/examples.jl\"","category":"page"},{"location":"examples/#FreeBird.jl-Examples","page":"Examples","title":"FreeBird.jl Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we provide a few examples of how to use FreeBird.jl. We focus on how to set up a sampling run with various sampling schemes. You may need to fine-tune the parameters for your specific system.","category":"page"},{"location":"examples/#Atomistic-system","page":"Examples","title":"Atomistic system","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Before we start, we need to load the FreeBird.jl package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FreeBird","category":"page"},{"location":"examples/#Nested-Sampling","page":"Examples","title":"Nested Sampling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, let's generate some initial configurations","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"configs = generate_initial_configs(120, 562.5, 6)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Walkers are the objects that will be used in the simulation. They contain the information about the system's configuration. Let's warp the configurations into walkers.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"walkers = AtomWalker.(generate_initial_configs(120, 562.5, 6))\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's define the Lennard-Jones potential","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"lj = LJParameters(epsilon=0.1, sigma=2.5, cutoff=4.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then create a LJAtomWalkers object that contains the walkers and the Lennard-Jones potential.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ls = LJAtomWalkers(walkers, lj)\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then set up a NestedSamplingParameters object with the desired parameters. See the documentation for more information.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ns_params = NestedSamplingParameters(mc_steps=200, step_size=0.1, random_seed=1234*rand(Int))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then set up how we want to perform the Monte Carlo moves. MCRandomWalkClone is a routine that clones an existing walker and performs random walks.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc = MCRandomWalkClone()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We also set up a SaveEveryN object for saving the output.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"save = SaveEveryN(n_traj=10, n_snap=20_000, df_filename=\"output_df_lj6.csv\", n_info=10)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we run the nested sampling simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"energies, liveset, _ = nested_sampling(ls, ns_params, 1_000, mc, save)","category":"page"},{"location":"examples/#Metropolis-Monte-Carlo","page":"Examples","title":"Metropolis Monte Carlo","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similarly to nested sampling, we need to define some MC parameters. We will use the same Lennard-Jones potential and initial configurations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's use a walker from the previous example as the initial configuration.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"at = ls.walkers[1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define the temperature grid, the number of equilibration steps, the number of sampling steps, and the step size.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"temperatures = collect(1000.0:-50:0)\nnum_equilibration_steps = 100_000\nnum_sampling_steps = 100_000\nstep_size = 1.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pass the parameters to the MetropolisMCParameters object.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc_params = MetropolisMCParameters(\n    temperatures,\n    equilibrium_steps=num_equilibration_steps,\n    sampling_steps=num_sampling_steps,\n    step_size=step_size,\n    step_size_up=1.0,\n    accept_range=(0.5,0.5)\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Run the Monte Carlo simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc_energies, mc_ls, mc_cvs, acceptance_rates = monte_carlo_sampling(at, lj, mc_params)","category":"page"},{"location":"examples/#Wang-Landau-Sampling","page":"Examples","title":"Wang-Landau Sampling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"It's also very easy to set up a Wang-Landau simulation. We will use the same Lennard-Jones potential and initial configuration.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"at = ls.walkers[1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define the step size and the energy range.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"step_size = 1.0\nenergy_min = -1.26\nenergy_max = 0.0\nnum_energy_bins = 1000","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pass the parameters to the WangLandauParameters object.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wl_params = WangLandauParameters(num_steps=10_000,\n                            energy_min=energy_min,\n                            energy_max=energy_max,\n                            num_energy_bins=num_energy_bins,\n                            step_size=step_size,\n                            max_iter=10000,\n                            f_min=1.00001)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Viola! We can now run the Wang-Landau simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"energies_wl, configs, wl_params, S, H = wang_landau(at, lj, wl_params)","category":"page"},{"location":"examples/#Lattice-system","page":"Examples","title":"Lattice system","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also perform simulations on lattice systems.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's set up a 2D square lattice with a supercell of dimensions 4x4x1. Make the first four sites occupied.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"initial_lattice = SLattice{SquareLattice}(components=[[1,2,3,4]])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define the Hamiltonian with the adsorption energy and the nearest-neighbor and next-nearest-neighbor energies.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"adsorption_energy = -0.04\nnn_energy = -0.01\nnnn_energy = -0.0025\nh = GenericLatticeHamiltonian(adsorption_energy, [nn_energy, nnn_energy], u\"eV\")","category":"page"},{"location":"examples/#Wang-Landau-Sampling-2","page":"Examples","title":"Wang-Landau Sampling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This time, let's do a Wang-Landau simulation first, as it's the most straightforward to set up.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"energy_min = 20.5 * nn_energy + nn_energy / 8\nenergy_max = 16 * nn_energy - nn_energy / 8\nnum_energy_bins = 100","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pass the parameters to the WangLandauParameters object.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"wl_params = WangLandauParameters(\n    energy_min=energy_min,\n    energy_max=energy_max,\n    random_seed=Int(round(time() * 1000)),)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Run the Wang-Landau simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"energies_wl, configs, wl_params, S, H = wang_landau(initial_lattice, h, wl_params)","category":"page"},{"location":"examples/#Metroplis-Monte-Carlo","page":"Examples","title":"Metroplis Monte Carlo","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's make a Metropolis Monte Carlo simulation on the same lattice system.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc_lattice = deepcopy(initial_lattice)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define the temperature grid, the number of equilibration steps, and the number of sampling steps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"temperatures = collect(200.0:-10:10)  # 200:-1:1\nnum_equilibration_steps = 25_000\nnum_sampling_steps = 25_000","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pass the parameters to the MetropolisMCParameters object.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc_params = MetropolisMCParameters(\n    temperatures,\n    equilibrium_steps=num_equilibration_steps,\n    sampling_steps=num_sampling_steps,\n    random_seed=Int(round(time()))\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Run the Monte Carlo simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc_energies, mc_configs, mc_cvs, acceptance_rates = monte_carlo_sampling(mc_lattice, h, mc_params)","category":"page"},{"location":"examples/#Nested-Sampling-2","page":"Examples","title":"Nested Sampling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, let's set up a nested sampling simulation. It's a bit more complicated than the previous two, and nested sampling is not the optimal method for lattice systems with many degenerate states.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's use the Distributions.jl package to generate the random initial configurations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Distributions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Make 1000 copies of the initial lattice.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"walkers = [deepcopy(initial_lattice) for i in 1:1000]\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now using the sample function from the Distributions.jl package, we can randomly select 4 sites to be occupied.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"for walker in walkers\n    walker.components[1] = [false for i in 1:length(walker.components[1])]\n    for i in sample(1:length(walker.components[1]), 4, replace=false)\n        walker.components[1][i] = true\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Warp the walkers into LatticeWalker objects.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"walkers = [LatticeWalker(walker) for walker in walkers]\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Again, we use the same Hamiltonian as before. We then create a LatticeGasWalkers object that contains the walkers and the Hamiltonian.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ls = LatticeGasWalkers(walkers, h)\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The rejection routine for nested sampling is the best choice for lattice systems.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mc = MCRejectionSampling()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then set up a LatticeNestedSamplingParameters object with the desired parameters. We will use the same parameters as before, but we will set the number of Monte Carlo steps to 100. We will also set the allowed fail count to 1000000, which is a bit high to make sure we explore the configuration space. We will also set the random seed to a random number.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ns_params = LatticeNestedSamplingParameters(mc_steps=100,allowed_fail_count=1_000_000,random_seed=Int(floor(1234*rand())))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Redefine the output file name.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"save = SaveEveryN(df_filename=\"output_ns_lattice2d.csv\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And finally, we can run the nested sampling simulation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ns_energies, ls, _ = nested_sampling(ls, ns_params, 10_000, mc, save) # src","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FreeBird.jl","page":"FreeBird.jl","title":"FreeBird.jl","text":"","category":"section"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Documentation for FreeBird.jl","category":"page"},{"location":"#Installation","page":"FreeBird.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"FreeBird.jl is a Julia package. Install Julia first following the instructions in the download page.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Once Julia is installed, you can install the FreeBird package from the Julia REPL with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"julia> ] # press the \"]\" key on your keyboard to enter the Pkg manager","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"then","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"pkg> add FreeBird","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Alternatively, you can install the package with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"using Pkg; Pkg.add(\"FreeBird\")","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Useful for installing the package in a script or a notebook.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Or, if you want to install a specific branch from GitHub, you can do so with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"pkg> add https://github.com/wexlergroup/FreeBird.jl#branch_name","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Or, again, to install the package in a script or a notebook:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"using Pkg; Pkg.add(url=\"https://github.com/wexlergroup/FreeBird.jl\",rev=\"branch_name\")","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Remember to replace branch_name with the name of the branch you want to install.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"To get back to the Julia REPL, press Ctrl+C or backspace (when the REPL cursor is at the beginning of the input).","category":"page"}]
}
