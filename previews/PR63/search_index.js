var documenterSearchIndex = {"docs":
[{"location":"FreeBirdIO/#EnergyEval","page":"FreeBirdIO","title":"EnergyEval","text":"","category":"section"},{"location":"FreeBirdIO/#Functions","page":"FreeBirdIO","title":"Functions","text":"","category":"section"},{"location":"FreeBirdIO/","page":"FreeBirdIO","title":"FreeBirdIO","text":"Modules = [FreeBirdIO]","category":"page"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO","text":"FreeBirdIO\n\nModule for input/output operations in the FreeBird package.\n\n\n\n\n\n","category":"module"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.DataSavingStrategy","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.DataSavingStrategy","text":"abstract type DataSavingStrategy\n\nAbstract type representing a strategy for saving data.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.SaveEveryN","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.SaveEveryN","text":"struct SaveEveryN <: DataSavingStrategy\n\nSaveEveryN is a concrete subtype of DataSavingStrategy that specifies saving data every N steps.\n\nFields\n\ndf_filename::String: The name of the file to save the DataFrame to.\nwk_filename::String: The name of the file to save the atom walker to.\nls_filename::String: The name of the file to save the liveset to.\nn_traj::Int: The number of steps between each save of the culled walker into a trajectory file.\nn_snap::Int: The number of steps between each save of the liveset into a snapshot file.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.append_walker-Union{Tuple{C}, Tuple{String, AtomWalker{C}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.append_walker","text":"append_walker(filename::String, at::AtomWalker)\n\nAppend an AtomWalker object to a file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.convert_system_to_walker-Tuple{AtomsBase.FlexibleSystem, Bool}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.convert_system_to_walker","text":"convert_system_to_walker(at::FlexibleSystem, resume::Bool)\n\nConverts a FlexibleSystem object to an AtomWalker object.\n\nArguments\n\nat::FlexibleSystem: The FlexibleSystem object to convert.\nresume::Bool: Whether to resume from previous data.\n\nReturns\n\nAtomWalker: The converted AtomWalker object.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.convert_walker_to_system-Tuple{AtomWalker}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.convert_walker_to_system","text":"convert_walker_to_system(at::AtomWalker)\n\nConverts an AtomWalker object to an AbstractSystem object.\n\nArguments\n\nat::AtomWalker: The AtomWalker object to be converted.\n\nReturns\n\nAbstractSystem: The converted AbstractSystem object.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_initial_configs-Tuple{Int64, Float64, Int64}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_initial_configs","text":"generate_initial_configs(num_walkers::Int, volume_per_particle::Float64, num_particle::Int; particle_type::Symbol=:H)\n\nGenerate initial configurations for a given number of walkers.\n\nArguments\n\nnum_walkers::Int: The number of walkers.\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Int: The number of particles.\nparticle_type::Symbol=:H: The type of particle (default is :H).\n\nReturns\n\nAn array of initial configurations for each walker.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_multi_type_random_starting_config-Tuple{Float64, Vector{Int64}}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_multi_type_random_starting_config","text":"generate_multi_type_random_starting_config(volume_per_particle::Float64, num_particle::Vector{Int}; particle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)])\n\nGenerate a random starting configuration for a system of particles with multiple types.\n\nArguments\n\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Vector{Int}: The number of particles of each type.\nparticle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)]: The types of particles.\n\nReturns\n\nFastSystem: A FastSystem object representing the generated system.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_random_starting_config-Tuple{Float64, Int64}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_random_starting_config","text":"generate_random_starting_config(volume_per_particle::Float64, num_particle::Int; particle_type::Symbol=:H)\n\nGenerate a random starting configuration for a system of particles.\n\nArguments\n\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Int: The number of particles.\nparticle_type::Symbol=:H: The type of particle (default is hydrogen).\n\nReturns\n\nFastSystem: A FastSystem object representing the generated system.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_configs-Tuple{String, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_configs","text":"read_configs(filename::String, pbc::Vector)\n\nReads atomic configurations from a file and applies periodic boundary conditions.\n\nArguments\n\nfilename::String: The name of the file containing the atomic configurations.\npbc::Vector: A vector specifying the periodic boundary conditions.\n\nReturns\n\nAn array of atomic configurations with periodic boundary conditions applied.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_configs-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_configs","text":"read_configs(filename::String; pbc::String=\"TTT\")\n\nReads configurations from a file.\n\nArguments\n\nfilename::String: The name of the file to read configurations from.\npbc::String=\"TTT\": Periodic boundary conditions. A string of length 3, where each character represents whether the corresponding dimension has periodic boundary conditions ('T') or not ('F').\n\nReturns\n\nThe configurations read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_config-Tuple{String, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_config","text":"read_single_config(filename::String, pbc::Vector)\n\nReads a single configuration from the specified file and sets the periodic boundary conditions (PBC) for the atoms.\n\nArguments\n\nfilename::String: The name of the file to read the configuration from.\npbc::Vector: A vector specifying the periodic boundary conditions.\n\nReturns\n\nat::Atoms: The atoms with the PBC set.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_config-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_config","text":"read_single_config(filename::String; pbc::String=\"TTT\")\n\nReads a single configuration from the specified file.\n\nArguments\n\nfilename::String: The name of the file to read from.\npbc::String=\"TTT\": The periodic boundary conditions. Default is \"TTT\".\n\nReturns\n\nThe configuration read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_walker-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_walker","text":"read_single_walker(filename::String; pbc::String=\"TTT\", resume::Bool=true)\n\nReads a single walker from the specified file.\n\nArguments\n\nfilename::String: The path to the file containing the walker data.\npbc::String: (optional) The periodic boundary conditions. Default is \"TTT\".\nresume::Bool: (optional) Whether to resume reading from a previous checkpoint. Default is true.\n\nReturns\n\nThe walker object read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_walkers-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_walkers","text":"read_walkers(filename::String; pbc::String=\"TTT\", resume::Bool=true)\n\nReads walker configurations from a file.\n\nArguments\n\nfilename::String: The name of the file to read the walker configurations from.\npbc::String: A string specifying the periodic boundary conditions. Default is \"TTT\".\nresume::Bool: A boolean indicating whether to resume reading from a previous checkpoint. Default is true.\n\nReturns\n\nAn array of walker objects.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.set_pbc-Tuple{ExtXYZ.Atoms, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.set_pbc","text":"set_pbc(at::Atoms, pbc::Vector)\n\nSet the periodic boundary conditions for a system of atoms.\n\nArguments\n\nat::Atoms: The system of atoms.\npbc::Vector: A vector of length 3 specifying the periodic boundary conditions for each dimension. Each element can be either true for periodic boundary conditions or false for Dirichlet zero boundary conditions.\n\nReturns\n\nFlexibleSystem: A flexible system with the specified boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_df-Tuple{String, DataFrames.DataFrame}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_df","text":"write_df(filename::String, df::DataFrame)\n\nWrite a DataFrame to a CSV file.\n\nArguments\n\nfilename::String: The name of the file to write to.\ndf::DataFrame: The DataFrame to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_df_every_n-Tuple{DataFrames.DataFrame, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_df_every_n","text":"write_df_every_n(df::DataFrame, step::Int, d_strategy::SaveEveryN)\n\nWrite the DataFrame df to a file specified by d_strategy.filename every d_strategy.n steps.\n\nArguments\n\ndf::DataFrame: The DataFrame to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the filename and the step interval.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_ls_every_n-Tuple{AbstractLiveSet, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_ls_every_n","text":"write_ls_every_n(ls::AtomWalkers, step::Int, d_strategy::SaveEveryN)\n\nWrite the liveset ls to file every n steps, as specified by the d_strategy.\n\nArguments\n\nls::AbstractLiveSet: The liveset to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the frequency of writing.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_single_walker-Tuple{String, AtomWalker, Bool}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_single_walker","text":"write_single_walker(filename::String, at::AtomWalker, append::Bool)\n\nWrite a single AtomWalker object to a file. If the file already exists, append the walker to the file.\n\nArguments\n\nfilename::String: The name of the file to write to.\nat::AtomWalker: The AtomWalker object to write.\nappend::Bool: A boolean indicating whether to append the walker to the file if it already exists.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_single_walker-Tuple{String, AtomWalker}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_single_walker","text":"write_single_walker(filename::String, at::AtomWalker)\n\nWrite a single AtomWalker object to a file.\n\nArguments\n\nfilename::String: The name of the file to write to.\nat::AtomWalker: The AtomWalker object to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walker_every_n-Tuple{AtomWalker, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walker_every_n","text":"write_walker_every_n(at::AtomWalker, step::Int, d_strategy::SaveEveryN)\n\nWrite the atom walker at to a file specified by d_strategy.wk_filename every d_strategy.n steps.\n\nArguments\n\nat::AtomWalker: The atom walker to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the file name and the interval.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walkers-Union{Tuple{C}, Tuple{String, Array{AtomWalker{C}, 1}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walkers","text":"write_walkers(filename::String, ats::Vector{AtomWalker})\n\nWrite a collection of AtomWalker objects to a file.\n\nArguments\n\nfilename::String: The name of the file to write the walkers to.\nats::Vector{AtomWalker}: The collection of AtomWalker objects to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walkers-Union{Tuple{C}, Tuple{String, Array{LatticeWalker{C}, 1}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walkers","text":"write_walkers(filename::String, ats::Vector{LatticeWalker})\n\nWrite a collection of LatticeWalker objects to a file.\n\nArguments\n\nfilename::String: The name of the file to write the walkers to.\nats::Vector{LatticeWalker}: The collection of LatticeWalker objects to write.\n\n\n\n\n\n","category":"method"},{"location":"Hamiltonians/#Hamiltonians","page":"Hamiltonians","title":"Hamiltonians","text":"","category":"section"},{"location":"Hamiltonians/#Functions","page":"Hamiltonians","title":"Functions","text":"","category":"section"},{"location":"Hamiltonians/","page":"Hamiltonians","title":"Hamiltonians","text":"Modules = [Hamiltonians]","category":"page"},{"location":"Hamiltonians/#FreeBird.Hamiltonians","page":"Hamiltonians","title":"FreeBird.Hamiltonians","text":"Method for defining and implementing Hamiltonians.\n\n\n\n\n\n","category":"module"},{"location":"Hamiltonians/#FreeBird.Hamiltonians.GenericLatticeHamiltonian","page":"Hamiltonians","title":"FreeBird.Hamiltonians.GenericLatticeHamiltonian","text":"struct GenericLatticeHamiltonian{N,U} <: ClassicalHamiltonian\n\nThe GenericLatticeHamiltonian struct represents a generic lattice Hamiltonian.  It has an on-site interaction energy and a N-elements vector of nth-neighbor interaction energies. Units of energy U is also specified.\n\nFields\n\non_site_interaction::U: The energy of on-site interactions.\nnth_neighbor_interactions::SVector{N, U}: The energy of nth-neighbor interactions.\n\nConstructors\n\nGenericLatticeHamiltonian(on_site_interaction::Float64, nth_neighbor_interactions::Vector{Float64}, energy_units::Unitful.Units)\nGenericLatticeHamiltonian(on_site_interaction::U, nth_neighbor_interactions::Vector{U}) where U\n\nExamples\n\njulia> ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\")\nGenericLatticeHamiltonian{2,Quantity{Float64, ùêã¬≤ ùêå ùêì‚Åª¬≤, Unitful.FreeUnits{(eV,), ùêã¬≤ ùêå ùêì‚Åª¬≤, nothing}}}:\n    on_site_interaction:      -0.04 eV\n    nth_neighbor_interactions: [-0.01, -0.0025] eV\n\n\njulia> ham = GenericLatticeHamiltonian(-0.04u\"eV\", [-0.01, -0.0025]*u\"eV\")\nGenericLatticeHamiltonian{2,Quantity{Float64, ùêã¬≤ ùêå ùêì‚Åª¬≤, Unitful.FreeUnits{(eV,), ùêã¬≤ ùêå ùêì‚Åª¬≤, nothing}}}:\n    on_site_interaction:      -0.04 eV\n    nth_neighbor_interactions: [-0.01, -0.0025] eV\n\n\n\n\n\n","category":"type"},{"location":"Hamiltonians/#FreeBird.Hamiltonians.MLatticeHamiltonian","page":"Hamiltonians","title":"FreeBird.Hamiltonians.MLatticeHamiltonian","text":"    struct MLatticeHamiltonian{C,N,U} <: ClassicalHamiltonian\n\nThe MLatticeHamiltonian struct represents a multi-component lattice Hamiltonian. It has a matrix of GenericLatticeHamiltonian{N,U}.\n\nFields\n\nHamiltonians::Matrix{GenericLatticeHamiltonian{N,U}}: The matrix of GenericLatticeHamiltonian{N,U}.\n\nConstructors\n\nMLatticeHamiltonian(Hamiltonians::Vector{GenericLatticeHamiltonian{N,U}})\n\nExamples\n\njulia> hams = [GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\") for i in 1:4]\njulia> mlham = MLatticeHamiltonian(hams)\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#Sampling-Schemes","page":"SamplingSchemes","title":"Sampling Schemes","text":"","category":"section"},{"location":"SamplingSchemes/#Functions","page":"SamplingSchemes","title":"Functions","text":"","category":"section"},{"location":"SamplingSchemes/","page":"SamplingSchemes","title":"SamplingSchemes","text":"Modules = [SamplingSchemes]","category":"page"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCDemonWalk","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCDemonWalk","text":"MCDemonWalk <: MCRoutine\n\nA Monte Carlo routine for performing demon walks.\n\nFields\n\ne_demon_tolerance::typeof(0.0u\"eV\"): The tolerance for the energy difference in the demon walk. Tighter tolerance will lead to lower overall acceptance of the demon walk.\ndemon_energy_threshold::typeof(0.0u\"eV\"): The energy threshold for the demon walk. Lower threshold will limit the exploration of the potential energy landscape but increase the overall acceptance of the demon walk.\ndemon_gain_threshold::typeof(0.0u\"eV\"): The gain threshold for the demon during each walk. Similar to the demon_energy_threshold, lower gain threshold will limit the exploration of the potential energy landscape but increase the overall acceptance of the demon walk.\nmax_add_steps::Int: The maximum number of steps to add in the demon walk if the demon energy e_demon is higher than the demon_energy_threshold.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCNewSample","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCNewSample","text":"struct MCNewSample <: MCRoutine\n\nA type for generating a new walker from a random configuration. Currently, it is intended to use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkClone","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkClone","text":"struct MCRandomWalkClone <: MCRoutine\n\nA type for generating a new walker by cloning an existing walker and performing a random walk for decorrelation.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkMaxE","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkMaxE","text":"struct MCRandomWalkMaxE <: MCRoutine\n\nA type for generating a new walker by performing a random walk for decorrelation on the highest-energy walker.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRoutine","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRoutine","text":"abstract type MCRoutine\n\nAn abstract type representing a Monte Carlo routine.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MixedMCRoutine","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MixedMCRoutine","text":"struct MixedMCRoutine <: MCRoutine\n\nA mutable struct representing a mixed Monte Carlo routine, where the main routine is used for the majority of the steps,      and the backup routine is used when the main routine fails to accept a move. Currently, it is intended to use MCRandomWalk      as the main routine and MCDemonWalk as the backup routine.\n\nFields\n\nmain_routine::MCRoutine: The main Monte Carlo routine.\nback_up_routine::MCRoutine: The backup Monte Carlo routine.\nns_params_main::NestedSamplingParameters: The nested sampling parameters for the main routine.\nns_params_back_up::NestedSamplingParameters: The nested sampling parameters for the backup routine.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.NestedSamplingParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.NestedSamplingParameters","text":"mutable struct NestedSamplingParameters <: SamplingParameters\n\nThe NestedSamplingParameters struct represents the parameters used in the nested sampling scheme.\n\nFields\n\nmc_steps::Int64: The number of total Monte Carlo moves to perform.\ninitial_step_size::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.\nstep_size::Float64: The on-the-fly step size used in the sampling process.\nstep_size_lo::Float64: The lower bound of the step size.\nstep_size_up::Float64: The upper bound of the step size.\nfail_count::Int64: The number of failed MC moves in a row.\nallowed_fail_count::Int64: The maximum number of failed MC moves allowed before resetting the step size.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.adjust_step_size-Tuple{NestedSamplingParameters, Float64}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.adjust_step_size","text":"adjust_step_size(ns_params::NestedSamplingParameters, rate::Float64)\n\nAdjusts the step size of the nested sampling algorithm based on the acceptance rate.      If the acceptance rate is greater than 0.75, the step size is increased by 1%.      If the acceptance rate is less than 0.25, the step size is decreased by 1%.\n\nArguments\n\nns_params::NestedSamplingParameters: The parameters of the nested sampling algorithm.\nrate::Float64: The acceptance rate of the algorithm.\nrange::Tuple{Float64, Float64}: The range of acceptance rates for adjusting the step size. Default is (0.25, 0.75).\n\nReturns\n\nns_params::NestedSamplingParameters: The updated parameters with adjusted step size.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.exact_enumeration-Union{Tuple{G}, Tuple{C}, Tuple{MLattice{C, G}, ClassicalHamiltonian}} where {C, G}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.exact_enumeration","text":"exact_enumeration(lattice::SLattice{G}, cutoff_radii::Tuple{Float64, Float64}, h::LatticeGasHamiltonian) where G\n\nEnumerate all possible configurations of a lattice system and compute the energy of each configuration.\n\nArguments\n\nlattice::SLattice{G}: The (starting) lattice system to enumerate. All possible configurations will be generated from this lattice system.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\n\nReturns\n\nDataFrame: A DataFrame containing the energy and configuration of each configuration.\nLatticeGasWalkers: A collection of lattice walkers for each configuration.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_loop!-Tuple{AtomWalkers, Int64, MixedMCRoutine, DataSavingStrategy}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_loop!","text":"nested_sampling_loop!(liveset::AtomWalkers, n_steps::Int64, mc_routine::MixedMCRoutine, save_strategy::DataSavingStrategy)\n\nPerform a nested sampling loop for a given number of steps.\n\nArguments\n\nliveset::AtomWalkers: The initial set of walkers.\nn_steps::Int64: The number of steps to perform.\nmc_routine::MixedMCRoutine: The mixed Monte Carlo routine to use.\nsave_strategy::DataSavingStrategy: The strategy for saving data.\n\nReturns\n\ndf::DataFrame: The data frame containing the iteration number and maximum energy for each step.\nliveset::AtomWalkers: The updated set of walkers.\nmc_routine.ns_params_main: The updated nested sampling parameters for the main routine.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_loop!-Tuple{AtomWalkers, NestedSamplingParameters, Int64, MCRoutine, DataSavingStrategy}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_loop!","text":"nested_sampling_loop!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, n_steps::Int64, mc_routine::MCRoutine; args...)\n\nPerform a nested sampling loop for a given number of steps.\n\nArguments\n\nliveset::AtomWalkers: The initial set of walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nn_steps::Int64: The number of steps to perform.\nmc_routine::MCRoutine: The Monte Carlo routine to use.\n\nReturns\n\ndf: A DataFrame containing the iteration number and maximum energy for each step.\nliveset: The updated set of walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_loop!-Tuple{LatticeGasWalkers, LatticeNestedSamplingParameters, Int64, MCRoutine, DataSavingStrategy}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_loop!","text":"nested_sampling_loop!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, n_steps::Int64, mc_routine::MCRoutine; args...)\n\nPerform a nested sampling loop on a lattice gas system for a given number of steps.\n\nArguments\n\nliveset::LatticeGasWalkers: The initial set of walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nn_steps::Int64: The number of steps to perform.\nmc_routine::MCRoutine: The Monte Carlo routine to use.\n\nKeyword Arguments\n\nargs...: Additional arguments.\n\nReturns\n\ndf: A DataFrame containing the iteration number and maximum energy for each step.\nliveset: The updated set of walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{AtomWalkers, NestedSamplingParameters, MCDemonWalk}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, mc_routine::MCDemonWalk)\n\nPerform a single step of the nested sampling algorithm using the Monte Carlo demon walk routine.\n\nArguments\n\nliveset::AtomWalkers: The set of atom walkers representing the current state of the system.\nns_params::NestedSamplingParameters: The parameters for the nested sampling algorithm.\nmc_routine::MCDemonWalk: The parameters for the Monte Carlo demon walk.\n\nReturns\n\niter: The iteration number after the step.\nemax: The maximum energy recorded during the step.\nliveset: The updated set of atom walkers after the step.\nns_params: The updated nested sampling parameters after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{AtomWalkers, NestedSamplingParameters, MCRoutine}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, mc_routine::MCRandomWalk)\n\nPerform a single step of the nested sampling algorithm using the Monte Carlo random walk routine.\n\nArguments\n\nliveset::AtomWalkers: The set of atom walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCRandomWalk: The Monte Carlo random walk routine. Currently within this function, the random walk is only applied to the highest-energy walker, i.e., the one being culled.\n\nReturns\n\niter: The iteration number after the step.\nemax: The highest energy recorded during the step.\nliveset: The updated set of atom walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{LatticeGasWalkers, LatticeNestedSamplingParameters, MCNewSample}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, mc_routine::MCNewSample; accept_same_config::Bool=false)\n\nPerform a single step of the nested sampling algorithm.\n\nThis function takes a liveset of lattice gas walkers, ns_params containing the parameters for nested sampling, and mc_routine representing the Monte Carlo routine for generating new samples. It performs a single step of the nested sampling algorithm by updating the liveset with a new walker.\n\nArguments\n\nliveset::LatticeGasWalkers: The liveset of lattice gas walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCNewSample: The Monte Carlo routine for generating new samples.\naccept_same_config::Bool=true: A flag indicating whether to accept a new sample with the same configuration as an existing one.\n\nReturns\n\niter: The iteration number of the liveset after the step.\nemax: The maximum energy of the liveset after the step.\nliveset::LatticeGasWalkers: The updated liveset after the step.\nns_params::LatticeNestedSamplingParameters: The updated nested sampling parameters after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{LatticeGasWalkers, LatticeNestedSamplingParameters, MCRoutine}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, mc_routine::MCRoutine; accept_same_config::Bool=true)\n\nPerform a single step of the nested sampling algorithm.\n\nThis function takes a liveset of lattice gas walkers, ns_params containing the parameters for nested sampling, and mc_routine representing the Monte Carlo  routine for generating new samples. It performs a single step of the nested sampling algorithm by updating the liveset with a new walker.\n\nArguments\n\nliveset::LatticeGasWalkers: The liveset of lattice gas walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCRoutine: The Monte Carlo routine for generating new samples.\naccept_same_config::Bool=true: A flag indicating whether to accept a new sample with the same configuration as an existing one. Default is true. Note that \n\nif it is set to false, the sampling process may take significantly longer to find a new configuration.\n\nReturns\n\niter: The iteration number of the liveset after the step.\nemax: The maximum energy of the liveset after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.sort_by_energy!-Tuple{AbstractLiveSet}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.sort_by_energy!","text":"sort_by_energy!(liveset::LJAtomWalkers)\n\nSorts the walkers in the liveset by their energy in descending order.\n\nArguments\n\nliveset::LJAtomWalkers: The liveset of walkers to be sorted.\n\nReturns\n\nliveset::LJAtomWalkers: The sorted liveset.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.update_iter!-Tuple{AbstractLiveSet}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.update_iter!","text":"update_iter!(liveset::AtomWalkers)\n\nUpdate the iteration count for each walker in the liveset.\n\nArguments\n\nliveset::AtomWalkers: The set of walkers to update.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#EnergyEval","page":"EnergyEval","title":"EnergyEval","text":"","category":"section"},{"location":"EnergyEval/#Functions","page":"EnergyEval","title":"Functions","text":"","category":"section"},{"location":"EnergyEval/","page":"EnergyEval","title":"EnergyEval","text":"Modules = [EnergyEval]","category":"page"},{"location":"EnergyEval/#FreeBird.EnergyEval","page":"EnergyEval","title":"FreeBird.EnergyEval","text":"Module for evaluating energy-related quantities for a system.\n\n\n\n\n\n","category":"module"},{"location":"EnergyEval/#FreeBird.EnergyEval.check_num_components-Tuple{Int64, Vector{Int64}, Vector{Bool}}","page":"EnergyEval","title":"FreeBird.EnergyEval.check_num_components","text":"check_num_components(C::Int, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCheck that the number of components matches the length of the list of number of particles and frozen particles.\n\nArguments\n\nC::Int: The number of components.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.frozen_energy-Tuple{AtomsBase.AbstractSystem, LJParameters, Vector{Int64}, Vector{Bool}}","page":"EnergyEval","title":"FreeBird.EnergyEval.frozen_energy","text":"frozen_energy(at::AbstractSystem, lj::LJParameters, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy of the frozen particles in the system using a single Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the frozen particles. Since the frozen particles do not move, the energy is typically only calculated once for a given system.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nlj::LJParameters: The Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy of the frozen particles in the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.frozen_energy-Union{Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeLJParameters{C}, Vector{Int64}, Vector{Bool}}} where C","page":"EnergyEval","title":"FreeBird.EnergyEval.frozen_energy","text":"frozen_energy(at::AbstractSystem, ljs::CompositeLJParameters{C}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy of the frozen particles in the system using a composite Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the frozen particles. Since the frozen particles do not move, the energy is typically only calculated once for a given system.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nljs::CompositeLJParameters{C}: The composite Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy of the frozen particles in the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.inter_component_energy-Tuple{AtomsBase.AbstractSystem, AtomsBase.AbstractSystem, LJParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.inter_component_energy","text":"inter_component_energy(at1::AbstractSystem, at2::AbstractSystem, lj::LJParameters)\n\nCompute the energy between two components of a system using the Lennard-Jones potential.\n\nArguments\n\nat1::AbstractSystem: The first component of the system.\nat2::AbstractSystem: The second component of the system.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy: The energy between the two components.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.inter_component_energy-Union{Tuple{U}, Tuple{N}, Tuple{Vector{Bool}, Vector{Bool}, Vector{Vector{Vector{Int64}}}, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.inter_component_energy","text":"inter_component_energy(lattice1::Vector{Bool}, lattice2::Vector{Bool}, lattice_neighbors::Vector{Vector{Vector{Int64}}}, h::GenericLatticeHamiltonian{N,U})\n\nCompute the interaction energy between two lattice configurations using the Hamiltonian parameters.\n\nArguments\n\nlattice1::Vector{Bool}: The first lattice configuration.\nlattice2::Vector{Bool}: The second lattice configuration.\nlattice_neighbors::Vector{Vector{Vector{Int64}}}: The lattice neighbor list.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::U: The interaction energy between the two lattice configurations.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Tuple{AtomsBase.AbstractSystem, LJParameters, Vector{Int64}, Vector{Bool}}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, lj::LJParameters, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy from interactions between free-free and free-frozen particles using the Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nlj::LJParameters: The Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Tuple{AtomsBase.AbstractSystem, LJParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, lj::LJParameters)\n\nCalculate the energy from interactions between particles using the Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Tuple{SLattice, LatticeGasHamiltonian}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::SLattice, h::LatticeGasHamiltonian)\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::SLattice: The lattice configuration.\nh::LatticeGasHamiltonian: The lattice-gas Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeLJParameters{C}, Vector{Int64}, Vector{Bool}}} where C","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, ljs::CompositeLJParameters{C}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy from interactions between free-free and free-frozen particles using the Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nljs::CompositeLJParameters{C}: The composite Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{U}, Tuple{N}, Tuple{G}, Tuple{C}, Tuple{MLattice{C, G}, MLatticeHamiltonian{C, N, U}}} where {C, G, N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::MLattice{C,G}, h::MLatticeHamiltonian{C,N,U})\n\nCompute the interaction energy of a multi-component lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::MLattice{C,G}: The multi-component lattice configuration.\nh::MLatticeHamiltonian{C,N,U}: The multi-component lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{U}, Tuple{N}, Tuple{SLattice, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::SLattice, h::GenericLatticeHamiltonian{N})\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::SLattice: The lattice configuration.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.intra_component_energy-Tuple{AtomsBase.AbstractSystem, LJParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.intra_component_energy","text":"intra_component_energy(at::AbstractSystem, lj::LJParameters)\n\nCompute the energy within a component of a system using the Lennard-Jones potential.\n\nArguments\n\nat::AbstractSystem: The component of the system.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy: The energy within the component.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.lattice_interaction_energy-Union{Tuple{U}, Tuple{N}, Tuple{Vector{Bool}, Vector{Vector{Vector{Int64}}}, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.lattice_interaction_energy","text":"lattice_interaction_energy(lattice_occupations::Vector{Bool}, lattice_neighbors::Vector{Vector{Vector{Int64}}}, h::GenericLatticeHamiltonian{N,U})\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice_occupations::Vector{Bool}: The lattice occupation configuration.\nlattice_neighbors::Vector{Vector{Vector{Int64}}}: The lattice neighbor list.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::U: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.pbc_dist-Union{Tuple{T}, Tuple{Union{Vector{T}, StaticArraysCore.SVector{T}}, Union{Vector{T}, StaticArraysCore.SVector{T}}, AtomsBase.AbstractSystem}} where T","page":"EnergyEval","title":"FreeBird.EnergyEval.pbc_dist","text":"pbc_dist(pos1, pos2, at)\n\nCompute the distance between two positions considering periodic boundary conditions. Currently only works for orthorhombic lattices.\n\nArguments\n\npos1::Union{SVector{T},Vector{T}}: The first position.\npos2::Union{SVector{T},Vector{T}}: The second position.\nat::AbstractSystem: The abstract system containing boundary conditions and bounding box.\n\nReturns\n\nd::Float64: The distance between pos1 and pos2 considering periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.sort_components_by_atomic_number-Tuple{AtomsBase.AbstractSystem}","page":"EnergyEval","title":"FreeBird.EnergyEval.sort_components_by_atomic_number","text":"sort_components_by_atomic_number(at::AbstractSystem; merge_same_species=true)\n\nSorts the components of an AbstractSystem object at by their atomic number.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem object.\n\nKeyword Arguments\n\nmerge_same_species::Bool=true: Whether to merge components with the same species.\n\nReturns\n\nlist_num_par::Vector{Int64}: A vector containing the number of each component species.\nnew_list::FastSystem: A new FastSystem object with the sorted components.\n\nThe function first extracts the atomic numbers of the components in at. If merge_same_species is true, it sorts the unique species and counts the number of each species. If merge_same_species is false, it creates a list of species and their counts. It then sorts the species and counts by atomic number. Finally, it constructs a new FastSystem object with the sorted components and returns the list of species counts and the new FastSystem object.\n\nExamples\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"√Ö\"\n\n        .--------------.  \n       /|     Cl    H  |  \n      / |      Fe      |  \n     /  |  Au     FeH  |  \n    *   |   FeH  ACl   |  \n    |   |    Cl     Au |  \n    |   |            O |  \n    |   .--Fe----------.  \n    |  /H  Cl         /   \n    | /          Au  /    \n    |/Cl          Cl/     \n    *--------------*      \n\n\njulia> sort_components_by_atomic_number(at; merge_same_species=false)\n([2, 3, 1, 6, 4, 5], FastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\"))\n\njulia> sort_components_by_atomic_number(at)\n([5, 1, 6, 4, 5], FastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\"))\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.split_components-Tuple{AtomsBase.AbstractSystem, Vector{Int64}}","page":"EnergyEval","title":"FreeBird.EnergyEval.split_components","text":"split_components(at::AbstractSystem, list_num_par::Vector{Int})\n\nSplit the system into components based on the number of particles in each component.\n\nArguments\n\nat::AbstractSystem: The system to split.\nlist_num_par::Vector{Int}: The number of particles in each component.\n\nReturns\n\ncomponents: An array of FastSystem objects representing the components of the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.split_components_by_chemical_species-Tuple{AtomsBase.AbstractSystem}","page":"EnergyEval","title":"FreeBird.EnergyEval.split_components_by_chemical_species","text":"split_components_by_chemical_species(at::AbstractSystem)\n\nSplit an AbstractSystem into multiple components based on the chemical species.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem to be split.\n\nReturns\n\nAn array of FastSystem objects, each representing a component of the input system.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"√Ö\"\n\n        .--------------.  \n       /Au      Cl     |  \n      / |HAu Fe        |  \n     /  |     Cl Cl Cl |  \n    *   |Cle           |  \n    |   | Cl      H    |  \n    |   |      OAuH    |  \n    |FeFe-----------H--.  \n    |  /          Au  /   \n    | /      Au      /    \n    |/              /     \n    *--------------*      \n\n\njulia> split_components_by_chemical_species(at)\n5-element Vector{FastSystem}:\n FastSystem(H‚ÇÖ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(Cl‚ÇÜ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(Fe‚ÇÑ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(Au‚ÇÖ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#AbstractLiveSets","page":"AbstractLiveSets","title":"AbstractLiveSets","text":"","category":"section"},{"location":"AbstractLiveSets/#Functions","page":"AbstractLiveSets","title":"Functions","text":"","category":"section"},{"location":"AbstractLiveSets/","page":"AbstractLiveSets","title":"AbstractLiveSets","text":"Modules = [AbstractLiveSets]","category":"page"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LJAtomWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LJAtomWalkers","text":"struct LJAtomWalkers <: AtomWalkers\n\nThe LJAtomWalkers struct represents a collection of atom walkers that interact with each other using the Lennard-Jones potential.\n\nFields\n\nwalkers::Vector{AtomWalker{C}}: A vector of atom walkers, where C is the number of components.\nlj_potential::LennardJonesParametersSets: The Lennard-Jones potential parameters. See LennardJonesParametersSets.\n\nConstructor\n\nLJAtomWalkers(walkers::Vector{AtomWalker{C}}, lj_potential::LennardJonesParametersSets; assign_energy=true):    Constructs a new LJAtomWalkers object with the given walkers and Lennard-Jones potential parameters. If assign_energy=true,   the energy of each walker is assigned using the Lennard-Jones potential.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LatticeGasWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LatticeGasWalkers","text":"struct LatticeGasWalkers <: LatticeWalkers\n\nThe LatticeGasWalkers struct represents a collection of lattice walkers for a lattice gas system. It is a subtype of LatticeWalkers.\n\nFields\n\nwalkers::Vector{LatticeWalker{C}}: A vector of lattice walkers.\nhamiltonian::LatticeGasHamiltonian: The lattice gas Hamiltonian associated with the walkers.\n\nConstructors\n\nLatticeGasWalkers(walkers::Vector{LatticeWalker{C}}, hamiltonian::LatticeGasHamiltonian; assign_energy=true, perturb_energy::Float64=0.0): Constructs a new LatticeGasWalkers object with the given walkers and Hamiltonian. If assign_energy is true, the energy of each walker is assigned using the provided Hamiltonian. The optional perturb_energy parameter can be used to add a small perturbation to the assigned energy.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Tuple{AtomWalker, LennardJonesParametersSets}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::AtomWalker, lj::LennardJonesParametersSets)\n\nAssigns the energy to the given walker using the Lennard-Jones parameters lj.\n\nArguments\n\nwalker::AtomWalker: The walker object to assign the energy to.\nlj::LennardJonesParametersSets: The Lennard-Jones parameters.\n\nReturns\n\nwalker::AtomWalker: The walker object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian}} where C","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::LatticeWalker{C}, hamiltonian::LatticeGasHamiltonian; perturb_energy::Float64=0.0)\n\nAssigns energy to the given walker based on the hamiltonian. If perturb_energy is non-zero, a small random perturbation is added to the energy.\n\nArguments\n\nwalker::LatticeWalker{C}: The walker to assign energy to.\nhamiltonian::LatticeGasHamiltonian: The Hamiltonian used to calculate the energy.\nperturb_energy::Float64=0.0: The amount of random perturbation to add to the energy.\n\nReturns\n\nwalker::LatticeWalker{C}: The walker with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"Potentials/#Potentials","page":"Potentials","title":"Potentials","text":"","category":"section"},{"location":"Potentials/#Functions","page":"Potentials","title":"Functions","text":"","category":"section"},{"location":"Potentials/","page":"Potentials","title":"Potentials","text":"Modules = [Potentials]","category":"page"},{"location":"Potentials/#FreeBird.Potentials","page":"Potentials","title":"FreeBird.Potentials","text":"Module for defining and implementing potentials.\n\n\n\n\n\n","category":"module"},{"location":"Potentials/#FreeBird.Potentials.CompositeLJParameters","page":"Potentials","title":"FreeBird.Potentials.CompositeLJParameters","text":"struct CompositeLJParameters{C} <: LennardJonesParametersSets\n\nCompositeLJParameters is a struct that represents a set of composite Lennard-Jones parameters.\n\nFields\n\nlj_param_sets::Matrix{LJParameters}: A matrix of LJParameters representing the LJ parameter sets.\n\nType Parameters\n\nC::Int: The number of composite parameter sets.\n\n\n\n\n\n","category":"type"},{"location":"Potentials/#FreeBird.Potentials.CompositeLJParameters-Tuple{Int64, Vector{LJParameters}}","page":"Potentials","title":"FreeBird.Potentials.CompositeLJParameters","text":"CompositeLJParameters(c::Int, ljs::Vector{LJParameters})\n\nConstruct a CompositeLJParameters object from a vector of LJParameters.\n\nArguments\n\nc::Int: The number of components.\nljs::Vector{LJParameters}: A vector of LJParameters. \n\nThe number of elements in the vector must be equal to c^2 or c*(c+1)/2.  The former case is for a full flattened matrix of LJParameters, useful when  the interactions are asymmetric, i.e., epsilon_ij != epsilon_ji. The latter case is for symmetric interactions, i.e., epsilon_ij = epsilon_ji, hence only the upper triangular part of the matrix is needed.\n\nReturns\n\nA CompositeLJParameters object.\n\nExample\n\njulia> ljs = [LJParameters(epsilon=e) for e in [11, 12, 13, 22, 23, 33]]\n6-element Vector{LJParameters}:\n LJParameters(11.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n LJParameters(12.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n LJParameters(13.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n LJParameters(22.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n LJParameters(23.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n LJParameters(33.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n\njulia> ljp = CompositeLJParameters(3,ljs)\nCompositeLJParameters{3}(lj_param_sets::3x3 Matrix{LJParameters}):\n    lj_param_sets[1, 1] : LJParameters(11.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[1, 2] : LJParameters(12.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[1, 3] : LJParameters(13.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[2, 1] : LJParameters(12.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[2, 2] : LJParameters(22.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[2, 3] : LJParameters(23.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[3, 1] : LJParameters(13.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[3, 2] : LJParameters(23.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n    lj_param_sets[3, 3] : LJParameters(33.0 eV, 1.0 √Ö, Inf, 0.0 eV)\n\n\n\n\n\n","category":"method"},{"location":"Potentials/#FreeBird.Potentials.LJParameters","page":"Potentials","title":"FreeBird.Potentials.LJParameters","text":"struct LJParameters\n\nThe LJParameters struct represents the parameters for the Lennard-Jones potential.\n\nFields\n\nepsilon::typeof(1.0u\"eV\"): The energy scale of the potential.\nsigma::typeof(1.0u\"√Ö\"): The length scale of the potential.\ncutoff::Float64: The cutoff distance for the potential, in units of sigma.\nshift::typeof(0.0u\"eV\"): The energy shift applied to the potential, calculated at the cutoff distance.\n\n\n\n\n\n","category":"type"},{"location":"Potentials/#FreeBird.Potentials.LJParameters-Tuple{}","page":"Potentials","title":"FreeBird.Potentials.LJParameters","text":"LJParameters(;epsilon=1.0, sigma=1.0, cutoff=Inf, shift=true)\n\nA constructor for the LJParameters struct with default values for the  Lennard-Jones potential with no cutoff or shift. The shift parameter can be  specified as a boolean, if true, the shift energy is calculated automatically  at the cutoff distance; or as a typeof(0.0u\"eV\"), in which case the value is used directly.\n\nExample\n\njulia> lj = LJParameters(epsilon=0.1,sigma=2.5,cutoff=3.5,shift=false)\nLJParameters(0.1 eV, 2.5 √Ö, 3.5, 0.0 eV)\n\njulia> lj = LJParameters(sigma=2.5)\nLJParameters(1.0 eV, 2.5 √Ö, Inf, 0.0 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=5.0)\nLJParameters(1.0 eV, 1.0 √Ö, 3.5, 5.0 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=true)\nLJParameters(1.0 eV, 1.0 √Ö, 3.5, -0.0021747803916549904 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=false)\nLJParameters(1.0 eV, 1.0 √Ö, 3.5, 0.0 eV)\n\n\n\n\n\n\n","category":"method"},{"location":"Potentials/#FreeBird.Potentials.lj_energy-Tuple{Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}, LJParameters}","page":"Potentials","title":"FreeBird.Potentials.lj_energy","text":"lj_energy(r::typeof(1.0u\"√Ö\"), lj::LJParameters)\n\nCompute the Lennard-Jones energy between two particles at a given distance.\n\nArguments\n\nr::typeof(1.0u\"√Ö\"): The distance between the particles.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\n0.0u\"eV\" if the distance is greater than the cutoff distance.\nThe Lennard-Jones energy minus the shift otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Potentials/#FreeBird.Potentials.lj_energy-Tuple{Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}}","page":"Potentials","title":"FreeBird.Potentials.lj_energy","text":"lj_energy(epsilon::typeof(1.0u\"eV\"), sigma::typeof(1.0u\"√Ö\"), r::typeof(1.0u\"√Ö\"))\n\nCompute the Lennard-Jones potential energy between two particles.\n\nThe Lennard-Jones potential energy is given by the equation:\n\nV(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right\n\nwhere epsilon is the energy scale, sigma is the distance scale, and r is the distance between the particles.\n\nArguments\n\nepsilon::typeof(1.0u\"eV\"): The energy scale of the potential.\nsigma::typeof(1.0u\"√Ö\"): The distance scale of the potential.\nr::typeof(1.0u\"√Ö\"): The distance between the particles.\n\nReturns\n\nThe Lennard-Jones potential energy between the particles.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#Monte-Carlo-Moves","page":"MonteCarloMoves","title":"Monte Carlo Moves","text":"","category":"section"},{"location":"MonteCarloMoves/#Functions","page":"MonteCarloMoves","title":"Functions","text":"","category":"section"},{"location":"MonteCarloMoves/","page":"MonteCarloMoves","title":"MonteCarloMoves","text":"Modules = [MonteCarloMoves]","category":"page"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves","text":"Module containing functions for performing Monte Carlo moves on atomic/molecular systems.\n\n\n\n\n\n","category":"module"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_new_sample!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_new_sample!","text":"MC_new_sample!(lattice::LatticeWalker, h::ClassicalHamiltonian, emax::Float64; energy_perturb::Float64=0.0)\n\nGenerate a new sample for the lattice system.\n\nArguments\n\nlattice::LatticeWalker: The walker to generate a new sample for.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_nve_walk!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParametersSets, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_nve_walk!","text":"MC_nve_walk!(\n    n_steps::Int, \n    at::AtomWalker{C}, \n    lj::LennardJonesParametersSets, \n    step_size::Float64; \n    e_demon_tolerance=1e-9u\"eV\",\n    demon_energy_threshold=Inf*u\"eV\",\n    demon_gain_threshold=Inf*u\"eV\",\n    max_add_steps::Int=1_000_000\n)\n\nPerform a NVE walk using the demon algorithm. The demon algorithm is used to maintain the energy (E) of the system.\n\nArguments\n\nn_steps::Int: The number of demon walks to perform.\nat::AtomWalker: The walker to perform the demon walk on.\nlj::LJParameters: The Lennard-Jones parameters for the system.\nstep_size::Float64: The step size for the demon walk.\n\nOptional Arguments\n\ne_demon_tolerance=1e-9u\"eV\": The energy tolerance for the demon, below which the demon walk is considered successful,    i.e., the NVE condition is satisfied.\ndemon_energy_threshold=Inf*u\"eV\": The maximum energy allowed for the demon to have.\ndemon_gain_threshold=Inf*u\"eV\": The energy gain threshold for the demon during each move.\nmax_add_steps::Int=1_000_000: The maximum number of additional demon walks if the demon energy is above the tolerance.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_ratio::Float64: The acceptance ratio of the demon walk (excluding additional demon walks).\nat_final::AtomWalker: The final walker after the demon walks.\ndemon_energies::Array{Float64}: The energies of the demon at each step.\ntemp_estimate::Float64: The estimated temperature of the system.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Tuple{Int64, LatticeWalker{1}, ClassicalHamiltonian, Float64}","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, lattice::LatticeWalker, h::LatticeGasHamiltonian, emax::Float64; energy_perturb::Float64=0.0)\n\nPerform a Monte Carlo random walk on the lattice system.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nlattice::LatticeWalker: The walker to perform the random walk on.\nh::LatticeGasHamiltonian: The lattice gas Hamiltonian.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParametersSets, Float64, Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, at::AtomWalker, lj::LJParameters, step_size::Float64, emax::typeof(0.0u\"eV\"))\n\nPerform a Monte Carlo random walk on the atomic/molecular system.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\nlj::LennardJonesParametersSets: The Lennard-Jones potential parameters.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.additional_demon_walk!-Union{Tuple{C}, Tuple{Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}, AtomWalker{C}, LennardJonesParametersSets, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.additional_demon_walk!","text":"additional_demon_walk!(e_demon::typeof(0.0u\"eV\"), at::AtomWalker, lj::LJParameters, step_size::Float64;\n                      e_demon_tolerance=1e-9u\"eV\", max_add_steps::Int=1_000_000)\n\nPerforms additional demon walk steps until the demon energy e_demon is below the tolerance e_demon_tolerance or the maximum number of additional steps max_add_steps is reached.\n\nArguments\n\ne_demon::typeof(0.0u\"eV\"): The initial demon energy.\nat::AtomWalker{C}: The walker that the demon walk is performed on.\nlj::LennardJonesParametersSets: The LJ parameters.\nstep_size::Float64: The step size for the demon walk.\ne_demon_tolerance=1e-9u\"eV\": The tolerance for the demon energy.\nmax_add_steps::Int=1_000_000: The maximum number of additional steps.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted after the additional demon walk.\naccept_rate::Float64: The acceptance rate of the additional demon walk.\nat::AtomWalker: The updated walker.\ne_demon::typeof(0.0u\"eV\"): The final demon energy.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.free_par_index-Union{Tuple{AtomWalker{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.free_par_index","text":"free_par_index(at::AtomWalker{C}) where C\n\nGet the indices of the free particles in the AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!","text":"generate_random_new_lattice_sample!(lattice::MLattice{C}) where C\n\nGenerate a new random sample for the multi-component lattice system.\n\nArguments\n\nlattice::MLattice{C}: The lattice system to generate a new sample for.\n\nReturns\n\nlattice::MLattice{C}: The updated lattice system.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.mean_sq_displacement-Union{Tuple{C}, Tuple{AtomWalker{C}, AtomWalker{C}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.mean_sq_displacement","text":"mean_sq_displacement(at::AtomWalker, at_orig::AtomWalker)\n\nCalculate the mean squared displacement before and after random walk(s). Note that due to the current implementation of the periodic boundary wrap, this function is not appropriate to use for calculating mean displacements in a propagation.\n\nArguments\n\nat::AtomWalker{C}: The current AtomWalker after the random walk.\nat_orig::AtomWalker{C}: The original AtomWalker before the random walk.\n\nReturns\n\ndistsq::typeof(0.0u\"√Ö\"^2): The mean squared displacement of all free particles.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.periodic_boundary_wrap!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, AtomsBase.AbstractSystem}} where T","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.periodic_boundary_wrap!","text":"periodic_boundary_wrap!(pos::SVector{3,T}, system::AbstractSystem) where T\n\nWrap the position vector pos according to the periodic boundary conditions of the system. If the boundary condition is Periodic(), the position is wrapped using the modulo operator. If the boundary condition is DirichletZero(), the position is wrapped by reflecting the position vector across the boundary.\n\nArguments\n\npos::SVector{3,T}: The position vector to be wrapped.\nsystem::AbstractSystem: The system containing the periodic boundary conditions.\n\nReturns\n\nThe wrapped position vector.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.single_atom_demon_walk!-Union{Tuple{C}, Tuple{AtomWalker{C}, LennardJonesParametersSets, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.single_atom_demon_walk!","text":"single_atom_demon_walk!(at::AtomWalker{C}, \n                        lj::LennardJonesParametersSets, \n                        step_size::Float64;\n                        e_demon=0.0u\"eV\",\n                        demon_energy_threshold=Inf*u\"eV\",\n                        demon_gain_threshold=Inf*u\"eV\")\n\nPerform a single atom demon walk.\n\nArguments:\n\nat::AtomWalker: The walker to perform the demon walk on.\nlj::LJParameters: The LJ parameters.\nstep_size::Float64: The step size for the random walk.\n\nKeyword Arguments:\n\ne_demon=0.0u\"eV\": The energy of the demon.\ndemon_energy_threshold=Inf*u\"eV\": The energy threshold for the demon.\ndemon_gain_threshold=Inf*u\"eV\": The energy gain threshold for the demon during each move.\n\nReturns:\n\naccept::Bool: Whether the move is accepted or rejected.\nat::AtomWalker: The updated atom walker object.\ne_demon::Float64: The updated energy of the demon.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.single_atom_random_walk!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Float64}} where T","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.single_atom_random_walk!","text":"single_atom_random_walk!(pos::SVector{3,T}, step_size::Float64) where T\n\nPerform a single atom random walk by updating the position pos in each direction by a random amount. The step_size determines the maximum distance the atom can move in any direction.\n\nArguments\n\npos::SVector{3,T}: The current position of the atom as a 3D vector.\nstep_size::Float64: The maximum distance the atom can move in any direction.\n\nReturns\n\npos: The updated position of the atom.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#Analysis-Tools","page":"AnalysisTools","title":"Analysis Tools","text":"","category":"section"},{"location":"AnalysisTools/#Functions","page":"AnalysisTools","title":"Functions","text":"","category":"section"},{"location":"AnalysisTools/","page":"AnalysisTools","title":"AnalysisTools","text":"Modules = [AnalysisTools]","category":"page"},{"location":"AnalysisTools/#FreeBird.AnalysisTools","page":"AnalysisTools","title":"FreeBird.AnalysisTools","text":"AnalysisTools\n\nModule for analyzing the output of the sampling.\n\n\n\n\n\n","category":"module"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{DataFrames.DataFrame, Vector{Float64}, Int64, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(df::DataFrame, Œ≤s::Vector{Float64}, dof::Int, n_walkers::Int)\n\nCalculates the constant-volume heat capacity at constant volume for the given DataFrame, inverse temperatures, degrees of freedom, and number of walkers. The heat capacity is defined as:\n\nC_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)\n\nwhere mathrmdof is the degrees of freedom, k_B is the Boltzmann constant (in units of eV/K), beta is the inverse temperature, omega_i is the i-th omega factor, E_i is the i-th energy, Z(beta) is the partition function, and U(beta) is the internal energy.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the output data.\nŒ≤s::Vector{Float64}: The inverse temperatures.\ndof::Int: The degrees of freedom, equals to the number of dimensions times the number of particles.\nn_walkers::Int: The number of walkers.\n\nReturns\n\nA vector of constant-volume heat capacities.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{Float64, Vector{Float64}, Vector{Float64}, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(Œ≤::Float64, omega_i::Vector{Float64}, Ei::Vector{Float64}, dof::Int)\n\nCalculates the constant-volume heat capacity for the given beta, omega factors, energies, and degrees of freedom. The heat capacity is defined as:\n\nC_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)\n\nwhere mathrmdof is the degrees of freedom, k_B is the Boltzmann constant (in units of eV/K), beta is the inverse temperature,  omega_i is the i-th omega factor, E_i is the i-th energy, Z(beta) is the partition function, and U(beta) is the internal energy.\n\nArguments\n\nŒ≤::Float64: The inverse temperature.\nœâi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies in eV.\ndof::Int: The degrees of freedom, equals to the number of dimensions times the number of particles.\n\nReturns\n\nThe constant-volume heat capacity.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.internal_energy-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.internal_energy","text":"internal_energy(Œ≤::Float64, œâi::Vector{Float64}, ei::Vector{Float64})\n\nCalculates the internal energy from the partition function for the given beta, omega factors, and energies. The internal energy is defined as:\n\nU(beta) = fracsum_i omega_i E_i exp(-E_i beta)sum_i omega_i exp(-E_i beta)\n\nwhere omega_i is the i-th omega factor, E_i is the i-th energy, and beta is the inverse temperature.\n\nArguments\n\nŒ≤::Float64: The inverse temperature.\nœâi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies in eV.\n\nReturns\n\nThe internal energy.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.partition_function-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.partition_function","text":"partition_function(Œ≤::Float64, œâi::Vector{Float64}, Ei::Vector{Float64})\n\nCalculates the partition function for the given beta, omega factors, and energies. The partition function is defined as:\n\nZ(beta) = sum_i omega_i exp(-E_i beta)\n\nwhere omega_i is the i-th omega factor, E_i is the i-th energy, and beta is the inverse temperature.\n\nArguments\n\nŒ≤::Float64: The inverse temperature.\nœâi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies.\n\nReturns\n\nThe partition function.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.read_output-Tuple{String}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.read_output","text":"read_output(filename::String)\n\nReads the output file and returns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.œâ·µ¢-Tuple{Vector{Int64}, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.œâ·µ¢","text":"œâ·µ¢(iters::Vector{Int}, n_walkers::Int)\n\nCalculates the omega factors for the given number of iterations and walkers. The omega factors account for the fractions of phase-space volume sampled during each nested sampling iteration, defined as:\n\nomega_i = frac1N+1 left(fracNN+1right)^i\n\nwhere N is the number of walkers and i is the iteration number.\n\nArguments\n\niters::Vector{Int}: The iteration numbers.\nn_walkers::Int: The number of walkers.\n\nReturns\n\nA vector of omega factors.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#AbstractWalkers","page":"AbstractWalkers","title":"AbstractWalkers","text":"","category":"section"},{"location":"AbstractWalkers/#Functions","page":"AbstractWalkers","title":"Functions","text":"","category":"section"},{"location":"AbstractWalkers/","page":"AbstractWalkers","title":"AbstractWalkers","text":"Modules = [AbstractWalkers]","category":"page"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers","text":"Module containing abstract definitions for walkers.\n\n\n\n\n\n","category":"module"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.AtomWalker","text":"mutable struct AtomWalker\n\nThe AtomWalker struct represents a walker composed of atoms/molecules.\n\nFields\n\nconfiguration::FastSystem: The configuration of the walker.\nenergy::typeof(0.0u\"eV\"): The energy of the walker.\niter::Int64: The current iteration number of the walker.\nlist_num_par::Vector{Int64}: The list of the number of particles for each component.\nfrozen::Vector{Bool}: A boolean vector indicating whether each component is frozen or not.\nenergy_frozen_part::typeof(0.0u\"eV\"): The energy of the frozen particles in the walker, serves as a constant energy offset   to the interacting part of the system.\n\nConstructor\n\nAtomWalker(configuration::FastSystem; energy=0.0u\"eV\", iter=0, list_num_par=zeros(Int,C), frozen=zeros(Bool,C), energy_frozen_part=0.0u\"eV\"):    Constructs a new AtomWalker object with the given configuration and optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker-Tuple{AtomsBase.FastSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.AtomWalker","text":"AtomWalker(configuration::FastSystem; freeze_species::Vector{Symbol}=Symbol[], merge_same_species=true)\n\nConstructs an AtomWalker object with the given configuration.\n\nArguments\n\nconfiguration::FastSystem: The configuration of the walker.\nfreeze_species::Vector{Symbol}: A vector of species to freeze.\nmerge_same_species::Bool: A boolean indicating whether to merge the same species into one component.\n\nReturns\n\nAtomWalker{C}: The constructed AtomWalker object.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"√Ö\"\n\n        .--------------.  \n       /|Fel           |  \n      / H   H   Cl     |  \n     /  Hu   O         |  \n    *   |       Au   Fe|  \n    |   |FeCl        Fe|  \n    |   |        Au    |  \n    |   .---------Au---.  \n    |  /           H  /   \n    | Au Cl          /    \n    |/              /     \n    *--------------*      \n\njulia> AtomWalker(at;freeze_species=[:H],merge_same_species=false)\nAtomWalker{6}(FastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\"), 0.0 eV, 0, [2, 3, 1, 6, 4, 5], Bool[1, 1, 0, 0, 0, 0], 0.0 eV)\n\njulia> AtomWalker(at;freeze_species=[:H],merge_same_species=true)\nAtomWalker{5}(FastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\"), 0.0 eV, 0, [5, 1, 6, 4, 5], Bool[1, 0, 0, 0, 0], 0.0 eV)\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.LatticeGeometry","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.LatticeGeometry","text":"abstract type LatticeGeometry\n\nThe LatticeGeometry abstract type represents the geometry of a lattice. It has the following subtypes:\n\nSquareLattice: A square lattice.\nTriangularLattice: A triangular lattice.\nGenericLattice: A generic lattice. Currently used for non-square and non-triangular lattices.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.LatticeWalker","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.LatticeWalker","text":"mutable struct LatticeWalker\n\nThe LatticeWalker struct represents a walker on a 3D lattice.\n\nFields\n\nconfiguration::AbstractLattice: The configuration of the walker.\nenergy::Float64: The energy of the walker.\niter::Int64: The current iteration number of the walker.\n\nConstructor\n\nLatticeWalker(configuration::AbstractLattice; energy=0.0, iter=0)\n\nCreate a new LatticeWalker with the given configuration and optional energy and iteration number.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.MLattice","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.MLattice","text":"mutable struct MLattice{C,G}\n\nA mutable struct representing a lattice with the following fields:\n\nlattice_vectors::Matrix{Float64}: The lattice vectors defining the unit cell.\npositions::Matrix{Float64}: The positions of the lattice points.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis vectors within the unit cell.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\nperiodicity::Tuple{Bool, Bool, Bool}: The periodicity in each dimension.\ncomponents::Vector{Vector{Bool}}: The components of the lattice.\nneighbors::Vector{Vector{Vector{Int}}}: The neighbors of each lattice point.\nadsorptions::Vector{Bool}: The adsorption sites on the lattice.\n\nInner Constructor\n\nMLattice{C,G}(\n    lattice_vectors::Matrix{Float64},\n    basis::Vector{Tuple{Float64, Float64, Float64}},\n    supercell_dimensions::Tuple{Int64, Int64, Int64},\n    periodicity::Tuple{Bool, Bool, Bool},\n    components::Vector{Vector{Bool}},\n    adsorptions::Vector{Bool},\n    cutoff_radii::Vector{Float64},\n) where {C,G}\n\nCreates an MLattice instance with the specified parameters. The constructor performs the following steps:\n\nValidates that the number of components matches the expected value C.\nComputes the positions of the lattice points using lattice_positions.\nComputes the supercell lattice vectors.\nComputes the neighbors of each lattice point using compute_neighbors.\n\nThrows an ArgumentError if the number of components does not match C.\n\nOuter Constructors\n\nMLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,\n                           basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],\n                           supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),\n                           periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n                           cutoff_radii::Vector{Float64}=[1.1, 1.5],\n                           components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n                           adsorptions::Union{Vector{Int},Symbol}=:full)\n\nMLattice{C,TriangularLattice}(; lattice_constant::Float64=1.0,\n                              basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0),(1/2, sqrt(3)/2, 0.0)],\n                              supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 2, 1),\n                              periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n                              cutoff_radii::Vector{Float64}=[1.1, 1.5],\n                              components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n                              adsorptions::Union{Vector{Int},Symbol}=:full)\n\nConstructs a square/triangular lattice with the specified parameters. The components and adsorptions arguments can be a vector of integers specifying the indices of the occupied sites, or a symbol. If components is :equal, the lattice is divided into C equal components when possible, or  nearest to equal components otherwise. If adsorptions is :full, all sites are classified as adsorption sites.\n\nReturns\n\nMLattice{C,G}: A square/triangular lattice object with C components.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.check_num_components-Tuple{Int64, Vector{Int64}, Vector{Bool}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.check_num_components","text":"check_num_components(C::Int, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCheck that the number of components matches the length of the list of number of particles and frozen particles.\n\nArguments\n\nC::Int: The number of components.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.custom_sort-Tuple{Vector{Int64}, Int64}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.custom_sort","text":"custom_sort(arr::Vector{Int}, period::Int)\n\nSorts [1,2,3,4,5,6,7,8] into [1,3,5,7,2,4,6,8] for period = 2. Useful for printing triangular lattices.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.lattice_positions-Tuple{Matrix{Float64}, Vector{Tuple{Float64, Float64, Float64}}, Tuple{Int64, Int64, Int64}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.lattice_positions","text":"latticepositions(latticevectors::Matrix{Float64}, basis::Vector{Tuple{Float64, Float64, Float64}}, supercell_dimensions::Tuple{Int64, Int64, Int64})\n\nCompute the positions of atoms in a 3D lattice.\n\nArguments\n\nlattice_vectors::Matrix{Float64}: The lattice vectors of the system.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis of the system.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\n\nReturns\n\npositions::Matrix{Float64}: The positions of the atoms in the supercell.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.merge_components-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.merge_components","text":"merge_components(lattice::MLattice{C}) where C\n\nMerges the boolvec of components into a single vector of integers, where each integer represents the component number.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.mlattice_setup-Tuple{Int64, Vector{Tuple{Float64, Float64, Float64}}, Tuple{Int64, Int64, Int64}, Union{Vector{Vector{Bool}}, Vector{Vector{Int64}}, Symbol}, Union{Vector{Bool}, Vector{Int64}, Symbol}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.mlattice_setup","text":"mlattice_setup(C::Int, \n                 basis::Vector{Tuple{Float64, Float64, Float64}},\n                 supercell_dimensions::Tuple{Int64, Int64, Int64},\n                 components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol},\n                 adsorptions::Union{Vector{Int}, Vector{Bool}, Symbol})\n\nSetup the components and adsorptions for a lattice.\n\nArguments\n\nC::Int: The number of components.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis of the lattice.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\ncomponents::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}: The components of the lattice.\nadsorptions::Union{Vector{Int}, Vector{Bool}, Symbol}: The adsorption sites on the lattice.\n\nReturns\n\nlattice_comp::Vector{Vector{Bool}}: The components of the lattice.\nlattice_adsorptions::Vector{Bool}: The adsorption sites on the lattice.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.num_sites-Tuple{AbstractLattice}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.num_sites","text":"num_sites(lattice::AbstractLattice)\n\nReturns the total number of sites in a lattice given a AbstractLattice object. Returns the total number of sites.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.occupied_site_count-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.occupied_site_count","text":"occupied_site_count(MLattice::MLattice{C})\n\nReturns the number of occupied sites in each component of a lattice in an array.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.sort_components_by_atomic_number-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.sort_components_by_atomic_number","text":"sort_components_by_atomic_number(at::AbstractSystem; merge_same_species=true)\n\nSorts the components of an AbstractSystem object at by their atomic number.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem object.\n\nKeyword Arguments\n\nmerge_same_species::Bool=true: Whether to merge components with the same species.\n\nReturns\n\nlist_num_par::Vector{Int64}: A vector containing the number of each component species.\nnew_list::FastSystem: A new FastSystem object with the sorted components.\n\nThe function first extracts the atomic numbers of the components in at. If merge_same_species is true, it sorts the unique species and counts the number of each species. If merge_same_species is false, it creates a list of species and their counts. It then sorts the species and counts by atomic number. Finally, it constructs a new FastSystem object with the sorted components and returns the list of species counts and the new FastSystem object.\n\nExamples\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"√Ö\"\n\n        .--------------.  \n       /|     Cl    H  |  \n      / |      Fe      |  \n     /  |  Au     FeH  |  \n    *   |   FeH  ACl   |  \n    |   |    Cl     Au |  \n    |   |            O |  \n    |   .--Fe----------.  \n    |  /H  Cl         /   \n    | /          Au  /    \n    |/Cl          Cl/     \n    *--------------*      \n\n\njulia> AbstractWalkers.sort_components_by_atomic_number(at; merge_same_species=false)\n([2, 3, 1, 6, 4, 5], FastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\"))\n\njulia> AbstractWalkers.sort_components_by_atomic_number(at)\n([5, 1, 6, 4, 5], FastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\"))\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_components-Tuple{AtomsBase.AbstractSystem, Vector{Int64}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_components","text":"split_components(at::AbstractSystem, list_num_par::Vector{Int})\n\nSplit the system into components based on the number of particles in each component.\n\nArguments\n\nat::AbstractSystem: The system to split.\nlist_num_par::Vector{Int}: The number of particles in each component.\n\nReturns\n\ncomponents: An array of FastSystem objects representing the components of the system.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_components_by_chemical_species-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_components_by_chemical_species","text":"split_components_by_chemical_species(at::AbstractSystem)\n\nSplit an AbstractSystem into multiple components based on the chemical species.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem to be split.\n\nReturns\n\nAn array of FastSystem objects, each representing a component of the input system.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au‚ÇÖCl‚ÇÜFe‚ÇÑH‚ÇÖO, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"√Ö\"\n\n        .--------------.  \n       /Au      Cl     |  \n      / |HAu Fe        |  \n     /  |     Cl Cl Cl |  \n    *   |Cle           |  \n    |   | Cl      H    |  \n    |   |      OAuH    |  \n    |FeFe-----------H--.  \n    |  /          Au  /   \n    | /      Au      /    \n    |/              /     \n    *--------------*      \n\n\njulia> AbstractWalkers.split_components_by_chemical_species(at)\n5-element Vector{FastSystem}:\n FastSystem(H‚ÇÖ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(Cl‚ÇÜ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(Fe‚ÇÑ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n FastSystem(Au‚ÇÖ, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"√Ö\")\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_into_subarrays-Tuple{AbstractVector, Int64}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_into_subarrays","text":"split_into_subarrays(arr::AbstractVector, N::Int)\n\nSplit an array into N subarrays of approximately equal size.\n\nArguments\n\narr::AbstractVector: The array to split.\nN::Int: The number of subarrays to create.\n\nReturns\n\nsubarrays::Vector{Vector{eltype(arr)}}: A vector of subarrays.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.update_walker!-Tuple{AtomWalker, Symbol, Any}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.update_walker!","text":"update_walker!(walker::AtomWalker, key::Symbol, value)\n\nUpdate the properties of an AtomWalker object.\n\nA convenient function that updates the value of a specific property of an AtomWalker object.\n\nArguments\n\nwalker::AtomWalker: The AtomWalker object to be updated.\nkey::Symbol: The key of the property to be updated.\nvalue: The new value of the property.\n\nReturns\n\nwalker::AtomWalker: The updated AtomWalker object.\n\nExample\n\nupdate_walker!(walker, :energy, 10.0u\"eV\")\nupdate_walker!(walker, :iter, 1)\n\n\n\n\n\n","category":"method"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"#FreeBird.jl","page":"FreeBird.jl","title":"FreeBird.jl","text":"","category":"section"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Documentation for FreeBird.jl","category":"page"},{"location":"#Installation","page":"FreeBird.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"FreeBird.jl is a Julia package. Install Julia first following the instructions in the download page.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Once Julia is installed, you can install the FreeBird package from the Julia REPL with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"julia> ] # press the \"]\" key on your keyboard to enter the Pkg manager\n\npkg> add https://github.com/wexlergroup/FreeBird.jl#branch_name","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"To get back to the Julia REPL, press Ctrl+C or backspace (when the REPL cursor is at the beginning of the input).","category":"page"}]
}
