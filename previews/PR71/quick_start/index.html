<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start ¬∑ FreeBird.jl</title><meta name="title" content="Quick Start ¬∑ FreeBird.jl"/><meta property="og:title" content="Quick Start ¬∑ FreeBird.jl"/><meta property="twitter:title" content="Quick Start ¬∑ FreeBird.jl"/><meta name="description" content="Documentation for FreeBird.jl."/><meta property="og:description" content="Documentation for FreeBird.jl."/><meta property="twitter:description" content="Documentation for FreeBird.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FreeBird.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FreeBird.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">FreeBird.jl</a></li><li class="is-active"><a class="tocitem" href>Quick Start</a><ul class="internal"><li><a class="tocitem" href="#Atomistic-walkers-and-nested-sampling"><span>Atomistic walkers and nested sampling</span></a></li><li><a class="tocitem" href="#Lattice-walkers-and-exact-enumeration"><span>Lattice walkers and exact enumeration</span></a></li></ul></li><li><span class="tocitem">Modules and Documentation</span><ul><li><a class="tocitem" href="../AbstractLiveSets/">AbstractLiveSets</a></li><li><a class="tocitem" href="../AbstractWalkers/">AbstractWalkers</a></li><li><a class="tocitem" href="../SamplingSchemes/">SamplingSchemes</a></li><li><a class="tocitem" href="../AbstractPotentials/">AbstractPotentials</a></li><li><a class="tocitem" href="../AbstractHamiltonians/">AbstractHamiltonians</a></li><li><a class="tocitem" href="../EnergyEval/">EnergyEval</a></li><li><a class="tocitem" href="../MonteCarloMoves/">MonteCarloMoves</a></li><li><a class="tocitem" href="../FreeBirdIO/">FreeBirdIO</a></li><li><a class="tocitem" href="../AnalysisTools/">AnalysisTools</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/wexlergroup/FreeBird.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/wexlergroup/FreeBird.jl/blob/main/scripts/quick_start.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-start-guide-to-FreeBird.jl"><a class="docs-heading-anchor" href="#Quick-start-guide-to-FreeBird.jl">Quick start guide to FreeBird.jl</a><a id="Quick-start-guide-to-FreeBird.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start-guide-to-FreeBird.jl" title="Permalink"></a></h1><p>This is a quick start guide to using the FreeBird.jl package. It covers the basic functionalities of the package, such as generating atomistic and lattice walkers, defining a potential energy function or Hamiltonian, and running a sampling simulation. For more detailed information, please refer to the documentation of the package. You can find the runnable version of this script in the <code>scripts</code> directory of the package.</p><h2 id="Atomistic-walkers-and-nested-sampling"><a class="docs-heading-anchor" href="#Atomistic-walkers-and-nested-sampling">Atomistic walkers and nested sampling</a><a id="Atomistic-walkers-and-nested-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Atomistic-walkers-and-nested-sampling" title="Permalink"></a></h2><p>First, let&#39;s load the FreeBird.jl package:</p><pre><code class="language-julia hljs">using FreeBird</code></pre><p>Now, let&#39;s create a few configurations of a simple atomistic system with six particles in a 3D box.</p><pre><code class="language-julia hljs">single_config = generate_initial_configs(1, 562.5, 6; particle_type=:H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{AtomsBase.FastSystem{3, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}, Quantity{Float64, ùêå, Unitful.FreeUnits{(u,), ùêå, nothing}}}}:
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)</code></pre><p>The function above has generated a single configuration, with 562.5 √Ö<span>$^3$</span> volume per particle, and 6 particles of type H. Note that the <code>particle_type</code> keyword argument can be used to specify the type of particle, i.e., chemical element. By default, the type is set to <code>:H</code>. Use <code>?generate_initial_configs</code> in the REPL to see the documentation of the function. Or see <a href="../FreeBirdIO/#FreeBird.FreeBirdIO.generate_initial_configs-Tuple{Int64, Float64, Int64}"><code>generate_initial_configs</code></a>.</p><p>Let&#39;s inspect the generated configuration:</p><pre><code class="language-julia hljs">single_config[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FastSystem(H‚ÇÜ, periodic = FFF):
    bounding_box      : [      15        0        0;
                                0       15        0;
                                0        0       15]u&quot;√Ö&quot;

    AtomView(H,  [  12.589,  14.3106,  6.44841]u&quot;√Ö&quot;)
    AtomView(H,  [ 6.41721, 0.286518,  12.2321]u&quot;√Ö&quot;)
    AtomView(H,  [ 12.2365,   7.8283,  13.3543]u&quot;√Ö&quot;)
    AtomView(H,  [ 3.36242,  14.4352, 0.955306]u&quot;√Ö&quot;)
    AtomView(H,  [ 10.2428,  3.77278,  10.2985]u&quot;√Ö&quot;)
    AtomView(H,  [ 7.90371,  14.6692, 0.843658]u&quot;√Ö&quot;)

             .------------------------------------.  
            /|                                    |  
           / |                                    |  
          /  |                                    |  
         /   |                                    |  
        /    |                                    |  
       /     |                         H          |  
      /      |                                    |  
     /       |                                    |  
    *        |                                    |  
    |        |                                    |  
    |        |                              H     |  
    |        |      H           H                 |  
    |        |                                    |  
    |        |                                    |  
    |        |                                    |  
    |        |                                    |  
    |        |       H          H                 |  
    |        .------------------------------------.  
    |       /                                    /   
    |      /                                    /    
    |     /                                    /     
    |    /                                    /      
    |   /                                    /       
    |  /                                    /        
    | /                                    /         
    |/                                    /          
    *------------------------------------*           
</code></pre><p>It&#39;s of a <code>FastSystem</code> type from <code>AtomsBase</code>. The dimensions of the box are 15 √Ö x 15 √Ö x 15 √Ö, following the volume per particle specified. The positions of the particles are randomly generated within the box.</p><p>Now, let&#39;s generate a few more configurations:</p><pre><code class="language-julia hljs">configs = generate_initial_configs(120, 562.5, 6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">120-element Vector{AtomsBase.FastSystem{3, Quantity{Float64, ùêã, Unitful.FreeUnits{(√Ö,), ùêã, nothing}}, Quantity{Float64, ùêå, Unitful.FreeUnits{(u,), ùêå, nothing}}}}:
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 ‚ãÆ
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
 FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)</code></pre><p>The function above has generated 120 configurations, again, with 562.5 √Ö<span>$^3$</span> volume per particle, and 6 particles of type H. These configurations will be served as the initial walkers for a sampling run, but first, we need to warp them into the <a href="../AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker"><code>AtomWalker</code></a> type defined in FreeBird.jl.</p><pre><code class="language-julia hljs">walkers = AtomWalker.(generate_initial_configs(120, 562.5, 6))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">120-element Vector{AtomWalker{1}}:
 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 ‚ãÆ
 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

 AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.0 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)
</code></pre><p>Let&#39;s inquire the type of the <code>walkers</code> variable:</p><pre><code class="language-julia hljs">walkers |&gt; typeof</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vector{AtomWalker{1}}<span class="sgr90"> (alias for Array{AtomWalker{1}, 1})</span></code></pre><p>The <code>walkers</code> variable is of a <code>Vector{AtomWalker{1}}</code> type, which is a vector of <code>AtomWalker{1}</code> objects. The <code>AtomWalker{1}</code> type is a parametrized type, where the parameter is the number of components in the system. In this case, the system has only one component, consisting of 6 particles of type H.</p><p>To define how these particles interact with each other, we need to create a potential energy function. Let&#39;s use the Lennard-Jones potential:</p><pre><code class="language-julia hljs">lj = LJParameters(epsilon=0.1, sigma=2.5, cutoff=4.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LJParameters(0.1 eV, 2.5 √Ö, 4.0, -9.763240814208984e-5 eV)</code></pre><p>The <a href="../AbstractPotentials/#FreeBird.AbstractPotentials.LJParameters"><code>LJParameters</code></a> type is a struct that holds the parameters of the Lennard-Jones potential. The <code>epsilon</code> and <code>sigma</code> fields are the energy and length scales of the potential, respectively. The <code>cutoff</code> field is the distance at which the potential is truncated. An energy shift is applied to the potential to ensure continuity at the cutoff distance, automatically in this case. See the documentation of the <code>LJParameters</code> type for more information and examples.</p><p>We now can create a so-called <em>liveset</em> that will be used to store the walkers during the simulation. The <code>lj</code> potential will be used to attached and used to calculate the potential energy of the walkers.</p><pre><code class="language-julia hljs">ls = LJAtomWalkers(walkers, lj)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LJAtomWalkers(AtomWalker{1}, LJParameters):
[1] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 9585.06464734629 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[2] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.01954451756598441 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[3] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.0021273769040524187 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[4] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.02417842821703293 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[5] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.034402392638972046 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

‚ãÆ
Omitted 110 walkers
‚ãÆ

[116] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.07423171434947787 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[117] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.019933759790847917 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[118] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.11558453097366296 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[119] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -0.010387240960106736 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[120] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : 0.4940741733062602 eV
    iter               : 0
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

LJParameters(0.1 eV, 2.5 √Ö, 4.0, -9.763240814208984e-5 eV)
</code></pre><p>Here, <code>ls</code> is a <a href="../AbstractLiveSets/#FreeBird.AbstractLiveSets.LJAtomWalkers"><code>LJAtomWalkers</code></a> type, and has the <code>walkers</code> and <code>lj</code> fields attached to it.</p><p>Now, time to set up a simulation. We will be using nested sampling, a Bayesian-inference inspired method, as an example here. First, we need to define the nested sampling parameters:</p><pre><code class="language-julia hljs">ns_params = NestedSamplingParameters(200, 0.1, 0.01, 1e-5, 1.0, 0, 200)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NestedSamplingParameters(200, 0.1, 0.01, 1.0e-5, 1.0, 0, 200)</code></pre><p>The <a href="../SamplingSchemes/#FreeBird.SamplingSchemes.NestedSamplingParameters"><code>NestedSamplingParameters</code></a> type is a struct that holds the parameters of the nested sampling algorithm. The fields are as follows:</p><ul><li><code>mc_steps::Int64</code>: The number of total Monte Carlo moves to perform.</li><li><code>initial_step_size</code>::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.</li><li><code>step_size::Float64</code>: The on-the-fly step size used in the sampling process.</li><li><code>step_size_lo::Float64</code>: The lower bound of the step size.</li><li><code>step_size_up::Float64</code>: The upper bound of the step size.</li><li><code>fail_count::Int64</code>: The number of failed MC moves in a row.</li><li><code>allowed_fail_count::Int64</code>: The maximum number of failed MC moves allowed before resetting the step size.</li></ul><p>Speaking of the Monte Carlo moves, we need to define that too:</p><pre><code class="language-julia hljs">mc = MCRandomWalkClone()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MCRandomWalkClone()</code></pre><p>The <a href="../SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkClone"><code>MCRandomWalkClone</code></a> type is a type of Monte Carlo move that indicates a new walker is created by cloning an existing walker and then decorrelate the positions of the particles.</p><p>We also need to specify how we want to save the data and the output:</p><pre><code class="language-julia hljs">save = SaveEveryN(n_traj=10, n_snap=20_00)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SaveEveryN(&quot;output_df.csv&quot;, &quot;output.traj.extxyz&quot;, &quot;output.ls.extxyz&quot;, 10, 2000)</code></pre><p>The <a href="../FreeBirdIO/#FreeBird.FreeBirdIO.SaveEveryN"><code>SaveEveryN</code></a> type is a struct that holds the parameters of the saving routine.</p><p>Now, we are ready to run the nested sampling simulation:</p><pre><code class="language-julia hljs">energies, liveset, _ = nested_sampling_loop!(ls, ns_params, 20_000, mc, save)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">20000√ó2 DataFrame
   Row ‚îÇ iter   emax
       ‚îÇ<span class="sgr90"> Int64  Float64
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     1 ‚îÇ     1      1.07806e7
     2 ‚îÇ     2      2.32797e6
     3 ‚îÇ     3  17506.1
     4 ‚îÇ     4   9585.06
     5 ‚îÇ     5   4375.71
     6 ‚îÇ     6   3592.71
     7 ‚îÇ     7   3588.73
     8 ‚îÇ     8   1117.72
   ‚ãÆ   ‚îÇ   ‚ãÆ          ‚ãÆ
 19994 ‚îÇ 19994     -1.26974
 19995 ‚îÇ 19995     -1.26974
 19996 ‚îÇ 19996     -1.26974
 19997 ‚îÇ 19997     -1.26974
 19998 ‚îÇ 19998     -1.26974
 19999 ‚îÇ 19999     -1.26974
 20000 ‚îÇ 20000     -1.26974
</span><span class="sgr36">            19985 rows omitted, LJAtomWalkers(AtomWalker{1}, LJParameters):
[1] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417394846333 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[2] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417394849064 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[3] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417394849309 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[4] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.269741739485023 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[5] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417394850317 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

‚ãÆ
Omitted 110 walkers
‚ãÆ

[116] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417395130777 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[117] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417395148947 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[118] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.269741739515693 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[119] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417395333157 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

[120] AtomWalker{1}(
    configuration      : FastSystem(H‚ÇÜ, periodic = FFF, bounding_box = [[14.999999999999998, 0.0, 0.0], [0.0, 14.999999999999998, 0.0], [0.0, 0.0, 14.999999999999998]]u&quot;√Ö&quot;)
    energy             : -1.2697417394892425 eV
    iter               : 20000
    list_num_par       : [6]
    frozen             : Bool[0]
    energy_frozen_part : 0.0 eV)

LJParameters(0.1 eV, 2.5 √Ö, 4.0, -9.763240814208984e-5 eV)
, NestedSamplingParameters(200, 0.1, 9.517397470535628e-6, 1.0e-5, 1.0, 0, 200))</span></span></code></pre><p>The results of the simulation are stored in the <code>energies</code> and <code>liveset</code> variables. The <code>energies</code> variable is a <code>DataFrame</code> that contains the energies of the walkers at each iteration. The <code>liveset</code> variable is the final liveset after the simulation. Let&#39;s see how the walkers look like after the simulation:</p><pre><code class="language-julia hljs">liveset.walkers[1].configuration</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FastSystem(H‚ÇÜ, periodic = FFF):
    bounding_box      : [      15        0        0;
                                0       15        0;
                                0        0       15]u&quot;√Ö&quot;

    AtomView(H,  [ 8.50775,  2.07181,  11.4109]u&quot;√Ö&quot;)
    AtomView(H,  [ 9.14698,  5.96238,  11.6627]u&quot;√Ö&quot;)
    AtomView(H,  [   10.72,  3.67687,  11.9888]u&quot;√Ö&quot;)
    AtomView(H,  [ 6.93472,  4.35732,  11.0849]u&quot;√Ö&quot;)
    AtomView(H,  [ 9.29413,  4.06462,  9.61796]u&quot;√Ö&quot;)
    AtomView(H,  [ 8.36061,  3.96957,  13.4557]u&quot;√Ö&quot;)

             .------------------------------------.  
            /|                                    |  
           / |                                    |  
          /  |                                    |  
         /   |                                    |  
        /    |                                    |  
       /     |                                    |  
      /      |                                    |  
     /       |             H                      |  
    *        |                H                   |  
    |        |                   H                |  
    |        |          H                         |  
    |        |            H                       |  
    |        |               H                    |  
    |        |                                    |  
    |        |                                    |  
    |        |                                    |  
    |        |                                    |  
    |        .------------------------------------.  
    |       /                                    /   
    |      /                                    /    
    |     /                                    /     
    |    /                                    /      
    |   /                                    /       
    |  /                                    /        
    | /                                    /         
    |/                                    /          
    *------------------------------------*           
</code></pre><p>They should be in a more ordered state, in this case, a cluster, than the initial gaseous state.</p><p>That&#39;s it! You have successfully run a nested sampling simulation using the FreeBird.jl package.</p><h2 id="Lattice-walkers-and-exact-enumeration"><a class="docs-heading-anchor" href="#Lattice-walkers-and-exact-enumeration">Lattice walkers and exact enumeration</a><a id="Lattice-walkers-and-exact-enumeration-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-walkers-and-exact-enumeration" title="Permalink"></a></h2><p>Another feature of FreeBird.jl is the ability to work with lattice systems. The lattice systems are defined by the <a href="../AbstractWalkers/#FreeBird.AbstractWalkers.MLattice"><code>MLattice</code></a> which is a parametrized type.</p><pre><code class="language-julia hljs">MLattice{C,G}(
    lattice_vectors::Matrix{Float64},
    basis::Vector{Tuple{Float64, Float64, Float64}},
    supercell_dimensions::Tuple{Int64, Int64, Int64},
    periodicity::Tuple{Bool, Bool, Bool},
    components::Vector{Vector{Bool}},
    adsorptions::Vector{Bool},
    cutoff_radii::Vector{Float64},
) where {C,G}</code></pre><p>The <code>C</code> parameter is the number of components in the system, and the <code>G</code> parameter defines the geometry of the lattice.</p><p>Now, let&#39;s create a simple square lattice system with single component:</p><pre><code class="language-julia hljs">ml = MLattice{1,SquareLattice}(components=[[1,2]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 48 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors at cutoffs [1.1, 1.5]
    occupations          : 
      ‚óè ‚óè ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
    adsorptions          : full adsorption
</code></pre><p>When you run the above code, the outer constructor of <code>MLattice</code> will be called. Many of the arguments are optional and have default values. The <code>components</code> argument is a vector of vectors that defines the components of the system. The <code>components=[[1,2]]</code> argument specifies that the system has a single component, and the first and second sites are occupied.</p><pre><code class="language-julia hljs">MLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,
    basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],
    supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),
    periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),
    cutoff_radii::Vector{Float64}=[1.1, 1.5],
    components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,
    adsorptions::Union{Vector{Int},Symbol}=:full)</code></pre><p>You may notice that the above code returns a <code>SLattice</code> type. The <code>SLattice</code> type is simply an alias for the <code>MLattice{1,G}</code>, where <code>G</code> is the geometry of the lattice and the number of components is fixed to 1. You can also directly call the <code>SLattice</code>, it will give the same result:</p><pre><code class="language-julia hljs">sl = SLattice{SquareLattice}(components=[[1,2]])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 48 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors at cutoffs [1.1, 1.5]
    occupations          : 
      ‚óè ‚óè ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
    adsorptions          : full adsorption
</code></pre><p>Now, let&#39;s define a Hamiltonian for the lattice system:</p><pre><code class="language-julia hljs">ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u&quot;eV&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GenericLatticeHamiltonian{2,Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}:
    on_site_interaction:      -0.04 eV
    nth_neighbor_interactions: [-0.01, -0.0025] eV
</code></pre><p>The <a href="../AbstractHamiltonians/#FreeBird.AbstractHamiltonians.GenericLatticeHamiltonian"><code>GenericLatticeHamiltonian</code></a> type is a struct that holds the parameters of the Hamiltonian. The first argument is the on-site energy, and the second argument is the list of n-th nearest-neighbors energy. The third argument is the unit of the energy.</p><p>To run exact enumeration, we only need a initial walker/lattice configuration, and the Hamiltonian. Let&#39;s run the exact enumeration:</p><pre><code class="language-julia hljs">df, ls = exact_enumeration(sl, ham)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">120√ó2 DataFrame
 Row ‚îÇ energy      config
     ‚îÇ<span class="sgr90"> Quantity‚Ä¶   Array‚Ä¶
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ   -0.09 eV  Vector{Bool}[[1, 1, 0, 0, 0, 0, ‚Ä¶
   2 ‚îÇ   -0.08 eV  Vector{Bool}[[1, 0, 1, 0, 0, 0, ‚Ä¶
   3 ‚îÇ   -0.09 eV  Vector{Bool}[[1, 0, 0, 1, 0, 0, ‚Ä¶
   4 ‚îÇ   -0.09 eV  Vector{Bool}[[1, 0, 0, 0, 1, 0, ‚Ä¶
   5 ‚îÇ -0.0825 eV  Vector{Bool}[[1, 0, 0, 0, 0, 1, ‚Ä¶
   6 ‚îÇ   -0.08 eV  Vector{Bool}[[1, 0, 0, 0, 0, 0, ‚Ä¶
   7 ‚îÇ -0.0825 eV  Vector{Bool}[[1, 0, 0, 0, 0, 0, ‚Ä¶
   8 ‚îÇ   -0.08 eV  Vector{Bool}[[1, 0, 0, 0, 0, 0, ‚Ä¶
  ‚ãÆ  ‚îÇ     ‚ãÆ                       ‚ãÆ
 114 ‚îÇ   -0.09 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 115 ‚îÇ   -0.09 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 116 ‚îÇ   -0.08 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 117 ‚îÇ   -0.09 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 118 ‚îÇ   -0.09 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 119 ‚îÇ   -0.08 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
 120 ‚îÇ   -0.09 eV  Vector{Bool}[[0, 0, 0, 0, 0, 0, ‚Ä¶
</span><span class="sgr36">                                     105 rows omitted, LatticeGasWalkers(LatticeWalker{1}, GenericLatticeHamiltonian{2, Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}):
    lattice_vectors:      [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    supercell_dimensions: (4, 4, 1)
    periodicity:          (true, true, false)
    basis:                [(0.0, 0.0, 0.0)]
[1] energy = -0.09 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[2] energy = -0.08 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[3] energy = -0.09 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[4] energy = -0.09 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[5] energy = -0.0825 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
‚ãÆ
Omitted 110 walkers
‚ãÆ

[116] energy = -0.08 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]
[117] energy = -0.09 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1]
[118] energy = -0.09 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]
[119] energy = -0.08 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]
[120] energy = -0.09 eV, iter = 0
    occupations:
      components:
        component 1:
          Bool[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]

GenericLatticeHamiltonian{2,Quantity{Float64, ùêã^2 ùêå ùêì^-2, Unitful.FreeUnits{(eV,), ùêã^2 ùêå ùêì^-2, nothing}}}:
    on_site_interaction:      -0.04 eV
    nth_neighbor_interactions: [-0.01, -0.0025] eV

)</span></span></code></pre><p>The results of the exact enumeration are stored in the <code>df</code> and <code>ls</code> variables. The <code>df</code> variable is a <code>DataFrame</code> that contains the list of energies, as well as the configurations. The <code>ls</code> variable is the final liveset that contains all possible configurations of the lattice system. Let&#39;s see how the first configuration looks like:</p><pre><code class="language-julia hljs">ls.walkers[1].configuration</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 48 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors at cutoffs [1.1, 1.5]
    occupations          : 
      ‚óè ‚óè ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
    adsorptions          : full adsorption
</code></pre><p>It&#39;s the initial configuration of the lattice system. Let&#39;s see how the last configuration looks like:</p><pre><code class="language-julia hljs">ls.walkers[end].configuration</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SLattice{SquareLattice}
    lattice_vectors      : [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0]
    positions            : 48 grid points
    supercell_dimensions : (4, 4, 1)
    basis                : [(0.0, 0.0, 0.0)]
    periodicity          : (true, true, false)
    cutoff radii         : 2 nearest neighbors at cutoffs [1.1, 1.5]
    occupations          : 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óã ‚óã 
      ‚óã ‚óã ‚óè ‚óè 
    adsorptions          : full adsorption
</code></pre><p>Be warned that the exact enumeration can be computationally expensive for large systems.</p><p>That&#39;s it! You have successfully run an exact enumeration simulation using the FreeBird.jl package.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ FreeBird.jl</a><a class="docs-footer-nextpage" href="../AbstractLiveSets/">AbstractLiveSets ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 3 January 2025 21:59">Friday 3 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
