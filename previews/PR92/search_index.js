var documenterSearchIndex = {"docs":
[{"location":"FreeBirdIO/#FreeBirdIO","page":"FreeBirdIO","title":"FreeBirdIO","text":"","category":"section"},{"location":"FreeBirdIO/#Functions","page":"FreeBirdIO","title":"Functions","text":"","category":"section"},{"location":"FreeBirdIO/","page":"FreeBirdIO","title":"FreeBirdIO","text":"Modules = [FreeBirdIO]","category":"page"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO","text":"FreeBirdIO\n\nModule for input/output operations in the FreeBird package.\n\n\n\n\n\n","category":"module"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.DataSavingStrategy","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.DataSavingStrategy","text":"abstract type DataSavingStrategy\n\nAbstract type representing a strategy for saving data.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.SaveEveryN","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.SaveEveryN","text":"struct SaveEveryN <: DataSavingStrategy\n\nSaveEveryN is a concrete subtype of DataSavingStrategy that specifies saving data every N steps.\n\nFields\n\ndf_filename::String: The name of the file to save the DataFrame to.\nwk_filename::String: The name of the file to save the atom walker to.\nls_filename::String: The name of the file to save the liveset to.\nn_traj::Int: The number of steps between each save of the culled walker into a trajectory file.\nn_snap::Int: The number of steps between each save of the liveset into a snapshot file.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.SaveFreePartEveryN","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.SaveFreePartEveryN","text":"struct SaveFreePartEveryN <: DataSavingStrategy\n\nSaveFreePartEveryN is a concrete subtype of DataSavingStrategy that specifies saving data every N steps. Only the free particles are saved into the trajectory and snapshot files.\n\nFields\n\ndf_filename::String: The name of the file to save the DataFrame to.\nwk_filename::String: The name of the file to save the atom walker to.\nls_filename::String: The name of the file to save the liveset to.\nn_traj::Int: The number of steps between each save of the culled walker into a trajectory file.\nn_snap::Int: The number of steps between each save of the liveset into a snapshot file.\n\n\n\n\n\n","category":"type"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.append_system-Tuple{AtomsBase.FlexibleSystem, AtomsBase.FlexibleSystem}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.append_system","text":"append_system(ats1::FlexibleSystem, ats2::FlexibleSystem)\n\nAppend two FlexibleSystem objects into a single FastSystem object. The first argument is the system to be appended to, and its bounding box and boundary conditions  will be used for the new system.\n\nArguments\n\nats1::FlexibleSystem: The base system to be appended.\nats2::FlexibleSystem: The system to append.\n\nReturns\n\nnew_list: A new FastSystem object containing the appended systems.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.append_walker-Union{Tuple{C}, Tuple{String, AtomWalker{C}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.append_walker","text":"append_walker(filename::String, at::AtomWalker)\n\nAppend an AtomWalker object to a file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.convert_system_to_walker-Tuple{AtomsBase.FlexibleSystem, Bool}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.convert_system_to_walker","text":"convert_system_to_walker(at::FlexibleSystem, resume::Bool)\n\nConverts a FlexibleSystem object to an AtomWalker object.\n\nArguments\n\nat::FlexibleSystem: The FlexibleSystem object to convert.\nresume::Bool: Whether to resume from previous data.\n\nReturns\n\nAtomWalker: The converted AtomWalker object.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.convert_walker_to_system-Tuple{AtomWalker}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.convert_walker_to_system","text":"convert_walker_to_system(at::AtomWalker)\n\nConverts an AtomWalker object to an AbstractSystem object.\n\nArguments\n\nat::AtomWalker: The AtomWalker object to be converted.\n\nReturns\n\nAbstractSystem: The converted AbstractSystem object.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_initial_configs-Tuple{Int64, Float64, Int64}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_initial_configs","text":"generate_initial_configs(num_walkers::Int, volume_per_particle::Float64, num_particle::Int; particle_type::Symbol=:H)\n\nGenerate initial configurations for a given number of walkers.\n\nArguments\n\nnum_walkers::Int: The number of walkers.\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Int: The number of particles.\nparticle_type::Symbol=:H: The type of particle (default is :H).\n\nReturns\n\nAn array of initial configurations for each walker.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_multi_type_random_starting_config-Tuple{Float64, Vector{Int64}}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_multi_type_random_starting_config","text":"generate_multi_type_random_starting_config(volume_per_particle::Float64, num_particle::Vector{Int}; particle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)])\n\nGenerate a random starting configuration for a system of particles with multiple types.\n\nArguments\n\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Vector{Int}: The number of particles of each type.\nparticle_types::Vector{Symbol}=[Symbol(:H), Symbol(:O)]: The types of particles.\n\nReturns\n\nFastSystem: A FastSystem object representing the generated system.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.generate_random_starting_config-Tuple{Float64, Int64}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.generate_random_starting_config","text":"generate_random_starting_config(volume_per_particle::Float64, num_particle::Int; particle_type::Symbol=:H)\n\nGenerate a random starting configuration for a system of particles.\n\nArguments\n\nvolume_per_particle::Float64: The volume per particle.\nnum_particle::Int: The number of particles.\nparticle_type::Symbol=:H: The type of particle (default is hydrogen).\n\nReturns\n\nFastSystem: A FastSystem object representing the generated system.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_configs-Tuple{String, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_configs","text":"read_configs(filename::String, pbc::Vector)\n\nReads atomic configurations from a file and applies periodic boundary conditions.\n\nArguments\n\nfilename::String: The name of the file containing the atomic configurations.\npbc::Vector: A vector specifying the periodic boundary conditions.\n\nReturns\n\nAn array of atomic configurations with periodic boundary conditions applied.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_configs-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_configs","text":"read_configs(filename::String; pbc::String=\"TTT\")\n\nReads configurations from a file.\n\nArguments\n\nfilename::String: The name of the file to read configurations from.\npbc::String=\"TTT\": Periodic boundary conditions. A string of length 3, where each character represents whether the corresponding dimension has periodic boundary conditions ('T') or not ('F').\n\nReturns\n\nThe configurations read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_config-Tuple{String, Vector}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_config","text":"read_single_config(filename::String, pbc::Vector)\n\nReads a single configuration from the specified file and sets the periodic boundary conditions (PBC) for the atoms.\n\nArguments\n\nfilename::String: The name of the file to read the configuration from.\npbc::Vector: A vector specifying the periodic boundary conditions.\n\nReturns\n\nat::Atoms: The atoms with the PBC set.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_config-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_config","text":"read_single_config(filename::String; pbc::String=\"TTT\")\n\nReads a single configuration from the specified file.\n\nArguments\n\nfilename::String: The name of the file to read from.\npbc::String=\"TTT\": The periodic boundary conditions. Default is \"TTT\".\n\nReturns\n\nThe configuration read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_single_walker-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_single_walker","text":"read_single_walker(filename::String; pbc::String=\"TTT\", resume::Bool=true)\n\nReads a single walker from the specified file.\n\nArguments\n\nfilename::String: The path to the file containing the walker data.\npbc::String: (optional) The periodic boundary conditions. Default is \"TTT\".\nresume::Bool: (optional) Whether to resume reading from a previous checkpoint. Default is true.\n\nReturns\n\nThe walker object read from the file.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.read_walkers-Tuple{String}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.read_walkers","text":"read_walkers(filename::String; pbc::String=\"TTT\", resume::Bool=true)\n\nReads walker configurations from a file.\n\nArguments\n\nfilename::String: The name of the file to read the walker configurations from.\npbc::String: A string specifying the periodic boundary conditions. Default is \"TTT\".\nresume::Bool: A boolean indicating whether to resume reading from a previous checkpoint. Default is true.\n\nReturns\n\nAn array of walker objects.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.set_pbc-Tuple{ExtXYZ.Atoms, Vector{Bool}}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.set_pbc","text":"set_pbc(at::Atoms, pbc::Vector)\n\nSet the periodic boundary conditions for a system of atoms.\n\nArguments\n\nat::Atoms: The system of atoms.\npbc::Vector: A vector of length 3 specifying the periodic boundary conditions for each dimension. Each element can be either true for periodic boundary conditions or false for Dirichlet zero boundary conditions.\n\nReturns\n\nFlexibleSystem: A flexible system with the specified boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_df-Tuple{String, DataFrames.DataFrame}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_df","text":"write_df(filename::String, df::DataFrame)\n\nWrite a DataFrame to a CSV file.\n\nArguments\n\nfilename::String: The name of the file to write to.\ndf::DataFrame: The DataFrame to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_df_every_n-Tuple{DataFrames.DataFrame, Int64, DataSavingStrategy}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_df_every_n","text":"write_df_every_n(df::DataFrame, step::Int, d_strategy::SaveEveryN)\n\nWrite the DataFrame df to a file specified by d_strategy.filename every d_strategy.n steps.\n\nArguments\n\ndf::DataFrame: The DataFrame to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the filename and the step interval.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_ls_every_n-Tuple{AbstractLiveSet, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_ls_every_n","text":"write_ls_every_n(ls::AtomWalkers, step::Int, d_strategy::SaveEveryN)\n\nWrite the liveset ls to file every n steps, as specified by the d_strategy.\n\nArguments\n\nls::AbstractLiveSet: The liveset to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the frequency of writing.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_single_walker-Tuple{String, AtomWalker, Bool}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_single_walker","text":"write_single_walker(filename::String, at::AtomWalker, append::Bool)\n\nWrite a single AtomWalker object to a file. If the file already exists, append the walker to the file.\n\nArguments\n\nfilename::String: The name of the file to write to.\nat::AtomWalker: The AtomWalker object to write.\nappend::Bool: A boolean indicating whether to append the walker to the file if it already exists.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_single_walker-Tuple{String, AtomWalker}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_single_walker","text":"write_single_walker(filename::String, at::AtomWalker)\n\nWrite a single AtomWalker object to a file.\n\nArguments\n\nfilename::String: The name of the file to write to.\nat::AtomWalker: The AtomWalker object to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walker_every_n-Tuple{AtomWalker, Int64, SaveEveryN}","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walker_every_n","text":"write_walker_every_n(at::AtomWalker, step::Int, d_strategy::SaveEveryN)\n\nWrite the atom walker at to a file specified by d_strategy.wk_filename every d_strategy.n steps.\n\nArguments\n\nat::AtomWalker: The atom walker to be written.\nstep::Int: The current step number.\nd_strategy::SaveEveryN: The save strategy specifying the file name and the interval.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walkers-Union{Tuple{C}, Tuple{String, Array{AtomWalker{C}, 1}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walkers","text":"write_walkers(filename::String, ats::Vector{AtomWalker})\n\nWrite a collection of AtomWalker objects to a file.\n\nArguments\n\nfilename::String: The name of the file to write the walkers to.\nats::Vector{AtomWalker}: The collection of AtomWalker objects to write.\n\n\n\n\n\n","category":"method"},{"location":"FreeBirdIO/#FreeBird.FreeBirdIO.write_walkers-Union{Tuple{C}, Tuple{String, Array{LatticeWalker{C}, 1}}} where C","page":"FreeBirdIO","title":"FreeBird.FreeBirdIO.write_walkers","text":"write_walkers(filename::String, ats::Vector{LatticeWalker})\n\nWrite a collection of LatticeWalker objects to a file.\n\nArguments\n\nfilename::String: The name of the file to write the walkers to.\nats::Vector{LatticeWalker}: The collection of LatticeWalker objects to write.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#Sampling-Schemes","page":"SamplingSchemes","title":"Sampling Schemes","text":"","category":"section"},{"location":"SamplingSchemes/#Functions","page":"SamplingSchemes","title":"Functions","text":"","category":"section"},{"location":"SamplingSchemes/","page":"SamplingSchemes","title":"SamplingSchemes","text":"Modules = [SamplingSchemes]","category":"page"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes","text":"SamplingSchemes\n\nModule for defining the sampling schemes.\n\n\n\n\n\n","category":"module"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.LatticeNestedSamplingParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.LatticeNestedSamplingParameters","text":"mutable struct LatticeNestedSamplingParameters <: SamplingParameters\n\nThe LatticeNestedSamplingParameters struct represents the parameters used in the lattice nested sampling scheme.\n\nFields\n\nmc_steps::Int64: The number of total Monte Carlo moves to perform.\nenergy_perturbation::Float64: The energy perturbation used in the sampling process.\nfail_count::Int64: The number of failed MC moves in a row.\nallowed_fail_count::Int64: The maximum number of failed MC moves allowed before resetting the step size.\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCMixedMoves","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCMixedMoves","text":"struct MCMixedMoves <: MCRoutine\n\nA type for generating a new walker by performing random walks and swapping atoms. Currently, it is intended to use this routine for multi-component systems. The actual number of random walks and swaps to perform is determined by the weights of the fields walks_freq and swaps_freq. For example, if walks_freq=4 and swaps_freq=1, then the routine will perform 4 random walks and 1 atom swap in each cycle. The counters  walks_counter and swaps_counter are used to keep track of the number of random walks and swaps performed in the current cycle.\n\nFields\n\nwalks_freq::Int: The frequency of random walks to perform.\nswaps_freq::Int: The frequency of atom swaps to perform.\nwalks_counter::Int: The counter for random walks.\nswaps_counter::Int: The counter for atom swaps.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCNewSample","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCNewSample","text":"struct MCNewSample <: MCRoutine\n\nA type for generating a new walker from a random configuration. Currently, it is intended to use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkClone","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkClone","text":"struct MCRandomWalkClone <: MCRoutine\n\nA type for generating a new walker by cloning an existing walker and performing a random walk for decorrelation.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRandomWalkMaxE","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRandomWalkMaxE","text":"struct MCRandomWalkMaxE <: MCRoutine\n\nA type for generating a new walker by performing a random walk for decorrelation on the highest-energy walker.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRejectionSampling","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRejectionSampling","text":"struct MCRejectionSampling <: MCRoutine\n\nA type for generating a new walker by performing rejection sampling. Currently, it is intended to use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MCRoutine","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MCRoutine","text":"abstract type MCRoutine\n\nAn abstract type representing a Monte Carlo routine.\n\nCurrently, the following concrete types are supported:\n\nMCRandomWalkMaxE: A type for generating a new walker by performing a random walk for decorrelation on the\n\nhighest-energy walker.\n\nMCRandomWalkClone: A type for generating a new walker by cloning an existing walker and performing a random walk\n\nfor decorrelation.\n\nMCNewSample: A type for generating a new walker from a random configuration. Currently, it is intended to use \n\nthis routine for lattice gas systems.\n\nMCMixedMoves: A type for generating a new walker by performing random walks and swapping atoms. Currently, it is\n\nintended to use this routine for multi-component systems. The actual number of random walks and swaps to perform is determined by the weights of the fields walks_freq and swaps_freq. See MCMixedMoves.\n\nMCRejectionSampling: A type for generating a new walker by performing rejection sampling. Currently, it is intended\n\nto use this routine for lattice gas systems.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.MetropolisMCParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.MetropolisMCParameters","text":"MetropolisMCParameters <: SamplingParameters\n\nParameters for the Metropolis Monte Carlo algorithm.\n\nFields\n\ntemperature::Float64: The temperature of the system.\nnum_steps::Int64: The number of Monte Carlo steps.\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.NestedSamplingParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.NestedSamplingParameters","text":"mutable struct NestedSamplingParameters <: SamplingParameters\n\nThe NestedSamplingParameters struct represents the parameters used in the nested sampling scheme.\n\nFields\n\nmc_steps::Int64: The number of total Monte Carlo moves to perform.\ninitial_step_size::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.\nstep_size::Float64: The on-the-fly step size used in the sampling process.\nstep_size_lo::Float64: The lower bound of the step size.\nstep_size_up::Float64: The upper bound of the step size.\nfail_count::Int64: The number of failed MC moves in a row.\nallowed_fail_count::Int64: The maximum number of failed MC moves allowed before resetting the step size.\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.SamplingParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.SamplingParameters","text":"struct NestedSamplingParameters\n\nThe NestedSamplingParameters struct represents the parameters for various sampling algorithm.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.WangLandauParameters","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.WangLandauParameters","text":"WangLandauParameters\n\nA structure to hold the parameters for the Wang-Landau sampling scheme.\n\nFields\n\nnum_steps::Int64: The number of Monte Carlo steps.\nflatness_criterion::Float64: The criterion for flatness of the histogram.\nf_initial::Float64: The initial modification factor.\nf_min::Float64: The minimum modification factor.\nenergy_bins::Vector{Float64}: The pre-supplied energy bins.\nrandom_seed::Int64: The seed for the random number generator.\n\n\n\n\n\n","category":"type"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.WangLandauParameters-Tuple{}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.WangLandauParameters","text":"WangLandauParameters(; \n    num_steps::Int64=100,\n    flatness_criterion::Float64=0.8,\n    f_initial::Float64=Float64(MathConstants.e),\n    f_min::Float64=exp(1e-8),\n    energy_min::Float64=0.0,\n    energy_max::Float64=1.0,\n    num_energy_bins::Int64=100,\n    random_seed::Int64=1234\n)\n\nCreate a WangLandauParameters object with the specified parameters.\n\nArguments\n\nnum_steps::Int64: The number of Monte Carlo steps.\nflatness_criterion::Float64: The criterion for flatness of the histogram.\nf_initial::Float64: The initial modification factor.\nf_min::Float64: The minimum modification factor.\nenergy_min::Float64: The minimum energy.\nenergy_max::Float64: The maximum energy.\nnum_energy_bins::Int64: The number of energy bins.\nrandom_seed::Int64: The seed for the random number generator.\n\nReturns\n\nWangLandauParameters: The parameters for the Wang-Landau sampling scheme.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.adjust_step_size-Tuple{NestedSamplingParameters, Float64}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.adjust_step_size","text":"adjust_step_size(ns_params::NestedSamplingParameters, rate::Float64)\n\nAdjusts the step size of the nested sampling algorithm based on the acceptance rate.      If the acceptance rate is greater than 0.75, the step size is increased by 1%.      If the acceptance rate is less than 0.25, the step size is decreased by 1%.\n\nArguments\n\nns_params::NestedSamplingParameters: The parameters of the nested sampling algorithm.\nrate::Float64: The acceptance rate of the algorithm.\nrange::Tuple{Float64, Float64}: The range of acceptance rates for adjusting the step size. Default is (0.25, 0.75).\n\nReturns\n\nns_params::NestedSamplingParameters: The updated parameters with adjusted step size.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.exact_enumeration-Union{Tuple{G}, Tuple{C}, Tuple{MLattice{C, G}, ClassicalHamiltonian}} where {C, G}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.exact_enumeration","text":"exact_enumeration(lattice::SLattice{G}, cutoff_radii::Tuple{Float64, Float64}, h::ClassicalHamiltonian) where G\n\nEnumerate all possible configurations of a lattice system and compute the energy of each configuration.\n\nArguments\n\nlattice::SLattice{G}: The (starting) lattice system to enumerate. All possible configurations will be generated from this lattice system.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\n\nReturns\n\nDataFrame: A DataFrame containing the energy and configuration of each configuration.\nLatticeGasWalkers: A collection of lattice walkers for each configuration.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.monte_carlo_sampling-Tuple{AbstractLattice, ClassicalHamiltonian, MetropolisMCParameters}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.monte_carlo_sampling","text":"monte_carlo_sampling(\n    lattice::AbstractLattice,\n    h::ClassicalHamiltonian,\n    mc_params::MetropolisMCParameters\n)\n\nPerform the Metropolis Monte Carlo sampling algorithm for a range of temperatures.\n\nNote: The Boltzmann constant is set to 8.617333262e-5 eV K^-1. Thus, the units of the temperature should be in Kelvin, and the units of the energy should be in eV (defined in the Hamiltonian).\n\nArguments\n\nlattice::AbstractLattice: The initial lattice configuration.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\nmc_params::MetropolisMCParameters: The parameters for the Metropolis Monte Carlo algorithm.\n\nReturns\n\nenergies::Vector{Float64}: The energies of the system at each temperature.\ncvs::Vector{Float64}: The heat capacities of the system at each temperature.\nacceptance_rates::Vector{Float64}: The acceptance rates of the system at each temperature.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_loop!-Tuple{AtomWalkers, NestedSamplingParameters, Int64, MCRoutine, DataSavingStrategy}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_loop!","text":"nested_sampling_loop!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, n_steps::Int64, mc_routine::MCRoutine; args...)\n\nPerform a nested sampling loop for a given number of steps.\n\nArguments\n\nliveset::AtomWalkers: The initial set of walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nn_steps::Int64: The number of steps to perform.\nmc_routine::MCRoutine: The Monte Carlo routine to use.\n\nReturns\n\ndf: A DataFrame containing the iteration number and maximum energy for each step.\nliveset: The updated set of walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_loop!-Tuple{LatticeGasWalkers, LatticeNestedSamplingParameters, Int64, MCRoutine, DataSavingStrategy}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_loop!","text":"nested_sampling_loop!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, n_steps::Int64, mc_routine::MCRoutine, save_strategy::DataSavingStrategy)\n\nPerform a nested sampling loop on a lattice gas system for a given number of steps.\n\nArguments\n\nliveset::LatticeGasWalkers: The initial set of walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nn_steps::Int64: The number of steps to perform.\nmc_routine::MCRoutine: The Monte Carlo routine to use.\nsave_strategy::DataSavingStrategy: The strategy for saving data.\n\nReturns\n\ndf: A DataFrame containing the iteration number and maximum energy for each step.\nliveset: The updated set of walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{AtomWalkers, NestedSamplingParameters, MCMixedMoves}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, mc_routine::MCMixedMoves)\n\nPerform a single step of the nested sampling algorithm using the Monte Carlo mixed moves routine.\n\nArguments\n\nliveset::AtomWalkers: The set of atom walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCMixedMoves: The Monte Carlo mixed moves routine.\n\nReturns\n\niter: The iteration number after the step.\nemax: The highest energy recorded during the step.\nliveset: The updated set of atom walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{AtomWalkers, NestedSamplingParameters, MCRoutine}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::AtomWalkers, ns_params::NestedSamplingParameters, mc_routine::MCRoutine)\n\nPerform a single step of the nested sampling algorithm using the Monte Carlo random walk routine.\n\nArguments\n\nliveset::AtomWalkers: The set of atom walkers.\nns_params::NestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCRoutine: The Monte Carlo routine for generating new samples. See MCRoutine.\n\nReturns\n\niter: The iteration number after the step.\nemax: The highest energy recorded during the step.\nliveset: The updated set of atom walkers.\nns_params: The updated nested sampling parameters.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{LatticeGasWalkers, LatticeNestedSamplingParameters, MCNewSample}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, mc_routine::MCNewSample)\n\nPerform a single step of the nested sampling algorithm.\n\nThis function takes a liveset of lattice gas walkers, ns_params containing the parameters for nested sampling, and mc_routine representing the Monte Carlo routine for generating new samples. It performs a single step of the nested sampling algorithm by updating the liveset with a new walker.\n\nArguments\n\nliveset::LatticeGasWalkers: The liveset of lattice gas walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCNewSample: The Monte Carlo routine for generating new samples.\n\nReturns\n\niter: The iteration number of the liveset after the step.\nemax: The maximum energy of the liveset after the step.\nliveset::LatticeGasWalkers: The updated liveset after the step.\nns_params::LatticeNestedSamplingParameters: The updated nested sampling parameters after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nested_sampling_step!-Tuple{LatticeGasWalkers, LatticeNestedSamplingParameters, MCRoutine}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nested_sampling_step!","text":"nested_sampling_step!(liveset::LatticeGasWalkers, ns_params::LatticeNestedSamplingParameters, mc_routine::MCRoutine)\n\nPerform a single step of the nested sampling algorithm.\n\nThis function takes a liveset of lattice gas walkers, ns_params containing the parameters for nested sampling, and mc_routine representing the Monte Carlo  routine for generating new samples. It performs a single step of the nested sampling algorithm by updating the liveset with a new walker.\n\nArguments\n\nliveset::LatticeGasWalkers: The liveset of lattice gas walkers.\nns_params::LatticeNestedSamplingParameters: The parameters for nested sampling.\nmc_routine::MCRoutine: The Monte Carlo routine for generating new samples.\n\nReturns\n\niter: The iteration number of the liveset after the step.\nemax: The maximum energy of the liveset after the step.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.nvt_monte_carlo-Tuple{AbstractLattice, ClassicalHamiltonian, Float64, Int64, Int64}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.nvt_monte_carlo","text":"nvt_monte_carlo(\n    lattice::AbstractLattice,\n    h::ClassicalHamiltonian,\n    temperature::Float64,\n    num_steps::Int64,\n    random_seed::Int64\n)\n\nPerform the NVT Monte Carlo algorithm to sample the lattice configurations.\n\nNote: The Boltzmann constant is set to 8.617333262e-5 eV K^-1. Thus, the units of the temperature should be in Kelvin, and the units of the energy should be in eV (defined in the Hamiltonian).\n\nArguments\n\nlattice::AbstractLattice: The initial lattice configuration.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\ntemperature::Float64: The temperature of the system.\nnum_steps::Int64: The number of Monte Carlo steps.\nrandom_seed::Int64: The seed for the random number generator.\n\nReturns\n\nenergies::Vector{Float64}: The energies of the system at each step.\nconfigurations::Vector{typeof(lattice)}: The configurations of the system at each step.\naccepted_steps::Int64: The number of accepted steps.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.sort_by_energy!-Tuple{AbstractLiveSet}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.sort_by_energy!","text":"sort_by_energy!(liveset::LJAtomWalkers)\n\nSorts the walkers in the liveset by their energy in descending order.\n\nArguments\n\nliveset::LJAtomWalkers: The liveset of walkers to be sorted.\n\nReturns\n\nliveset::LJAtomWalkers: The sorted liveset.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.update_iter!-Tuple{AbstractLiveSet}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.update_iter!","text":"update_iter!(liveset::AtomWalkers)\n\nUpdate the iteration count for each walker in the liveset.\n\nArguments\n\nliveset::AtomWalkers: The set of walkers to update.\n\n\n\n\n\n","category":"method"},{"location":"SamplingSchemes/#FreeBird.SamplingSchemes.wang_landau-Tuple{AbstractLattice, ClassicalHamiltonian, WangLandauParameters}","page":"SamplingSchemes","title":"FreeBird.SamplingSchemes.wang_landau","text":"wang_landau(\n    lattice::AbstractLattice,\n    h::ClassicalHamiltonian,\n    wl_params::WangLandauParameters\n)\n\nwang_landau(\n    walker::AtomWalker,\n    lj::LennardJonesParametersSets,\n    wl_params::WangLandauParameters\n)\n\nPerform the Wang-Landau sampling scheme for a lattice or an atomistic system.\n\nArguments\n\nlattice::AbstractLattice/walker::AtomWalker: The initial lattice/atomistic configuration.\nh::ClassicalHamiltonian/lj::LennardJonesParametersSets: The Hamiltonian parameters for the lattice/atomistic system.\nwl_params::WangLandauParameters: The parameters for the Wang-Landau sampling scheme.\n\nReturns\n\ndf::DataFrame/energies::Vector{Float64}: The energies of the system at each step.\nwl_params::WangLandauParameters: The parameters for the Wang-Landau sampling scheme.\nS::Vector{Float64}: The entropy of the system.\nH::Vector{Int64}: The histogram of the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#EnergyEval","page":"EnergyEval","title":"EnergyEval","text":"","category":"section"},{"location":"EnergyEval/#Functions","page":"EnergyEval","title":"Functions","text":"","category":"section"},{"location":"EnergyEval/","page":"EnergyEval","title":"EnergyEval","text":"Modules = [EnergyEval]","category":"page"},{"location":"EnergyEval/#FreeBird.EnergyEval","page":"EnergyEval","title":"FreeBird.EnergyEval","text":"EnergyEval\n\nModule for evaluating energy-related quantities for a system.\n\n\n\n\n\n","category":"module"},{"location":"EnergyEval/#FreeBird.EnergyEval.frozen_energy-Tuple{AtomsBase.AbstractSystem, LJParameters, Vector{Int64}, Vector{Bool}}","page":"EnergyEval","title":"FreeBird.EnergyEval.frozen_energy","text":"frozen_energy(at::AbstractSystem, lj::LJParameters, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy of the frozen particles in the system using a single Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the frozen particles. Since the frozen particles do not move, the energy is typically only calculated once for a given system.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nlj::LJParameters: The Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy of the frozen particles in the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.frozen_energy-Union{Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeLJParameters{C}, Vector{Int64}, Vector{Bool}}} where C","page":"EnergyEval","title":"FreeBird.EnergyEval.frozen_energy","text":"frozen_energy(at::AbstractSystem, ljs::CompositeLJParameters{C}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy of the frozen particles in the system using a composite Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the frozen particles. Since the frozen particles do not move, the energy is typically only calculated once for a given system.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nljs::CompositeLJParameters{C}: The composite Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy of the frozen particles in the system.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.inter_component_energy-Tuple{AtomsBase.AbstractSystem, AtomsBase.AbstractSystem, LJParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.inter_component_energy","text":"inter_component_energy(at1::AbstractSystem, at2::AbstractSystem, lj::LJParameters)\n\nCompute the energy between two components of a system using the Lennard-Jones potential.\n\nArguments\n\nat1::AbstractSystem: The first component of the system.\nat2::AbstractSystem: The second component of the system.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy: The energy between the two components.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.inter_component_energy-Union{Tuple{U}, Tuple{N}, Tuple{Vector{Bool}, Vector{Bool}, Vector{Vector{Vector{Int64}}}, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.inter_component_energy","text":"inter_component_energy(lattice1::Vector{Bool}, lattice2::Vector{Bool}, lattice_neighbors::Vector{Vector{Vector{Int64}}}, h::GenericLatticeHamiltonian{N,U})\n\nCompute the interaction energy between two lattice configurations using the Hamiltonian parameters.\n\nArguments\n\nlattice1::Vector{Bool}: The first lattice configuration.\nlattice2::Vector{Bool}: The second lattice configuration.\nlattice_neighbors::Vector{Vector{Vector{Int64}}}: The lattice neighbor list.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::U: The interaction energy between the two lattice configurations.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Tuple{AtomsBase.AbstractSystem, LJParameters, Vector{Int64}, Vector{Bool}}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, lj::LJParameters, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy from interactions between free-free and free-frozen particles using the Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nlj::LJParameters: The Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Tuple{AtomsBase.AbstractSystem, LJParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, lj::LJParameters)\n\nCalculate the energy from interactions between particles using the Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{C}, Tuple{AtomsBase.AbstractSystem, CompositeLJParameters{C}, Vector{Int64}, Vector{Bool}}} where C","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(at::AbstractSystem, ljs::CompositeLJParameters{C}, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCalculate the energy from interactions between free-free and free-frozen particles using the Lennard-Jones potential. The energy is calculated by summing the pairwise interactions between the free particles.\n\nArguments\n\nat::AbstractSystem: The system for which the energy is calculated.\nljs::CompositeLJParameters{C}: The composite Lennard-Jones parameters.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\nReturns\n\nenergy: The energy from interactions between particles.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{U}, Tuple{N}, Tuple{G}, Tuple{C}, Tuple{MLattice{C, G}, MLatticeHamiltonian{C, N, U}}} where {C, G, N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::MLattice{C,G}, h::MLatticeHamiltonian{C,N,U})\n\nCompute the interaction energy of a multi-component lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::MLattice{C,G}: The multi-component lattice configuration.\nh::MLatticeHamiltonian{C,N,U}: The multi-component lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.interacting_energy-Union{Tuple{U}, Tuple{N}, Tuple{SLattice, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.interacting_energy","text":"interacting_energy(lattice::SLattice, h::GenericLatticeHamiltonian{N})\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice::SLattice: The lattice configuration.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::Float64: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.intra_component_energy-Tuple{AtomsBase.AbstractSystem, LJParameters}","page":"EnergyEval","title":"FreeBird.EnergyEval.intra_component_energy","text":"intra_component_energy(at::AbstractSystem, lj::LJParameters)\n\nCompute the energy within a component of a system using the Lennard-Jones potential.\n\nArguments\n\nat::AbstractSystem: The component of the system.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\nenergy: The energy within the component.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.lattice_interaction_energy-Union{Tuple{U}, Tuple{N}, Tuple{Vector{Bool}, Vector{Vector{Vector{Int64}}}, GenericLatticeHamiltonian{N, U}}} where {N, U}","page":"EnergyEval","title":"FreeBird.EnergyEval.lattice_interaction_energy","text":"lattice_interaction_energy(lattice_occupations::Vector{Bool}, lattice_neighbors::Vector{Vector{Vector{Int64}}}, h::GenericLatticeHamiltonian{N,U})\n\nCompute the interaction energy of a lattice configuration using the Hamiltonian parameters.\n\nArguments\n\nlattice_occupations::Vector{Bool}: The lattice occupation configuration.\nlattice_neighbors::Vector{Vector{Vector{Int64}}}: The lattice neighbor list.\nh::GenericLatticeHamiltonian{N,U}: The generic lattice Hamiltonian parameters.\n\nReturns\n\ne_interaction::U: The interaction energy of the lattice configuration.\n\n\n\n\n\n","category":"method"},{"location":"EnergyEval/#FreeBird.EnergyEval.pbc_dist-Union{Tuple{T}, Tuple{Union{Vector{T}, StaticArraysCore.SVector{T}}, Union{Vector{T}, StaticArraysCore.SVector{T}}, AtomsBase.AbstractSystem}} where T","page":"EnergyEval","title":"FreeBird.EnergyEval.pbc_dist","text":"pbc_dist(pos1, pos2, at)\n\nCompute the distance between two positions considering periodic boundary conditions. Currently only works for orthorhombic lattices.\n\nArguments\n\npos1::Union{SVector{T},Vector{T}}: The first position.\npos2::Union{SVector{T},Vector{T}}: The second position.\nat::AbstractSystem: The abstract system containing boundary conditions and bounding box.\n\nReturns\n\nd::Float64: The distance between pos1 and pos2 considering periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#AbstractLiveSets","page":"AbstractLiveSets","title":"AbstractLiveSets","text":"","category":"section"},{"location":"AbstractLiveSets/#Functions","page":"AbstractLiveSets","title":"Functions","text":"","category":"section"},{"location":"AbstractLiveSets/","page":"AbstractLiveSets","title":"AbstractLiveSets","text":"Modules = [AbstractLiveSets]","category":"page"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets","text":"AbstractLiveSets\n\nModule for defining the livesets, which are collections of  walkers that are used in the sampling schemes.\n\n\n\n\n\n","category":"module"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LJAtomWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LJAtomWalkers","text":"struct LJAtomWalkers <: AtomWalkers\n\nThe LJAtomWalkers struct represents a collection of atom walkers that interact with each other using the Lennard-Jones potential.\n\nFields\n\nwalkers::Vector{AtomWalker{C}}: A vector of atom walkers, where C is the number of components.\nlj_potential::LennardJonesParametersSets: The Lennard-Jones potential parameters. See LennardJonesParametersSets.\n\nConstructor\n\nLJAtomWalkers(walkers::Vector{AtomWalker{C}}, lj_potential::LennardJonesParametersSets; assign_energy=true):    Constructs a new LJAtomWalkers object with the given walkers and Lennard-Jones potential parameters. If assign_energy=true,   the energy of each walker is assigned using the Lennard-Jones potential.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.LatticeGasWalkers","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.LatticeGasWalkers","text":"struct LatticeGasWalkers <: LatticeWalkers\n\nThe LatticeGasWalkers struct represents a collection of lattice walkers for a lattice gas system. It is a subtype of LatticeWalkers.\n\nFields\n\nwalkers::Vector{LatticeWalker{C}}: A vector of lattice walkers.\nhamiltonian::LatticeGasHamiltonian: The lattice gas Hamiltonian associated with the walkers.\n\nConstructors\n\nLatticeGasWalkers(walkers::Vector{LatticeWalker{C}}, hamiltonian::LatticeGasHamiltonian; assign_energy=true, perturb_energy::Float64=0.0): Constructs a new LatticeGasWalkers object with the given walkers and Hamiltonian. If assign_energy is true, the energy of each walker is assigned using the provided Hamiltonian. The optional perturb_energy parameter can be used to add a small perturbation to the assigned energy.\n\n\n\n\n\n","category":"type"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Tuple{AtomWalker, LennardJonesParametersSets}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::AtomWalker, lj::LennardJonesParametersSets)\n\nAssigns the energy to the given walker using the Lennard-Jones parameters lj.\n\nArguments\n\nwalker::AtomWalker: The walker object to assign the energy to.\nlj::LennardJonesParametersSets: The Lennard-Jones parameters.\n\nReturns\n\nwalker::AtomWalker: The walker object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_energy!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian}} where C","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_energy!","text":"assign_energy!(walker::LatticeWalker{C}, hamiltonian::LatticeGasHamiltonian; perturb_energy::Float64=0.0)\n\nAssigns energy to the given walker based on the hamiltonian. If perturb_energy is non-zero, a small random perturbation is added to the energy.\n\nArguments\n\nwalker::LatticeWalker{C}: The walker to assign energy to.\nhamiltonian::LatticeGasHamiltonian: The Hamiltonian used to calculate the energy.\nperturb_energy::Float64=0.0: The amount of random perturbation to add to the energy.\n\nReturns\n\nwalker::LatticeWalker{C}: The walker with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"AbstractLiveSets/#FreeBird.AbstractLiveSets.assign_frozen_energy!-Tuple{AtomWalker, LennardJonesParametersSets}","page":"AbstractLiveSets","title":"FreeBird.AbstractLiveSets.assign_frozen_energy!","text":"assign_frozen_energy!(walker::AtomWalker, lj::LennardJonesParametersSets)\n\nAssigns the frozen energy to the given walker using the Lennard-Jones parameters lj.\n\nArguments\n\nwalker::AtomWalker: The walker object to assign the energy to.\nlj::LennardJonesParametersSets: The Lennard-Jones parameters.\n\nReturns\n\nwalker::AtomWalker: The walker object with the assigned energy.\n\n\n\n\n\n","category":"method"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"EditURL = \"../../scripts/quick_start.jl\"","category":"page"},{"location":"quick_start/#Quick-start-guide-to-FreeBird.jl","page":"Quick Start","title":"Quick start guide to FreeBird.jl","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"This is a quick start guide to using the FreeBird.jl package. It covers the basic functionalities of the package, such as generating atomistic and lattice walkers, defining a potential energy function or Hamiltonian, and running a sampling simulation. For more detailed information, please refer to the documentation of the package. You can find the runnable version of this script in the scripts directory of the package.","category":"page"},{"location":"quick_start/#Atomistic-walkers-and-nested-sampling","page":"Quick Start","title":"Atomistic walkers and nested sampling","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"First, let's load the FreeBird.jl package:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using FreeBird","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, let's create a few configurations of a simple atomistic system with six particles in a 3D box.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"single_config = generate_initial_configs(1, 562.5, 6; particle_type=:H)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The function above has generated a single configuration, with 562.5 Å^3 volume per particle, and 6 particles of type H. Note that the particle_type keyword argument can be used to specify the type of particle, i.e., chemical element. By default, the type is set to :H. Use ?generate_initial_configs in the REPL to see the documentation of the function. Or see generate_initial_configs.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's inspect the generated configuration using the vew_structure function:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"single_config[1] |> view_structure","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"It's of a FastSystem type from AtomsBase. The dimensions of the box are 15 Å x 15 Å x 15 Å, following the volume per particle specified. The positions of the particles are randomly generated within the box.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, let's generate a few more configurations:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"configs = generate_initial_configs(120, 562.5, 6)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The function above has generated 120 configurations, again, with 562.5 Å^3 volume per particle, and 6 particles of type H. These configurations will be served as the initial walkers for a sampling run, but first, we need to warp them into the AtomWalker type defined in FreeBird.jl.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"walkers = AtomWalker.(generate_initial_configs(120, 562.5, 6));\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's inquire the type of the walkers variable:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"walkers |> typeof","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The walkers variable is of a Vector{AtomWalker{1}} type, which is a vector of AtomWalker{1} objects. The AtomWalker{1} type is a parametrized type, where the parameter is the number of components in the system. In this case, the system has only one component, consisting of 6 particles of type H.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To define how these particles interact with each other, we need to create a potential energy function. Let's use the Lennard-Jones potential:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"lj = LJParameters(epsilon=0.1, sigma=2.5, cutoff=4.0)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The LJParameters type is a struct that holds the parameters of the Lennard-Jones potential. The epsilon and sigma fields are the energy and length scales of the potential, respectively. The cutoff field is the distance at which the potential is truncated. An energy shift is applied to the potential to ensure continuity at the cutoff distance, automatically in this case. See the documentation of the LJParameters type for more information and examples.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"We now can create a so-called liveset that will be used to store the walkers during the simulation. The lj potential will be used to attached and used to calculate the potential energy of the walkers.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ls = LJAtomWalkers(walkers, lj)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Here, ls is a LJAtomWalkers type, and has the walkers and lj fields attached to it.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, time to set up a simulation. We will be using nested sampling, a Bayesian-inference inspired method, as an example here. First, we need to define the nested sampling parameters:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ns_params = NestedSamplingParameters(200, 0.1, 0.01, 1e-5, 1.0, 0, 200, 1234)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The NestedSamplingParameters type is a struct that holds the parameters of the nested sampling algorithm. The fields are as follows:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"mc_steps::Int64: The number of total Monte Carlo moves to perform.\ninitial_step_size::Float64: The initial step size, which is the fallback step size if MC routine fails to accept a move.\nstep_size::Float64: The on-the-fly step size used in the sampling process.\nstep_size_lo::Float64: The lower bound of the step size.\nstep_size_up::Float64: The upper bound of the step size.\nfail_count::Int64: The number of failed MC moves in a row.\nallowed_fail_count::Int64: The maximum number of failed MC moves allowed before resetting the step size.\nrandom_seed::Int64: The seed for the random number generator.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Speaking of the Monte Carlo moves, we need to define that too:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"mc = MCRandomWalkClone()","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The MCRandomWalkClone type is a type of Monte Carlo move that indicates a new walker is created by cloning an existing walker and then decorrelate the positions of the particles.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"We also need to specify how we want to save the data and the output:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"save = SaveEveryN(n_traj=10, n_snap=20_000)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The SaveEveryN type is a struct that holds the parameters of the saving routine.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, we are ready to run the nested sampling simulation:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"energies, liveset, _ = nested_sampling_loop!(ls, ns_params, 20_000, mc, save)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The results of the simulation are stored in the energies and liveset variables. The energies variable is a DataFrame that contains the energies of the walkers at each iteration. The liveset variable is the final liveset after the simulation. Let's see how the walkers look like after the simulation:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"liveset.walkers[1].configuration |> view_structure","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"They should be in a more ordered state, in this case, a cluster, than the initial gaseous state.","category":"page"},{"location":"quick_start/#Calculating-heat-capacity-with-AnalysisTools-module","page":"Quick Start","title":"Calculating heat capacity with AnalysisTools module","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The AnalysisTools module provides functions to calculate the heat capacity of the system. First, we calculate the ω factors, which account for the fractions of phase-space volume sampled during each nested sampling iteration, defined as:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"omega_i = frac1N+1 left(fracNN+1right)^i","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"where N is the number of walkers and i is the iteration number.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ωi = ωᵢ(energies.iter, 120);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's shift the energies to be greater than or equal to zero, making the calculation of the heat capacity more stable.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Ei = energies.emax .- minimum(energies.emax);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Specify the temperatures that we are interested in, in units of Kelvin.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Ts = collect(1:0.1:1000);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Define the Boltzmann constant in units of eV/K.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"kb = 8.617333262e-5 # eV/K","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Calculate the inverse temperatures","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"β = 1 ./(kb.*Ts);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Define the degrees of freedom, which is 3×6 for the 6-particle system.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"dof = 18","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Calculate the heat capacities as a function of temperature using the cv function,","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"C_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"cvs = cv(energies, β, dof, 120);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's plot the heat capacity as a function of temperature","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using Plots\nplot(Ts, cvs./kb, xlabel=\"Temperature (K)\", ylabel=\"Heat Capacity (\\$k_B\\$)\", label=\"LJ\\$_6\\$\")","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The plot should show the heat capacity as a function of temperature for the 6-particle Lennard-Jones system, with a main peak around 400 K, representing the phase transition, and some fluctuations at low temperatures, and tailing off to zero at high temperatures.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"That's it! You have successfully run a nested sampling simulation using the FreeBird.jl package.","category":"page"},{"location":"quick_start/#Lattice-walkers-and-exact-enumeration","page":"Quick Start","title":"Lattice walkers and exact enumeration","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Another feature of FreeBird.jl is the ability to work with lattice systems. The lattice systems are defined by the MLattice which is a parametrized type.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"MLattice{C,G}(\n    lattice_vectors::Matrix{Float64},\n    basis::Vector{Tuple{Float64, Float64, Float64}},\n    supercell_dimensions::Tuple{Int64, Int64, Int64},\n    periodicity::Tuple{Bool, Bool, Bool},\n    components::Vector{Vector{Bool}},\n    adsorptions::Vector{Bool},\n    cutoff_radii::Vector{Float64},\n) where {C,G}","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The C parameter is the number of components in the system, and the G parameter defines the geometry of the lattice.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, let's create a simple square lattice system with single component:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ml = MLattice{1,SquareLattice}(components=[[1,2,3,4]])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"When you run the above code, the outer constructor of MLattice will be called. Many of the arguments are optional and have default values. The components argument is a vector of vectors that defines the components of the system. The components=[[1,2,3,4]] argument specifies that the system has a single component, and the first four sites are occupied.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"MLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,\n    basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],\n    supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),\n    periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n    cutoff_radii::Vector{Float64}=[1.1, 1.5],\n    components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n    adsorptions::Union{Vector{Int},Symbol}=:full)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"You may notice that the above code returns a SLattice type. The SLattice type is simply an alias for the MLattice{1,G}, where G is the geometry of the lattice and the number of components is fixed to 1. You can also directly call the SLattice, it will give the same result:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"sl = SLattice{SquareLattice}(components=[[1,2,3,4]])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now, let's define a Hamiltonian for the lattice system:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\")","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The GenericLatticeHamiltonian type is a struct that holds the parameters of the Hamiltonian. The first argument is the on-site energy, and the second argument is the list of n-th nearest-neighbors energy. The third argument is the unit of the energy.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To run exact enumeration, we only need a initial walker/lattice configuration, and the Hamiltonian. Let's run the exact enumeration:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"df, ls = exact_enumeration(sl, ham)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The results of the exact enumeration are stored in the df and ls variables. The df variable is a DataFrame that contains the list of energies, as well as the configurations. The ls variable is the final liveset that contains all possible configurations of the lattice system. Let's see how the first configuration looks like:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ls.walkers[1].configuration","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"It's the initial configuration of the lattice system. Let's see how the last configuration looks like:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ls.walkers[end].configuration","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Be warned that the exact enumeration can be computationally expensive for large systems.","category":"page"},{"location":"quick_start/#Calculating-heat-capacity","page":"Quick Start","title":"Calculating heat capacity","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Since we enumerated all possible configurations of the lattice system, we can calculate the partition function, then heat capacity directly.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's calculate the heat capacity for the lattice system: Define the temperatures that we are interested in, in units of Kelvin.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Ts = collect(1:0.1:500);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Define the Boltzmann constant in units of eV/K.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"kb = 8.617333262e-5 # eV/K","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Convert them to inverse temperatures","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"βs = 1 ./(kb.*Ts);\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Extract the energies from the DataFrame, keeping the values only","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"es = [e.val for e in df.energy];\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Since this is not a nested sampling run, each configuration carries the same weight:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"ω_1 = ones(length(df.energy));\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"And for a lattice, the degrees of freedom is 0:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"dof = 0","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Now we can use a scaler version of the cv function to calculate the heat capacity:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"cvs = [cv(β, ω_1, es, dof) for β in βs];\nnothing #hide","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Let's plot the heat capacity as a function of temperature","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using Plots\nplot(Ts, cvs./kb, xlabel=\"Temperature (K)\", ylabel=\"Heat Capacity (\\$k_B\\$)\", label=\"Square Lattice\")","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"You should expect to see a single peak in the heat capacity curve around 40 K, and tailing off to zero at high temperatures.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"That's it! You have successfully run an exact enumeration simulation using the FreeBird.jl package.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"This page was generated using Literate.jl.","category":"page"},{"location":"AbstractPotentials/#AbstractPotentials","page":"AbstractPotentials","title":"AbstractPotentials","text":"","category":"section"},{"location":"AbstractPotentials/#Functions","page":"AbstractPotentials","title":"Functions","text":"","category":"section"},{"location":"AbstractPotentials/","page":"AbstractPotentials","title":"AbstractPotentials","text":"Modules = [AbstractPotentials]","category":"page"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials","text":"AbstractPotentials\n\nModule for defining and implementing potentials.\n\n\n\n\n\n","category":"module"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.CompositeLJParameters","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.CompositeLJParameters","text":"struct CompositeLJParameters{C} <: LennardJonesParametersSets\n\nCompositeLJParameters is a struct that represents a set of composite Lennard-Jones parameters.\n\nFields\n\nlj_param_sets::Matrix{LJParameters}: A matrix of LJParameters representing the LJ parameter sets.\n\nType Parameters\n\nC::Int: The number of composite parameter sets.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.CompositeLJParameters-Tuple{Int64, Vector{LJParameters}}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.CompositeLJParameters","text":"CompositeLJParameters(c::Int, ljs::Vector{LJParameters})\n\nConstruct a CompositeLJParameters object from a vector of LJParameters.\n\nArguments\n\nc::Int: The number of components.\nljs::Vector{LJParameters}: A vector of LJParameters. \n\nThe number of elements in the vector must be equal to c^2 or c*(c+1)/2.  The former case is for a full flattened matrix of LJParameters, useful when  the interactions are asymmetric, i.e., epsilon_ij != epsilon_ji. The latter case is for symmetric interactions, i.e., epsilon_ij = epsilon_ji, hence only the upper triangular part of the matrix is needed.\n\nReturns\n\nA CompositeLJParameters object.\n\nExample\n\njulia> ljs = [LJParameters(epsilon=e) for e in [11, 12, 13, 22, 23, 33]]\n6-element Vector{LJParameters}:\n LJParameters(11.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(12.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(13.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(22.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(23.0 eV, 1.0 Å, Inf, 0.0 eV)\n LJParameters(33.0 eV, 1.0 Å, Inf, 0.0 eV)\n\njulia> ljp = CompositeLJParameters(3,ljs)\nCompositeLJParameters{3}(lj_param_sets::3x3 Matrix{LJParameters}):\n    lj_param_sets[1, 1] : LJParameters(11.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[1, 2] : LJParameters(12.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[1, 3] : LJParameters(13.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[2, 1] : LJParameters(12.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[2, 2] : LJParameters(22.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[2, 3] : LJParameters(23.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[3, 1] : LJParameters(13.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[3, 2] : LJParameters(23.0 eV, 1.0 Å, Inf, 0.0 eV)\n    lj_param_sets[3, 3] : LJParameters(33.0 eV, 1.0 Å, Inf, 0.0 eV)\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.LJParameters","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.LJParameters","text":"struct LJParameters\n\nThe LJParameters struct represents the parameters for the Lennard-Jones potential.\n\nFields\n\nepsilon::typeof(1.0u\"eV\"): The energy scale of the potential.\nsigma::typeof(1.0u\"Å\"): The length scale of the potential.\ncutoff::Float64: The cutoff distance for the potential, in units of sigma.\nshift::typeof(0.0u\"eV\"): The energy shift applied to the potential, calculated at the cutoff distance.\n\n\n\n\n\n","category":"type"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.LJParameters-Tuple{}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.LJParameters","text":"LJParameters(;epsilon=1.0, sigma=1.0, cutoff=Inf, shift=true)\n\nA constructor for the LJParameters struct with default values for the  Lennard-Jones potential with no cutoff or shift. The shift parameter can be  specified as a boolean, if true, the shift energy is calculated automatically  at the cutoff distance; or as a typeof(0.0u\"eV\"), in which case the value is used directly.\n\nExample\n\njulia> lj = LJParameters(epsilon=0.1,sigma=2.5,cutoff=3.5,shift=false)\nLJParameters(0.1 eV, 2.5 Å, 3.5, 0.0 eV)\n\njulia> lj = LJParameters(sigma=2.5)\nLJParameters(1.0 eV, 2.5 Å, Inf, 0.0 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=5.0)\nLJParameters(1.0 eV, 1.0 Å, 3.5, 5.0 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=true)\nLJParameters(1.0 eV, 1.0 Å, 3.5, -0.0021747803916549904 eV)\n\njulia> lj = LJParameters(cutoff=3.5,shift=false)\nLJParameters(1.0 eV, 1.0 Å, 3.5, 0.0 eV)\n\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.lj_energy-Tuple{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, LJParameters}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.lj_energy","text":"lj_energy(r::typeof(1.0u\"Å\"), lj::LJParameters)\n\nCompute the Lennard-Jones energy between two particles at a given distance.\n\nArguments\n\nr::typeof(1.0u\"Å\"): The distance between the particles.\nlj::LJParameters: The Lennard-Jones parameters.\n\nReturns\n\n0.0u\"eV\" if the distance is greater than the cutoff distance.\nThe Lennard-Jones energy minus the shift otherwise.\n\n\n\n\n\n","category":"method"},{"location":"AbstractPotentials/#FreeBird.AbstractPotentials.lj_energy-Tuple{Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}, Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}, Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}}","page":"AbstractPotentials","title":"FreeBird.AbstractPotentials.lj_energy","text":"lj_energy(epsilon::typeof(1.0u\"eV\"), sigma::typeof(1.0u\"Å\"), r::typeof(1.0u\"Å\"))\n\nCompute the Lennard-Jones potential energy between two particles.\n\nThe Lennard-Jones potential energy is given by the equation:\n\nV(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right\n\nwhere epsilon is the energy scale, sigma is the distance scale, and r is the distance between the particles.\n\nArguments\n\nepsilon::typeof(1.0u\"eV\"): The energy scale of the potential.\nsigma::typeof(1.0u\"Å\"): The distance scale of the potential.\nr::typeof(1.0u\"Å\"): The distance between the particles.\n\nReturns\n\nThe Lennard-Jones potential energy between the particles.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#MonteCarloMoves","page":"MonteCarloMoves","title":"MonteCarloMoves","text":"","category":"section"},{"location":"MonteCarloMoves/#Functions","page":"MonteCarloMoves","title":"Functions","text":"","category":"section"},{"location":"MonteCarloMoves/","page":"MonteCarloMoves","title":"MonteCarloMoves","text":"Modules = [MonteCarloMoves]","category":"page"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves","text":"MonteCarloMoves\n\nModule containing functions for performing Monte Carlo moves on atomistic/lattice systems.\n\n\n\n\n\n","category":"module"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_new_sample!-Union{Tuple{C}, Tuple{LatticeWalker{C}, ClassicalHamiltonian, Float64}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_new_sample!","text":"MC_new_sample!(lattice::LatticeWalker, h::ClassicalHamiltonian, emax::Float64; energy_perturb::Float64=0.0)\n\nGenerate a new sample for the lattice system.\n\nArguments\n\nlattice::LatticeWalker: The walker to generate a new sample for.\nh::ClassicalHamiltonian: The Hamiltonian containing the on-site and nearest-neighbor interaction energies.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_swap!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParametersSets, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_swap!","text":"MC_random_swap!(n_steps::Int, at::AtomWalker{C}, lj::LennardJonesParametersSets, emax::typeof(0.0u\"eV\"))\n\nPerform a Monte Carlo random swap of two atoms in the AtomWalker. Only works when there are two or more non-frozen components.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The AtomWalker object.\nlj::LennardJonesParametersSets: The Lennard-Jones parameters.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker{C}: The updated AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Tuple{Int64, LatticeWalker{1}, ClassicalHamiltonian, Float64}","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, lattice::LatticeWalker, h::ClassicalHamiltonian, emax::Float64; energy_perturb::Float64=0.0)\n\nPerform a Monte Carlo random walk on the lattice system.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nlattice::LatticeWalker: The walker to perform the random walk on.\nh::ClassicalHamiltonian: The lattice gas Hamiltonian.\nemax::Float64: The maximum energy allowed for accepting a move.\nenergy_perturb::Float64=0.0: The energy perturbation used to make degenerate configurations distinguishable.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nlattice::LatticeWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParametersSets, Float64, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk!","text":"MC_random_walk!(n_steps::Int, at::AtomWalker, lj::LJParameters, step_size::Float64, emax::typeof(0.0u\"eV\"))\n\nPerform a Monte Carlo random walk on the atomic/molecular system.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\nlj::LennardJonesParametersSets: The Lennard-Jones potential parameters.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.MC_random_walk_2D!-Union{Tuple{C}, Tuple{Int64, AtomWalker{C}, LennardJonesParametersSets, Float64, Quantity{Float64, 𝐋^2 𝐌 𝐓^-2, Unitful.FreeUnits{(eV,), 𝐋^2 𝐌 𝐓^-2, nothing}}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.MC_random_walk_2D!","text":"MC_random_walk_2D!(n_steps::Int, at::AtomWalker, lj::LJParameters, step_size::Float64, emax::typeof(0.0u\"eV\"); dims::Vector{Int}=[1,2])\n\nPerform a Monte Carlo random walk on the atomic/molecular system in 2D.\n\nArguments\n\nn_steps::Int: The number of Monte Carlo steps to perform.\nat::AtomWalker{C}: The walker to perform the random walk on.\nlj::LennardJonesParametersSets: The Lennard-Jones potential parameters.\nstep_size::Float64: The maximum distance an atom can move in any direction.\nemax::typeof(0.0u\"eV\"): The maximum energy allowed for accepting a move.\ndims::Vector{Int}=[1,2]: The dimensions in which the random walk is performed.\n\nReturns\n\naccept_this_walker::Bool: Whether the walker is accepted or not.\naccept_rate::Float64: The acceptance rate of the random walk.\nat::AtomWalker: The updated walker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.free_component_index-Union{Tuple{AtomWalker{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.free_component_index","text":"free_component_index(at::AtomWalker{C}) where C\n\nGet the indices of the free particles in each component of the AtomWalker.\n\nReturns\n\nind_free_parts::Array{Vector{Int}}: An array of vectors containing the indices of the free particles in each component.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.free_par_index-Union{Tuple{AtomWalker{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.free_par_index","text":"free_par_index(at::AtomWalker{C}) where C\n\nGet the indices of the free particles in the AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!-Tuple{SLattice}","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!","text":"generate_random_new_lattice_sample!(lattice::SLattice)\n\nGenerate a new random sample for the single-component lattice system.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.generate_random_new_lattice_sample!","text":"generate_random_new_lattice_sample!(lattice::MLattice{C}) where C\n\nGenerate a new random sample for the multi-component lattice system.\n\nArguments\n\nlattice::MLattice{C}: The lattice system to generate a new sample for.\n\nReturns\n\nlattice::MLattice{C}: The updated lattice system.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.mean_sq_displacement-Union{Tuple{C}, Tuple{AtomWalker{C}, AtomWalker{C}}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.mean_sq_displacement","text":"mean_sq_displacement(at::AtomWalker, at_orig::AtomWalker)\n\nCalculate the mean squared displacement before and after random walk(s). Note that due to the current implementation of the periodic boundary wrap, this function is not appropriate to use for calculating mean displacements in a propagation.\n\nArguments\n\nat::AtomWalker{C}: The current AtomWalker after the random walk.\nat_orig::AtomWalker{C}: The original AtomWalker before the random walk.\n\nReturns\n\ndistsq::typeof(0.0u\"Å\"^2): The mean squared displacement of all free particles.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.periodic_boundary_wrap!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, AtomsBase.AbstractSystem}} where T","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.periodic_boundary_wrap!","text":"periodic_boundary_wrap!(pos::SVector{3,T}, system::AbstractSystem) where T\n\nWrap the position vector pos according to the periodic boundary conditions of the system. If the boundary condition is Periodic(), the position is wrapped using the modulo operator. If the boundary condition is DirichletZero(), the position is wrapped by reflecting the position vector across the boundary.\n\nArguments\n\npos::SVector{3,T}: The position vector to be wrapped.\nsystem::AbstractSystem: The system containing the periodic boundary conditions.\n\nReturns\n\nThe wrapped position vector.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.single_atom_random_walk!-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Float64}} where T","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.single_atom_random_walk!","text":"single_atom_random_walk!(pos::SVector{3,T}, step_size::Float64) where T\n\nPerform a single atom random walk by updating the position pos in each direction by a random amount. The step_size determines the maximum distance the atom can move in any direction.\n\nArguments\n\npos::SVector{3,T}: The current position of the atom as a 3D vector.\nstep_size::Float64: The maximum distance the atom can move in any direction.\n\nReturns\n\npos: The updated position of the atom.\n\n\n\n\n\n","category":"method"},{"location":"MonteCarloMoves/#FreeBird.MonteCarloMoves.two_atoms_swap!-Union{Tuple{C}, Tuple{AtomWalker{C}, Any, Any}} where C","page":"MonteCarloMoves","title":"FreeBird.MonteCarloMoves.two_atoms_swap!","text":"two_atoms_swap!(at::AtomWalker{C}, ind1, ind2) where C\n\nSwap the positions of two atoms in the AtomWalker.\n\nArguments\n\nat::AtomWalker{C}: The AtomWalker object.\nind1::Int: The index of the first atom.\nind2::Int: The index of the second atom.\n\nReturns\n\nat::AtomWalker{C}: The updated AtomWalker.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#Analysis-Tools","page":"AnalysisTools","title":"Analysis Tools","text":"","category":"section"},{"location":"AnalysisTools/#Functions","page":"AnalysisTools","title":"Functions","text":"","category":"section"},{"location":"AnalysisTools/","page":"AnalysisTools","title":"AnalysisTools","text":"Modules = [AnalysisTools]","category":"page"},{"location":"AnalysisTools/#FreeBird.AnalysisTools","page":"AnalysisTools","title":"FreeBird.AnalysisTools","text":"AnalysisTools\n\nModule for analyzing the output of the sampling.\n\n\n\n\n\n","category":"module"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{DataFrames.DataFrame, Vector{Float64}, Int64, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(df::DataFrame, βs::Vector{Float64}, dof::Int, n_walkers::Int)\n\nCalculates the constant-volume heat capacity at constant volume for the given DataFrame, inverse temperatures, degrees of freedom, and number of walkers. The heat capacity is defined as:\n\nC_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)\n\nwhere mathrmdof is the degrees of freedom, k_B is the Boltzmann constant (in units of eV/K), beta is the inverse temperature, omega_i is the i-th omega factor, E_i is the i-th energy, Z(beta) is the partition function, and U(beta) is the internal energy.\n\nArguments\n\ndf::DataFrame: The DataFrame containing the output data.\nβs::Vector{Float64}: The inverse temperatures.\ndof::Int: The degrees of freedom, equals to the number of dimensions times the number of particles.\nn_walkers::Int: The number of walkers.\nω0::Float64: The initial omega factor. Default is 1.0.\n\nReturns\n\nA vector of constant-volume heat capacities.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.cv-Tuple{Float64, Vector{Float64}, Vector{Float64}, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.cv","text":"cv(β::Float64, omega_i::Vector{Float64}, Ei::Vector{Float64}, dof::Int)\n\nCalculates the constant-volume heat capacity for the given beta, omega factors, energies, and degrees of freedom. The heat capacity is defined as:\n\nC_V(beta) = fracmathrmdof cdot k_B2 + k_B beta^2 left(fracsum_i omega_i E_i^2 exp(-E_i beta)Z(beta) - U(beta)^2right)\n\nwhere mathrmdof is the degrees of freedom, k_B is the Boltzmann constant (in units of eV/K), beta is the inverse temperature,  omega_i is the i-th omega factor, E_i is the i-th energy, Z(beta) is the partition function, and U(beta) is the internal energy.\n\nArguments\n\nβ::Float64: The inverse temperature.\nωi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies in eV.\ndof::Int: The degrees of freedom, equals to the number of dimensions times the number of particles.\n\nReturns\n\nThe constant-volume heat capacity.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.internal_energy-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.internal_energy","text":"internal_energy(β::Float64, ωi::Vector{Float64}, ei::Vector{Float64})\n\nCalculates the internal energy from the partition function for the given beta, omega factors, and energies. The internal energy is defined as:\n\nU(beta) = fracsum_i omega_i E_i exp(-E_i beta)sum_i omega_i exp(-E_i beta)\n\nwhere omega_i is the i-th omega factor, E_i is the i-th energy, and beta is the inverse temperature.\n\nArguments\n\nβ::Float64: The inverse temperature.\nωi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies in eV.\n\nReturns\n\nThe internal energy.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.partition_function-Tuple{Float64, Vector{Float64}, Vector{Float64}}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.partition_function","text":"partition_function(β::Float64, ωi::Vector{Float64}, Ei::Vector{Float64})\n\nCalculates the partition function for the given beta, omega factors, and energies. The partition function is defined as:\n\nZ(beta) = sum_i omega_i exp(-E_i beta)\n\nwhere omega_i is the i-th omega factor, E_i is the i-th energy, and beta is the inverse temperature.\n\nArguments\n\nβ::Float64: The inverse temperature.\nωi::Vector{Float64}: The omega factors.\nEi::Vector{Float64}: The energies.\n\nReturns\n\nThe partition function.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.read_output-Tuple{String}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.read_output","text":"read_output(filename::String)\n\nReads the output file and returns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"AnalysisTools/#FreeBird.AnalysisTools.ωᵢ-Tuple{Vector{Int64}, Int64}","page":"AnalysisTools","title":"FreeBird.AnalysisTools.ωᵢ","text":"ωᵢ(iters::Vector{Int}, n_walkers::Int)\n\nCalculates the omega factors for the given number of iterations and walkers. The omega factors account for the fractions of phase-space volume sampled during each nested sampling iteration, defined as:\n\nomega_i = frac1N+1 left(fracNN+1right)^i\n\nwhere N is the number of walkers and i is the iteration number.\n\nArguments\n\niters::Vector{Int}: The iteration numbers.\nn_walkers::Int: The number of walkers.\nω0::Float64: The initial omega factor. Default is 1.0.\n\nReturns\n\nA vector of omega factors.\n\n\n\n\n\n","category":"method"},{"location":"AbstractHamiltonians/#AbstractHamiltonians","page":"AbstractHamiltonians","title":"AbstractHamiltonians","text":"","category":"section"},{"location":"AbstractHamiltonians/#Functions","page":"AbstractHamiltonians","title":"Functions","text":"","category":"section"},{"location":"AbstractHamiltonians/","page":"AbstractHamiltonians","title":"AbstractHamiltonians","text":"Modules = [AbstractHamiltonians]","category":"page"},{"location":"AbstractHamiltonians/#FreeBird.AbstractHamiltonians","page":"AbstractHamiltonians","title":"FreeBird.AbstractHamiltonians","text":"AbstractHamiltonians\n\nModule for defining and implementing Hamiltonians.\n\n\n\n\n\n","category":"module"},{"location":"AbstractHamiltonians/#FreeBird.AbstractHamiltonians.GenericLatticeHamiltonian","page":"AbstractHamiltonians","title":"FreeBird.AbstractHamiltonians.GenericLatticeHamiltonian","text":"struct GenericLatticeHamiltonian{N,U} <: ClassicalHamiltonian\n\nThe GenericLatticeHamiltonian struct represents a generic lattice Hamiltonian.  It has an on-site interaction energy and a N-elements vector of nth-neighbor interaction energies. Units of energy U is also specified.\n\nFields\n\non_site_interaction::U: The energy of on-site interactions.\nnth_neighbor_interactions::SVector{N, U}: The energy of nth-neighbor interactions.\n\nConstructors\n\nGenericLatticeHamiltonian(on_site_interaction::Float64, nth_neighbor_interactions::Vector{Float64}, energy_units::Unitful.Units)\nGenericLatticeHamiltonian(on_site_interaction::U, nth_neighbor_interactions::Vector{U}) where U\n\nExamples\n\njulia> ham = GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\")\nGenericLatticeHamiltonian{2,Quantity{Float64, 𝐋² 𝐌 𝐓⁻², Unitful.FreeUnits{(eV,), 𝐋² 𝐌 𝐓⁻², nothing}}}:\n    on_site_interaction:      -0.04 eV\n    nth_neighbor_interactions: [-0.01, -0.0025] eV\n\n\njulia> ham = GenericLatticeHamiltonian(-0.04u\"eV\", [-0.01, -0.0025]*u\"eV\")\nGenericLatticeHamiltonian{2,Quantity{Float64, 𝐋² 𝐌 𝐓⁻², Unitful.FreeUnits{(eV,), 𝐋² 𝐌 𝐓⁻², nothing}}}:\n    on_site_interaction:      -0.04 eV\n    nth_neighbor_interactions: [-0.01, -0.0025] eV\n\n\n\n\n\n","category":"type"},{"location":"AbstractHamiltonians/#FreeBird.AbstractHamiltonians.MLatticeHamiltonian","page":"AbstractHamiltonians","title":"FreeBird.AbstractHamiltonians.MLatticeHamiltonian","text":"    struct MLatticeHamiltonian{C,N,U} <: ClassicalHamiltonian\n\nThe MLatticeHamiltonian struct represents a multi-component lattice Hamiltonian. It has a matrix of GenericLatticeHamiltonian{N,U}.\n\nFields\n\nHamiltonians::Matrix{GenericLatticeHamiltonian{N,U}}: The matrix of GenericLatticeHamiltonian{N,U}.\n\nConstructors\n\nMLatticeHamiltonian(Hamiltonians::Vector{GenericLatticeHamiltonian{N,U}})\n\nExamples\n\njulia> hams = [GenericLatticeHamiltonian(-0.04, [-0.01, -0.0025], u\"eV\") for i in 1:4]\njulia> mlham = MLatticeHamiltonian(hams)\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#AbstractWalkers","page":"AbstractWalkers","title":"AbstractWalkers","text":"","category":"section"},{"location":"AbstractWalkers/#Functions","page":"AbstractWalkers","title":"Functions","text":"","category":"section"},{"location":"AbstractWalkers/","page":"AbstractWalkers","title":"AbstractWalkers","text":"Modules = [AbstractWalkers]","category":"page"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers","text":"AbstractWalkers\n\nModule containing abstract definitions for walkers.\n\n\n\n\n\n","category":"module"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.AtomWalker","text":"mutable struct AtomWalker\n\nThe AtomWalker struct represents a walker composed of atoms/molecules.\n\nFields\n\nconfiguration::FastSystem: The configuration of the walker.\nenergy::typeof(0.0u\"eV\"): The energy of the walker.\niter::Int64: The current iteration number of the walker.\nlist_num_par::Vector{Int64}: The list of the number of particles for each component.\nfrozen::Vector{Bool}: A boolean vector indicating whether each component is frozen or not.\nenergy_frozen_part::typeof(0.0u\"eV\"): The energy of the frozen particles in the walker, serves as a constant energy offset   to the interacting part of the system.\n\nConstructor\n\nAtomWalker(configuration::FastSystem; energy=0.0u\"eV\", iter=0, list_num_par=zeros(Int,C), frozen=zeros(Bool,C), energy_frozen_part=0.0u\"eV\"):    Constructs a new AtomWalker object with the given configuration and optional parameters.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.AtomWalker-Tuple{AtomsBase.FastSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.AtomWalker","text":"AtomWalker(configuration::FastSystem; freeze_species::Vector{Symbol}=Symbol[], merge_same_species=true)\n\nConstructs an AtomWalker object with the given configuration.\n\nArguments\n\nconfiguration::FastSystem: The configuration of the walker.\nfreeze_species::Vector{Symbol}: A vector of species to freeze.\nmerge_same_species::Bool: A boolean indicating whether to merge the same species into one component.\n\nReturns\n\nAtomWalker{C}: The constructed AtomWalker object.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"Å\"\n\n        .--------------.  \n       /|Fel           |  \n      / H   H   Cl     |  \n     /  Hu   O         |  \n    *   |       Au   Fe|  \n    |   |FeCl        Fe|  \n    |   |        Au    |  \n    |   .---------Au---.  \n    |  /           H  /   \n    | Au Cl          /    \n    |/              /     \n    *--------------*      \n\njulia> AtomWalker(at;freeze_species=[:H],merge_same_species=false)\nAtomWalker{6}(FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"), 0.0 eV, 0, [2, 3, 1, 6, 4, 5], Bool[1, 1, 0, 0, 0, 0], 0.0 eV)\n\njulia> AtomWalker(at;freeze_species=[:H],merge_same_species=true)\nAtomWalker{5}(FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"), 0.0 eV, 0, [5, 1, 6, 4, 5], Bool[1, 0, 0, 0, 0], 0.0 eV)\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.LatticeGeometry","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.LatticeGeometry","text":"abstract type LatticeGeometry\n\nThe LatticeGeometry abstract type represents the geometry of a lattice. It has the following subtypes:\n\nSquareLattice: A square lattice.\nTriangularLattice: A triangular lattice.\nGenericLattice: A generic lattice. Currently used for non-square and non-triangular lattices.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.LatticeWalker","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.LatticeWalker","text":"mutable struct LatticeWalker\n\nThe LatticeWalker struct represents a walker on a 3D lattice.\n\nFields\n\nconfiguration::AbstractLattice: The configuration of the walker.\nenergy::Float64: The energy of the walker.\niter::Int64: The current iteration number of the walker.\n\nConstructor\n\nLatticeWalker(configuration::AbstractLattice; energy=0.0, iter=0)\n\nCreate a new LatticeWalker with the given configuration and optional energy and iteration number.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.MLattice","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.MLattice","text":"mutable struct MLattice{C,G}\n\nA mutable struct representing a lattice with the following fields:\n\nlattice_vectors::Matrix{Float64}: The lattice vectors defining the unit cell.\npositions::Matrix{Float64}: The positions of the lattice points.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis vectors within the unit cell.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\nperiodicity::Tuple{Bool, Bool, Bool}: The periodicity in each dimension.\ncomponents::Vector{Vector{Bool}}: The components of the lattice.\nneighbors::Vector{Vector{Vector{Int}}}: The neighbors of each lattice point.\nadsorptions::Vector{Bool}: The adsorption sites on the lattice.\n\nInner Constructor\n\nMLattice{C,G}(\n    lattice_vectors::Matrix{Float64},\n    basis::Vector{Tuple{Float64, Float64, Float64}},\n    supercell_dimensions::Tuple{Int64, Int64, Int64},\n    periodicity::Tuple{Bool, Bool, Bool},\n    components::Vector{Vector{Bool}},\n    adsorptions::Vector{Bool},\n    cutoff_radii::Vector{Float64},\n) where {C,G}\n\nCreates an MLattice instance with the specified parameters. The constructor performs the following steps:\n\nValidates that the number of components matches the expected value C.\nComputes the positions of the lattice points using lattice_positions.\nComputes the supercell lattice vectors.\nComputes the neighbors of each lattice point using compute_neighbors.\n\nThrows an ArgumentError if the number of components does not match C.\n\nOuter Constructors\n\nMLattice{C,SquareLattice}(; lattice_constant::Float64=1.0,\n                           basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0)],\n                           supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 4, 1),\n                           periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n                           cutoff_radii::Vector{Float64}=[1.1, 1.5],\n                           components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n                           adsorptions::Union{Vector{Int},Symbol}=:full)\n\nMLattice{C,TriangularLattice}(; lattice_constant::Float64=1.0,\n                              basis::Vector{Tuple{Float64,Float64,Float64}}=[(0.0, 0.0, 0.0),(1/2, sqrt(3)/2, 0.0)],\n                              supercell_dimensions::Tuple{Int64,Int64,Int64}=(4, 2, 1),\n                              periodicity::Tuple{Bool,Bool,Bool}=(true, true, false),\n                              cutoff_radii::Vector{Float64}=[1.1, 1.5],\n                              components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}=:equal,\n                              adsorptions::Union{Vector{Int},Symbol}=:full)\n\nConstructs a square/triangular lattice with the specified parameters. The components and adsorptions arguments can be a vector of integers specifying the indices of the occupied sites, or a symbol. If components is :equal, the lattice is divided into C equal components when possible, or  nearest to equal components otherwise. If adsorptions is :full, all sites are classified as adsorption sites.\n\nReturns\n\nMLattice{C,G}: A square/triangular lattice object with C components.\n\n\n\n\n\n","category":"type"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.check_num_components-Tuple{Int64, Vector{Int64}, Vector{Bool}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.check_num_components","text":"check_num_components(C::Int, list_num_par::Vector{Int}, frozen::Vector{Bool})\n\nCheck that the number of components matches the length of the list of number of particles and frozen particles.\n\nArguments\n\nC::Int: The number of components.\nlist_num_par::Vector{Int}: The number of particles in each component.\nfrozen::Vector{Bool}: A vector indicating whether each component is frozen.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.custom_sort-Tuple{Vector{Int64}, Int64}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.custom_sort","text":"custom_sort(arr::Vector{Int}, period::Int)\n\nSorts [1,2,3,4,5,6,7,8] into [1,3,5,7,2,4,6,8] for period = 2. Useful for printing triangular lattices.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.lattice_positions-Tuple{Matrix{Float64}, Vector{Tuple{Float64, Float64, Float64}}, Tuple{Int64, Int64, Int64}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.lattice_positions","text":"latticepositions(latticevectors::Matrix{Float64}, basis::Vector{Tuple{Float64, Float64, Float64}}, supercell_dimensions::Tuple{Int64, Int64, Int64})\n\nCompute the positions of atoms in a 3D lattice.\n\nArguments\n\nlattice_vectors::Matrix{Float64}: The lattice vectors of the system.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis of the system.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\n\nReturns\n\npositions::Matrix{Float64}: The positions of the atoms in the supercell.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.merge_components-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.merge_components","text":"merge_components(lattice::MLattice{C}) where C\n\nMerges the boolvec of components into a single vector of integers, where each integer represents the component number.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.mlattice_setup-Tuple{Int64, Vector{Tuple{Float64, Float64, Float64}}, Tuple{Int64, Int64, Int64}, Union{Vector{Vector{Bool}}, Vector{Vector{Int64}}, Symbol}, Union{Vector{Bool}, Vector{Int64}, Symbol}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.mlattice_setup","text":"mlattice_setup(C::Int, \n                 basis::Vector{Tuple{Float64, Float64, Float64}},\n                 supercell_dimensions::Tuple{Int64, Int64, Int64},\n                 components::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol},\n                 adsorptions::Union{Vector{Int}, Vector{Bool}, Symbol})\n\nSetup the components and adsorptions for a lattice.\n\nArguments\n\nC::Int: The number of components.\nbasis::Vector{Tuple{Float64, Float64, Float64}}: The basis of the lattice.\nsupercell_dimensions::Tuple{Int64, Int64, Int64}: The dimensions of the supercell.\ncomponents::Union{Vector{Vector{Int64}},Vector{Vector{Bool}},Symbol}: The components of the lattice.\nadsorptions::Union{Vector{Int}, Vector{Bool}, Symbol}: The adsorption sites on the lattice.\n\nReturns\n\nlattice_comp::Vector{Vector{Bool}}: The components of the lattice.\nlattice_adsorptions::Vector{Bool}: The adsorption sites on the lattice.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.num_sites-Tuple{AbstractLattice}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.num_sites","text":"num_sites(lattice::AbstractLattice)\n\nReturns the total number of sites in a lattice given a AbstractLattice object. Returns the total number of sites.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.occupied_site_count-Union{Tuple{MLattice{C}}, Tuple{C}} where C","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.occupied_site_count","text":"occupied_site_count(MLattice::MLattice{C})\n\nReturns the number of occupied sites in each component of a lattice in an array.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.sort_components_by_atomic_number-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.sort_components_by_atomic_number","text":"sort_components_by_atomic_number(at::AbstractSystem; merge_same_species=true)\n\nSorts the components of an AbstractSystem object at by their atomic number.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem object.\n\nKeyword Arguments\n\nmerge_same_species::Bool=true: Whether to merge components with the same species.\n\nReturns\n\nlist_num_par::Vector{Int64}: A vector containing the number of each component species.\nnew_list::FastSystem: A new FastSystem object with the sorted components.\n\nThe function first extracts the atomic numbers of the components in at. If merge_same_species is true, it sorts the unique species and counts the number of each species. If merge_same_species is false, it creates a list of species and their counts. It then sorts the species and counts by atomic number. Finally, it constructs a new FastSystem object with the sorted components and returns the list of species counts and the new FastSystem object.\n\nExamples\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"Å\"\n\n        .--------------.  \n       /|     Cl    H  |  \n      / |      Fe      |  \n     /  |  Au     FeH  |  \n    *   |   FeH  ACl   |  \n    |   |    Cl     Au |  \n    |   |            O |  \n    |   .--Fe----------.  \n    |  /H  Cl         /   \n    | /          Au  /    \n    |/Cl          Cl/     \n    *--------------*      \n\n\njulia> AbstractWalkers.sort_components_by_atomic_number(at; merge_same_species=false)\n([2, 3, 1, 6, 4, 5], FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"))\n\njulia> AbstractWalkers.sort_components_by_atomic_number(at)\n([5, 1, 6, 4, 5], FastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\"))\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_components-Tuple{AtomsBase.AbstractSystem, Vector{Int64}}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_components","text":"split_components(at::AbstractSystem, list_num_par::Vector{Int})\n\nSplit the system into components based on the number of particles in each component.\n\nArguments\n\nat::AbstractSystem: The system to split.\nlist_num_par::Vector{Int}: The number of particles in each component.\n\nReturns\n\ncomponents: An array of FastSystem objects representing the components of the system.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_components_by_chemical_species-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_components_by_chemical_species","text":"split_components_by_chemical_species(at::AbstractSystem)\n\nSplit an AbstractSystem into multiple components based on the chemical species.\n\nArguments\n\nat::AbstractSystem: The input AbstractSystem to be split.\n\nReturns\n\nAn array of FastSystem objects, each representing a component of the input system.\n\nExample\n\njulia> at = FreeBirdIO.generate_multi_type_random_starting_config(10.0,[2,1,3,4,5,6];particle_types=[:H,:O,:H,:Fe,:Au,:Cl])\nFastSystem(Au₅Cl₆Fe₄H₅O, periodic = FFF):\n    bounding_box      : [ 5.94392        0        0;\n                                0  5.94392        0;\n                                0        0  5.94392]u\"Å\"\n\n        .--------------.  \n       /Au      Cl     |  \n      / |HAu Fe        |  \n     /  |     Cl Cl Cl |  \n    *   |Cle           |  \n    |   | Cl      H    |  \n    |   |      OAuH    |  \n    |FeFe-----------H--.  \n    |  /          Au  /   \n    | /      Au      /    \n    |/              /     \n    *--------------*      \n\n\njulia> AbstractWalkers.split_components_by_chemical_species(at)\n5-element Vector{FastSystem}:\n FastSystem(H₅, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(O, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(Cl₆, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(Fe₄, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n FastSystem(Au₅, periodic = FFF, bounding_box = [[5.943921952763129, 0.0, 0.0], [0.0, 5.943921952763129, 0.0], [0.0, 0.0, 5.943921952763129]]u\"Å\")\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.split_into_subarrays-Tuple{AbstractVector, Int64}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.split_into_subarrays","text":"split_into_subarrays(arr::AbstractVector, N::Int)\n\nSplit an array into N subarrays of approximately equal size.\n\nArguments\n\narr::AbstractVector: The array to split.\nN::Int: The number of subarrays to create.\n\nReturns\n\nsubarrays::Vector{Vector{eltype(arr)}}: A vector of subarrays.\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.update_walker!-Tuple{AtomWalker, Symbol, Any}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.update_walker!","text":"update_walker!(walker::AtomWalker, key::Symbol, value)\n\nUpdate the properties of an AtomWalker object.\n\nA convenient function that updates the value of a specific property of an AtomWalker object.\n\nArguments\n\nwalker::AtomWalker: The AtomWalker object to be updated.\nkey::Symbol: The key of the property to be updated.\nvalue: The new value of the property.\n\nReturns\n\nwalker::AtomWalker: The updated AtomWalker object.\n\nExample\n\nupdate_walker!(walker, :energy, 10.0u\"eV\")\nupdate_walker!(walker, :iter, 1)\n\n\n\n\n\n","category":"method"},{"location":"AbstractWalkers/#FreeBird.AbstractWalkers.view_structure-Tuple{AtomsBase.AbstractSystem}","page":"AbstractWalkers","title":"FreeBird.AbstractWalkers.view_structure","text":"view_structure(at::AbstractSystem)\nview_structure(walker::AtomWalker)\n\nPrint an ASCII representation of the system.\n\n\n\n\n\n","category":"method"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"#FreeBird.jl","page":"FreeBird.jl","title":"FreeBird.jl","text":"","category":"section"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Documentation for FreeBird.jl","category":"page"},{"location":"#Installation","page":"FreeBird.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"FreeBird.jl is a Julia package. Install Julia first following the instructions in the download page.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Once Julia is installed, you can install the FreeBird package from the Julia REPL with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"julia> ] # press the \"]\" key on your keyboard to enter the Pkg manager","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"then","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"pkg> add FreeBird","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Alternatively, you can install the package with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"using Pkg; Pkg.add(\"FreeBird\")","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Useful for installing the package in a script or a notebook.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Or, if you want to install a specific branch from GitHub, you can do so with:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"pkg> add https://github.com/wexlergroup/FreeBird.jl#branch_name","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Or, again, to install the package in a script or a notebook:","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"using Pkg; Pkg.add(url=\"https://github.com/wexlergroup/FreeBird.jl\",rev=\"branch_name\")","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"Remember to replace branch_name with the name of the branch you want to install.","category":"page"},{"location":"","page":"FreeBird.jl","title":"FreeBird.jl","text":"To get back to the Julia REPL, press Ctrl+C or backspace (when the REPL cursor is at the beginning of the input).","category":"page"}]
}
